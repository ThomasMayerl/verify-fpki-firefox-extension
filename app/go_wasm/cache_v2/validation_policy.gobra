package cache_v2

import (
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
	"time"
	
	"fpki/pkg/common"
	"net/publicsuffix"
)

// create new PolicyTrustInfo
requires len(certificateChain) > 0
requires forall k int :: {&certificateChain[k]} 0 <= k && k < len(certificateChain) ==> acc(&certificateChain[k]) 
requires acc(certificateChain[len(certificateChain)-1])
requires let e2ld := publicsuffix.EffectiveTLDPlusOne(dnsName) in (e2ld in domain(policyDnsNameCache))
ensures acc_trustInfo(res, policyDnsNameCache)
func NewPolicyTrustInfo(dnsName string, certificateChain []*x509.Certificate, ghost policyDnsNameCache dict[string][]string) (res *PolicyTrustInfo) { // Added return param name
	policyTrustInfo := &PolicyTrustInfo{
		DNSName:                     dnsName,
		CertificateChain:            certificateChain,
		PolicyChain:                 nil,
		ConflictingPolicyAttributes: nil,
		PolicyChainTrustLevel:       0,
		EvaluationResult:            0,
		MaxValidity:                 time.Unix(0, 0),
		DomainExcluded:              false,
	}
	fold acc_trustInfo(policyTrustInfo, policyDnsNameCache)
	return policyTrustInfo
}

type PolicyTrustPreference struct {
	// PCA public keys
	PCAPublicKey string

	// TODO (cyrill): also implement setting the trust preferences for specific policy certificate
	// // Immutable hash of PCA certificate
	// PCAImmutableHash string

	// map CA set to TrustLevel
	TrustLevel int
}

type ConflictingPolicyAttribute struct {
	Domain    string
	Attribute *common.PolicyAttributes
}

type PolicyTrustInfo struct {
	// domain name used in the connection
	DNSName string

	// certificate chain received during the connection establishment
	CertificateChain []*x509.Certificate

	// CA set ID's and example subjects, and trust level of the
	// cached certificate chains that led to a failed
	// validation
	// (might be useful to construct error messages)

	// json encoded policy certifcates
	PolicyChain                 []*common.PolicyCertificate
	ConflictingPolicyAttributes []*ConflictingPolicyAttribute
	PolicyChainTrustLevel       int `default:"0"`

	// result of legacy validation
	// a value of 1 indicates that validation
	// was passed.
	// a value != 1 indicates failed validation
	EvaluationResult int `default:"0"`

	// timestamp indicating how long this
	// legacy validation outcome can be cached
	MaxValidity time.Time

	// true if the most specific policy (i.e., highest number of subdomains) added DNSName (or a
	// parent of DNSName) as an excluded subdomain where no policy attributes are applied
	DomainExcluded bool
}

// maps a domain name to a set of legacy trust preferences
// to be used to compute certificate chain trust levels
// TODO Unused? Only breaks verification because of assigning to global variables, but we never read from it
// var policyTrustPreferences = map[string][]*PolicyTrustPreference{}

type PolicyCertificateChain struct {
	PolicyCertificates                       []*common.PolicyCertificate
	DomainRootIssuanceTimestamp              time.Time
	DomainRootMinMaxTimestamp                time.Time
	RootAndIntermediateLatestMinMaxTimestamp time.Time
	DomainLatestMinMaxTimestamp              time.Time
	TrustLevel                               int

	// DisseminationTime  time.Time
}

requires policyPerms > 0
preserves forall k int :: {&pcChain.PolicyCertificates[k]} 0 <= k && k < len(pcChain.PolicyCertificates) ==> (acc(&pcChain.PolicyCertificates[k]) && (forall l int :: {&pcChain.PolicyCertificates[l]} 0 <= l && l < len(pcChain.PolicyCertificates) && k != l ==> &pcChain.PolicyCertificates[k] != &pcChain.PolicyCertificates[l]) && acc(pcChain.PolicyCertificates[k]/*getCertificatePerm(pcChain.PolicyCertificates[k])*/, policyPerms))// && acc(&pcChain.PolicyCertificates[k].PolicyAttributes))
func (pcChain PolicyCertificateChain) String(ghost policyPerms perm) string {
	str := fmt.Sprintf("<PolicyCertificateChain len=%d", len(pcChain.PolicyCertificates))
	str += fmt.Sprintf(", DomainRootIssuanceTimestamp=%v", pcChain.DomainRootIssuanceTimestamp)
	str += fmt.Sprintf(", DomainRootMinMaxTimestamp=%v", pcChain.DomainRootMinMaxTimestamp)
	str += fmt.Sprintf(", RootAndIntermediateLatestMinMaxTimestamp=%v", pcChain.RootAndIntermediateLatestMinMaxTimestamp)
	str += ", certs="
	invariant forall k int :: 0 <= k && k < len(pcChain.PolicyCertificates) ==> (acc(&pcChain.PolicyCertificates[k]) && (forall l int :: {&pcChain.PolicyCertificates[l]} 0 <= l && l < len(pcChain.PolicyCertificates) && k != l ==> &pcChain.PolicyCertificates[k] != &pcChain.PolicyCertificates[l]) && acc(pcChain.PolicyCertificates[k], policyPerms))
	invariant 0 <= i && i <= len(pcChain.PolicyCertificates)
	//for _, pc := range pcChain.PolicyCertificates {
	for i := 0; i < len(pcChain.PolicyCertificates); i++ {
		pc := pcChain.PolicyCertificates[i]
		if pc == nil {
			str += "nil, "
			continue
		}
		attributes, err := json.Marshal(pc.PolicyAttributes)
		if err != nil {
			break
		}
		pcStr := fmt.Sprintf("<Policy domain=%s, attributes=%s, #SPCTs=%d, hash=%s, immHash=%s >", pc.Domain(), attributes, len(pc.SPCTs), getPolicyHash(pc, policyPerms / 2), getImmutablePolicyHash(pc, policyPerms / 2))
		// pcStr, err := common.ToJSON(pc)
		// if err != nil {
		// break
		// }
		str += fmt.Sprintf("%s, ", pcStr)
	}
	return str + ">"
}

ensures acc(res) && len(res.PolicyCertificates) == 0
func NewPolicyCertificateChain() (res *PolicyCertificateChain) { // Named return variable for postcondition
	return &PolicyCertificateChain{
		PolicyCertificates:                       []*common.PolicyCertificate{},
		DomainRootIssuanceTimestamp:              time.Unix(0, 0),
		DomainRootMinMaxTimestamp:                time.Unix(0, 0),
		RootAndIntermediateLatestMinMaxTimestamp: time.Unix(0, 0),
		DomainLatestMinMaxTimestamp:              time.Unix(0, 0),
		TrustLevel:                               0,
	}
}

// initialize legacyTrustPreferences with a config
// TODO Unused? Only breaks verification because of assigning to global variables, but we never read from it
/* func InitializePolicyTrustPreferences(configMap map[string]interface{}) {
	policyTrustPreferences = map[string][]*PolicyTrustPreference{}

	// parse policy CA sets
	pcaSetsMap := map[string][]string{}
	pcaSets := configMap["policy-ca-sets"].(map[string]interface{})
	for pcaSetID, values := range pcaSets {
		pcaSetsMap[pcaSetID] = []string{}
		v := values.(map[string]interface{})
		for _, value := range v["pcas"].([]interface{}) {
			pcaSetsMap[pcaSetID] = append(pcaSetsMap[pcaSetID], value.(string))
		}
	}

	// parse policy CAs
	pcasPublicKeyMap := map[string]string{}
	pcas := configMap["policy-cas"].(map[string]interface{})
	for pcaID, values := range pcas {
		v := values.(map[string]interface{})
		pcasPublicKeyMap[pcaID] = v["publickey"].(string)
	}

	// get trust level map
	trustLevelMap := configMap["trust-levels"].(map[string]interface{})

	// parse policy trust preferences
	policyTrustPreferencesJSON := configMap["policy-trust-preference"].(map[string]interface{})
	for domainVar, entry := range policyTrustPreferencesJSON {
		domainTrustPreferences := []*PolicyTrustPreference{}
		objects := entry.([]interface{})
		for _, object := range objects {
			objectMap := object.(map[string]interface{})
			trustLevel := int(trustLevelMap[objectMap["level"].(string)].(float64))
			pcaSetID := objectMap["policy-ca-set"].(string)
			for _, pca := range pcaSetsMap[pcaSetID] {
				policyTrustPreference := &PolicyTrustPreference{
					PCAPublicKey: pcasPublicKeyMap[pca],
					TrustLevel:   trustLevel,
				}
				domainTrustPreferences = append(domainTrustPreferences, policyTrustPreference)
			}
		}
		policyTrustPreferences[domainVar] = domainTrustPreferences
	}
} */

/*
ghost 
decreases
requires outPerms <= inPerms
requires inPerms > 0
requires outPerms > 0
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache, inPerms)
ensures forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil
ensures forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache, outPerms)
func refoldChains(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string, inPerms perm, outPerms perm) {
	invariant 0 <= i && i <= len(chains)
	invariant outPerms <= inPerms
	invariant outPerms > 0
	invariant inPerms > 0
	invariant inPerms == old(inPerms)
	invariant outPerms == old(outPerms) 
	invariant forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil
	invariant forall k int :: {&chains[k]} 0 <= k && k < i ==> acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache, outPerms)
	invariant forall k int :: {&chains[k]} i <= k && k < len(chains) ==> acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache, inPerms)
	decreases len(chains) - i
	for i := 0; i < len(chains); i++ {
		unfold acc_inj_policyCertificateChain(chains[i], i, policyDnsNameCache, inPerms)
		refoldChain(chains[i], policyDnsNameCache, inPerms, outPerms)
		fold acc_inj_policyCertificateChain(chains[i], i, policyDnsNameCache, outPerms)
	}
}

ghost 
decreases
requires outPerms <= inPerms
requires inPerms > 0
requires outPerms > 0
requires acc_policyCertificateChain(chain, policyDnsNameCache, inPerms)
ensures acc_policyCertificateChain(chain, policyDnsNameCache, outPerms)
func refoldChain(chain *PolicyCertificateChain, policyDnsNameCache dict[string][]string, inPerms perm, outPerms perm) {
	unfold acc_policyCertificateChain(chain, policyDnsNameCache, inPerms)
	invariant acc(chain)
	invariant 0 <= i && i <= len(chain.PolicyCertificates)
	invariant outPerms <= inPerms
	invariant outPerms > 0
	invariant inPerms > 0
	invariant inPerms == old(inPerms)
	invariant outPerms == old(outPerms)
	invariant len(chain.PolicyCertificates) >= 1
	invariant forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc(&chain.PolicyCertificates[l])
	invariant forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < i ==> acc_inj_chainCertificate(chain.PolicyCertificates[l], len(chain.PolicyCertificates) - l - 1, policyDnsNameCache,outPerms, chain)
	invariant forall l int :: {&chain.PolicyCertificates[l]} i <= l && l < len(chain.PolicyCertificates) ==> acc_inj_chainCertificate(chain.PolicyCertificates[l], len(chain.PolicyCertificates) - l - 1, policyDnsNameCache,inPerms, chain)
	invariant i == 0 ==> unfolding acc_inj_chainCertificate(chain.PolicyCertificates[0], len(chain.PolicyCertificates) - 0 - 1, policyDnsNameCache,inPerms, chain) in chain.PolicyCertificates[0].Domain() in domain(policyDnsNameCache)
	invariant i > 0 ==> unfolding acc_inj_chainCertificate(chain.PolicyCertificates[0], len(chain.PolicyCertificates) - 0 - 1,policyDnsNameCache, outPerms, chain) in chain.PolicyCertificates[0].Domain() in domain(policyDnsNameCache)
	decreases len(chain.PolicyCertificates) - i
	for i := 0; i < len(chain.PolicyCertificates); i++ {
		unfold acc_inj_chainCertificate(chain.PolicyCertificates[i], len(chain.PolicyCertificates) - i - 1, policyDnsNameCache, inPerms, chain)
		unfold cache_SPCTs(chain.PolicyCertificates[i].SPCTs, inPerms)
		refoldForAllSPCTs(chain.PolicyCertificates[i].SPCTs, inPerms, outPerms)
		fold cache_SPCTs(chain.PolicyCertificates[i].SPCTs, outPerms)
		unfold policy_IssuerHash(chain.PolicyCertificates[i].IssuerHash, inPerms)
		fold policy_IssuerHash(chain.PolicyCertificates[i].IssuerHash, outPerms)
		unfold acc_strs(chain.PolicyCertificates[i].PolicyAttributes.AllowedCAs, inPerms)
		fold acc_strs(chain.PolicyCertificates[i].PolicyAttributes.AllowedCAs, outPerms)
		unfold acc_strs(chain.PolicyCertificates[i].PolicyAttributes.AllowedSubdomains, inPerms)
		fold acc_strs(chain.PolicyCertificates[i].PolicyAttributes.AllowedSubdomains, outPerms)
		unfold acc_strs(chain.PolicyCertificates[i].PolicyAttributes.DisallowedSubdomains, inPerms)
		fold acc_strs(chain.PolicyCertificates[i].PolicyAttributes.DisallowedSubdomains, outPerms)
		unfold acc_strs(chain.PolicyCertificates[i].PolicyAttributes.ExcludedSubdomains, inPerms)
		fold acc_strs(chain.PolicyCertificates[i].PolicyAttributes.ExcludedSubdomains, outPerms)
		fold acc_inj_chainCertificate(chain.PolicyCertificates[i], len(chain.PolicyCertificates) - i - 1, policyDnsNameCache, outPerms, chain)
	}
	fold acc_policyCertificateChain(chain, policyDnsNameCache, outPerms)
}

ghost
decreases
requires outPerms <= inPerms
requires outPerms > 0
requires inPerms > 0
requires forall l int :: {&spcts[l]} 0 <= l && l < len(spcts) ==> cache_SPCT(&spcts[l], l, inPerms)
ensures forall l int :: {&spcts[l]} 0 <= l && l < len(spcts) ==> cache_SPCT(&spcts[l], l, outPerms)
ensures outPerms == inPerms / 2 ==> forall l int :: {&spcts[l]} 0 <= l && l < len(spcts) ==> cache_SPCT(&spcts[l], l, outPerms) // so we can use the predicate inside of another cache_SPCTs
func refoldForAllSPCTs(spcts []common.SignedPolicyCertificateTimestamp, inPerms perm, outPerms perm) {
	invariant 0 <= i && i <= len(spcts)
	invariant outPerms <= inPerms
	invariant outPerms > 0
	invariant inPerms > 0
	invariant inPerms == old(inPerms)
	invariant outPerms == old(outPerms)
	invariant forall k int :: {&spcts[k]} 0 <= k && k < i ==> cache_SPCT(&spcts[k], k, outPerms)
	invariant forall k int :: {&spcts[k]} i <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k, inPerms)
	invariant outPerms == inPerms / 2 ==> forall k int :: {&spcts[k]} 0 <= k && k < i ==> cache_SPCT(&spcts[k], k, outPerms)
	decreases len(spcts) - i
	for i := 0; i < len(spcts); i++ {
		unfold cache_SPCT(&spcts[i], i, inPerms)
		fold cache_SPCT(&spcts[i], i, outPerms)
		if outPerms == inPerms / 2 {
			fold cache_SPCT(&spcts[i], i, outPerms)
		}
	}
}

ghost
decreases
requires outPerms / 2 == inPerms
requires outPerms > 0
requires inPerms > 0
requires forall l int :: {&spcts[l]} 0 <= l && l < len(spcts) ==> cache_SPCT(&spcts[l], l, inPerms) && cache_SPCT(&spcts[l], l, inPerms)
ensures forall l int :: {&spcts[l]} 0 <= l && l < len(spcts) ==> cache_SPCT(&spcts[l], l, outPerms)
func combineSPCTs(spcts []common.SignedPolicyCertificateTimestamp, inPerms perm, outPerms perm) {
	invariant 0 <= i && i <= len(spcts)
	invariant outPerms / 2 == inPerms
	invariant outPerms > 0
	invariant inPerms > 0
	invariant inPerms == old(inPerms)
	invariant outPerms == old(outPerms)
	invariant forall k int :: {&spcts[k]} 0 <= k && k < i ==> cache_SPCT(&spcts[k], k, outPerms)
	invariant forall k int :: {&spcts[k]} i <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k, inPerms) && cache_SPCT(&spcts[k], k, inPerms)
	decreases len(spcts) - i
	for i := 0; i < len(spcts); i++ {
		unfold cache_SPCT(&spcts[i], i, inPerms)
		unfold cache_SPCT(&spcts[i], i, inPerms)
		fold cache_SPCT(&spcts[i], i, outPerms)
	}
}

// not implemented because we cannot iterate over dictionaries in the current version of gobra
ghost decreases
requires outPerms <= inPerms
requires outPerms > 0
requires inPerms > 0
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache, inPerms)
ensures PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache, outPerms)
func refoldPolicyCache(policyCache dict[string]*PolicyCacheEntry, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyDnsNameCache dict[string][]string, inPerms perm, outPerms perm)

ghost decreases
requires outPerms <= inPerms
requires outPerms > 0
requires inPerms > 0
// acc(..., 1/2) so we know that we don't change any other invariants!
requires forall str string :: {policyCache[str]} str in domain(policyCache) && str != excl ==> acc(policyCache[str], 1/2) && cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache, inPerms)
ensures forall str string :: {policyCache[str]} str in domain(policyCache) && str != excl ==> acc(policyCache[str], 1/2) && cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache, outPerms)
func refoldPoliciesExceptFor(policyCache dict[string]*PolicyCacheEntry, excl string, policyDnsNameCache dict[string][]string, inPerms perm, outPerms perm)

ghost
requires outPerms <= inPerms
requires inPerms > 0
requires outPerms > 0
requires forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> acc(&policies[k]) && acc_inj_trustInfo_policy(policies[k], k, inPerms)
ensures forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> acc(&policies[k]) && acc_inj_trustInfo_policy(policies[k], k, outPerms)
decreases
func refoldTrustInfoPolicy(policies []*common.PolicyCertificate, inPerms perm, outPerms perm) {
	invariant 0 <= i && i <= len(policies)
	invariant outPerms <= inPerms
	invariant outPerms > 0
	invariant inPerms > 0
	invariant inPerms == old(inPerms)
	invariant outPerms == old(outPerms)
	invariant forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> acc(&policies[k])
	invariant forall k int :: {&policies[k]} 0 <= k && k < i ==> acc_inj_trustInfo_policy(policies[k], k, outPerms)
	invariant forall k int :: {&policies[k]} i <= k && k < len(policies) ==> acc_inj_trustInfo_policy(policies[k], k, inPerms)
	decreases len(policies) - i
	for i := 0; i < len(policies); i++ {
		unfold acc_inj_trustInfo_policy(policies[i], i, inPerms)
		unfold cache_SPCTs(policies[i].SPCTs, inPerms)
		refoldForAllSPCTs(policies[i].SPCTs, inPerms, outPerms)
		fold cache_SPCTs(policies[i].SPCTs, outPerms)
		unfold policy_IssuerHash(policies[i].IssuerHash, inPerms)
		fold policy_IssuerHash(policies[i].IssuerHash, outPerms)
		unfold acc_strs(policies[i].PolicyAttributes.AllowedCAs, inPerms)
		fold acc_strs(policies[i].PolicyAttributes.AllowedCAs, outPerms)
		unfold acc_strs(policies[i].PolicyAttributes.AllowedSubdomains, inPerms)
		fold acc_strs(policies[i].PolicyAttributes.AllowedSubdomains, outPerms)
		unfold acc_strs(policies[i].PolicyAttributes.DisallowedSubdomains, inPerms)
		fold acc_strs(policies[i].PolicyAttributes.DisallowedSubdomains, outPerms)
		unfold acc_strs(policies[i].PolicyAttributes.ExcludedSubdomains, inPerms)
		fold acc_strs(policies[i].PolicyAttributes.ExcludedSubdomains, outPerms)
		fold acc_inj_trustInfo_policy(policies[i], i, outPerms)
	}
}

ghost
requires outPerms <= inPerms
requires inPerms > 0
requires outPerms > 0
requires forall k int :: {&conflictingPolicyAttributes[k]} 0 <= k && k < len(conflictingPolicyAttributes) ==> acc(&conflictingPolicyAttributes[k]) && acc_inj_trustInfo_conflictingPolicyAttributes_attr(conflictingPolicyAttributes[k], k, inPerms)
ensures forall k int :: {&conflictingPolicyAttributes[k]} 0 <= k && k < len(conflictingPolicyAttributes) ==> acc(&conflictingPolicyAttributes[k]) && acc_inj_trustInfo_conflictingPolicyAttributes_attr(conflictingPolicyAttributes[k], k, outPerms)
decreases
func refoldTrustInfoConflictingPolicyAttributes(conflictingPolicyAttributes []*ConflictingPolicyAttribute, inPerms perm, outPerms perm) {
	invariant 0 <= i && i <= len(conflictingPolicyAttributes)
	invariant outPerms <= inPerms
	invariant outPerms > 0
	invariant inPerms > 0
	invariant inPerms == old(inPerms)
	invariant outPerms == old(outPerms)
	invariant forall k int :: {&conflictingPolicyAttributes[k]} 0 <= k && k < len(conflictingPolicyAttributes) ==> acc(&conflictingPolicyAttributes[k])
	invariant forall k int :: {&conflictingPolicyAttributes[k]} 0 <= k && k < i ==> acc_inj_trustInfo_conflictingPolicyAttributes_attr(conflictingPolicyAttributes[k], k, outPerms)
	invariant forall k int :: {&conflictingPolicyAttributes[k]} i <= k && k < len(conflictingPolicyAttributes) ==> acc_inj_trustInfo_conflictingPolicyAttributes_attr(conflictingPolicyAttributes[k], k, inPerms)
	decreases len(conflictingPolicyAttributes) - i
	for i := 0; i < len(conflictingPolicyAttributes); i++ {
		unfold acc_inj_trustInfo_conflictingPolicyAttributes_attr(conflictingPolicyAttributes[i], i, inPerms)
		unfold acc_policyAttributes(conflictingPolicyAttributes[i].Attribute, inPerms)
		unfold acc_strs(conflictingPolicyAttributes[i].Attribute.AllowedCAs, inPerms)
		fold acc_strs(conflictingPolicyAttributes[i].Attribute.AllowedCAs, outPerms)
		unfold acc_strs(conflictingPolicyAttributes[i].Attribute.AllowedSubdomains, inPerms)
		fold acc_strs(conflictingPolicyAttributes[i].Attribute.AllowedSubdomains, outPerms)
		unfold acc_strs(conflictingPolicyAttributes[i].Attribute.DisallowedSubdomains, inPerms)
		fold acc_strs(conflictingPolicyAttributes[i].Attribute.DisallowedSubdomains, outPerms)
		unfold acc_strs(conflictingPolicyAttributes[i].Attribute.ExcludedSubdomains, inPerms)
		fold acc_strs(conflictingPolicyAttributes[i].Attribute.ExcludedSubdomains, outPerms)
		fold acc_policyAttributes(conflictingPolicyAttributes[i].Attribute, outPerms)
		fold acc_inj_trustInfo_conflictingPolicyAttributes_attr(conflictingPolicyAttributes[i], i, outPerms)
	}
}*/

/*
ghost
requires outPerms > 0
requires acc(resChain, outPerms)
requires acc(parentChain, outPerms)
requires rootChain == parentChain ==> len(rootChain.PolicyCertificates) > 0
requires parentChain != resChain
requires len(resChain.PolicyCertificates) == len(parentChain.PolicyCertificates) + 1
requires forall k int :: {&resChain.PolicyCertificates[k]} 0 <= k && k < len(resChain.PolicyCertificates) ==> acc(&resChain.PolicyCertificates[k], outPerms)
requires forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < len(parentChain.PolicyCertificates) ==> acc(&parentChain.PolicyCertificates[k], outPerms)
requires forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < len(parentChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, policyDnsNameCache, parentChain), outPerms * 2)
requires forall k int :: {&resChain.PolicyCertificates[k]} 1 <= k && k < len(resChain.PolicyCertificates) ==> resChain.PolicyCertificates[k] == parentChain.PolicyCertificates[k-1]
requires acc(acc_inj_chainCertificate(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 0 - 1, policyDnsNameCache, resChain), outPerms)
requires unfolding acc(acc_inj_chainCertificate(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 0 - 1, policyDnsNameCache, resChain), outPerms) in resChain.PolicyCertificates[0].Domain() in domain(policyDnsNameCache)
requires rootChain != parentChain && rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), outPerms)
ensures acc(resChain, outPerms)
ensures acc(parentChain, outPerms)
ensures rootChain == parentChain ==> len(rootChain.PolicyCertificates) > 0
ensures parentChain != resChain
ensures len(resChain.PolicyCertificates) == len(parentChain.PolicyCertificates) + 1
ensures forall k int :: {&resChain.PolicyCertificates[k]} 0 <= k && k < len(resChain.PolicyCertificates) ==> acc(&resChain.PolicyCertificates[k], outPerms)
ensures forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < len(parentChain.PolicyCertificates) ==> acc(&parentChain.PolicyCertificates[k], outPerms)
ensures forall k int :: {&resChain.PolicyCertificates[k]} 1 <= k && k < len(resChain.PolicyCertificates) ==> resChain.PolicyCertificates[k] == parentChain.PolicyCertificates[k-1]
ensures forall k int :: {&resChain.PolicyCertificates[k]} 0 <= k && k < len(resChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(resChain.PolicyCertificates[k], len(resChain.PolicyCertificates) - k - 1, policyDnsNameCache, resChain), outPerms)
ensures unfolding acc(acc_inj_chainCertificate(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 0 - 1, policyDnsNameCache, resChain), outPerms) in resChain.PolicyCertificates[0].Domain() in domain(policyDnsNameCache)
ensures rootChain == parentChain ==> forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < len(parentChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, policyDnsNameCache, parentChain), outPerms)
ensures rootChain != parentChain && rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), outPerms)
decreases
func refoldFromParentToResChain(resChain *PolicyCertificateChain, parentChain *PolicyCertificateChain, rootChain *PolicyCertificateChain, outPerms perm, policyDnsNameCache dict[string][]string) {
	invariant policyDnsNameCache == old(policyDnsNameCache)
	invariant acc(resChain, outPerms)
	invariant acc(parentChain, outPerms)
	invariant rootChain == parentChain ==> len(rootChain.PolicyCertificates) > 0
	invariant parentChain != resChain
	invariant 1 <= i && i <= len(resChain.PolicyCertificates)
	invariant len(resChain.PolicyCertificates) == len(parentChain.PolicyCertificates) + 1
	invariant forall k int :: {&resChain.PolicyCertificates[k]} 0 <= k && k < len(resChain.PolicyCertificates) ==> acc(&resChain.PolicyCertificates[k])
	invariant forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < len(parentChain.PolicyCertificates) ==> acc(&parentChain.PolicyCertificates[k])
	invariant forall k int :: {&resChain.PolicyCertificates[k]} 1 <= k && k < len(resChain.PolicyCertificates) ==> resChain.PolicyCertificates[k] == parentChain.PolicyCertificates[k-1]
	invariant forall k int :: {&resChain.PolicyCertificates[k]} 0 <= k && k < i ==> acc(acc_inj_chainCertificate(resChain.PolicyCertificates[k], len(resChain.PolicyCertificates) - k - 1, policyDnsNameCache, resChain), outPerms)
	invariant forall k int :: {&parentChain.PolicyCertificates[k]} i - 1 <= k && k < len(parentChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, policyDnsNameCache, parentChain), outPerms * 2)
	invariant rootChain == parentChain ==> forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < i - 1 ==> acc(acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, policyDnsNameCache, parentChain), outPerms)
	invariant rootChain != parentChain && rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), outPerms)
	invariant outPerms == old(outPerms)
	decreases len(resChain.PolicyCertificates) - i
	for i := 1; i < len(resChain.PolicyCertificates); i++ {
		k := i - 1
		/// fold back parentChain independently of whether rootChain==parentChain (i.e. independently of whether we actually need parentChain back folded)
		unfold acc(acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, policyDnsNameCache, parentChain), outPerms * 2)
		unfold acc(cache_SPCTs(parentChain.PolicyCertificates[k].SPCTs), outPerms * 2)
		//refoldForAllSPCTs(parentChain.PolicyCertificates[k].SPCTs, outPerms, outPerms / 2)
		fold cache_SPCTs(resChain.PolicyCertificates[i].SPCTs, outPerms / 2)
		fold cache_SPCTs(parentChain.PolicyCertificates[k].SPCTs, outPerms / 2)
		unfold policy_IssuerHash(parentChain.PolicyCertificates[k].IssuerHash, outPerms)
		fold policy_IssuerHash(resChain.PolicyCertificates[i].IssuerHash, outPerms / 2)
		fold policy_IssuerHash(parentChain.PolicyCertificates[k].IssuerHash, outPerms / 2)
		unfold acc_strs(parentChain.PolicyCertificates[k].PolicyAttributes.AllowedCAs, outPerms)
		fold acc_strs(resChain.PolicyCertificates[i].PolicyAttributes.AllowedCAs, outPerms / 2)
		fold acc_strs(parentChain.PolicyCertificates[k].PolicyAttributes.AllowedCAs, outPerms / 2)
		unfold acc_strs(parentChain.PolicyCertificates[k].PolicyAttributes.AllowedSubdomains, outPerms)
		fold acc_strs(resChain.PolicyCertificates[i].PolicyAttributes.AllowedSubdomains, outPerms / 2)
		fold acc_strs(parentChain.PolicyCertificates[k].PolicyAttributes.AllowedSubdomains, outPerms / 2)
		unfold acc_strs(parentChain.PolicyCertificates[k].PolicyAttributes.DisallowedSubdomains, outPerms)
		fold acc_strs(resChain.PolicyCertificates[i].PolicyAttributes.DisallowedSubdomains, outPerms / 2)
		fold acc_strs(parentChain.PolicyCertificates[k].PolicyAttributes.DisallowedSubdomains, outPerms / 2)
		unfold acc_strs(parentChain.PolicyCertificates[k].PolicyAttributes.ExcludedSubdomains, outPerms)
		fold acc_strs(resChain.PolicyCertificates[i].PolicyAttributes.ExcludedSubdomains, outPerms / 2)
		fold acc_strs(parentChain.PolicyCertificates[k].PolicyAttributes.ExcludedSubdomains, outPerms / 2)
		fold acc_inj_chainCertificate(resChain.PolicyCertificates[i], len(resChain.PolicyCertificates) - i - 1, policyDnsNameCache, outPerms / 2, resChain)
		fold acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, policyDnsNameCache, outPerms / 2, parentChain)
	}
}
*/
// find the policy certificate chain which has the latest max timestamp in the set [issuance, SPCT time 1, SPCT time 2, ...].
// The second parameter is an optional root chain (e.g., domain root cert to root cert) that must be used. If nil is passed as an argument, any chain is accepted. If no acceptable chain can be generated, nil is returned.
requires cachePerms > 0
requires acc(&policyCache, cachePerms)
requires acc(&immutablePolicyCache, cachePerms)
requires acc(&policyDnsNameCache, cachePerms)
requires acc(immutablePolicyCache, cachePerms)
requires acc(policyCache, cachePerms)
requires acc(policyDnsNameCache, cachePerms)
requires inPerms > 0
requires rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), inPerms)
//requires rootChain != nil ==> immutableHash != base64.StdEncoding.EncodeToString(nil) // We cannot really do this.. And because of this it could also be that err != nil
requires immutableHash != base64.StdEncoding.EncodeToString(nil) ==> immutableHash in domain(immutablePolicyCache)
requires (forall str string :: {&dict(immutablePolicyCache)[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes, cachePerms) && acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, dict(policyCache)), cachePerms)) &&  // dict needed in trigger to make sure that gobra generates a valid trigger!
    (forall str string :: {&dict(immutablePolicyCache)[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth, cachePerms) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash, cachePerms) && ((immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) && immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache)) ==> immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains, cachePerms))
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
ensures acc(&policyCache, cachePerms)
ensures acc(&immutablePolicyCache, cachePerms)
ensures acc(&policyDnsNameCache, cachePerms)
ensures acc(immutablePolicyCache, cachePerms)
ensures acc(policyCache, cachePerms)
ensures acc(policyDnsNameCache, cachePerms)
ensures outPerms > 0
ensures outPerms <= inPerms
ensures rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms)
ensures immutableHash != base64.StdEncoding.EncodeToString(nil) ==> immutableHash in domain(immutablePolicyCache)
ensures (forall str string :: {&dict(immutablePolicyCache)[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes, cachePerms) && acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, dict(policyCache)), cachePerms)) &&  // dict needed in trigger to make sure that gobra generates a valid trigger!
    (forall str string :: {&dict(immutablePolicyCache)[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth, cachePerms) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash, cachePerms) && ((immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) && immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache)) ==> immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains, cachePerms))
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures err == nil ==> res != nil
ensures (rootChain != nil || immutableHash != base64.StdEncoding.EncodeToString(nil)) && res != rootChain && err == nil ==> acc(acc_policyCertificateChain(res, dict(policyDnsNameCache)), outPerms)
ensures rootChain == nil && err == nil && immutableHash == base64.StdEncoding.EncodeToString(nil) ==> acc(res) && len(res.PolicyCertificates) == 0
ensures err == nil ==> (rootChain == nil && immutableHash == base64.StdEncoding.EncodeToString(nil) ==> toAbstractChainFromChain(res.PolicyCertificates, dict(policyDnsNameCache), res) == old(abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))))
ensures err == nil ==> ((rootChain != nil || immutableHash != base64.StdEncoding.EncodeToString(nil)) ==> (unfolding acc(acc_policyCertificateChain(res, dict(policyDnsNameCache)), outPerms) in toAbstractChainFromChain(res.PolicyCertificates, dict(policyDnsNameCache), res)) == old(abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))))
func getPolicyCertificateChainWithLatestTimestamp(immutableHash string, rootChain *PolicyCertificateChain, ghost inPerms perm, ghost cachePerms perm) (res *PolicyCertificateChain, err error, ghost outPerms perm) /*{ // added names to reference return variables in postcondition 
	ghost outPerms = inPerms
	if rootChain != nil {
		unfold acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms)
		unfold acc(acc_inj_chainCertificate(rootChain.PolicyCertificates[0], len(rootChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache), rootChain), outPerms)
		if immutableHash == getImmutablePolicyHash(rootChain.PolicyCertificates[0], outPerms / 2) {
			fold acc(acc_inj_chainCertificate(rootChain.PolicyCertificates[0], len(rootChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache), rootChain), outPerms)
			fold acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms)
			reveal abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
			reveal getImmutableHashOfFirstCert(rootChain, dict(policyDnsNameCache))
			reveal getAbstractChainFromChain(rootChain, dict(policyDnsNameCache))
			// TODO CHANGE - JUST TO SEE WHERE THE POSTCONDITION CANNOT BE PROVEN
			assume false
			return rootChain, nil, outPerms
		}
		fold acc(acc_inj_chainCertificate(rootChain.PolicyCertificates[0], len(rootChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache), rootChain), outPerms)
		fold acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms)
	} else {
		if immutableHash == base64.StdEncoding.EncodeToString(nil) {
			reveal abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
			// TODO CHANGE - JUST TO SEE WHERE THE POSTCONDITION CANNOT BE PROVEN
			assume false
			return NewPolicyCertificateChain(), nil, outPerms
		}
	}
	issuerEntry, ok := immutablePolicyCache[immutableHash]
	
	if !ok {
		return nil, fmt.Errorf("Inconsistent caches: policy with immutable hash %s does not exist", immutableHash), outPerms
	}
	parentChain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(issuerEntry.immutableIssuerHash, rootChain, inPerms, cachePerms / 2)
	ghost outPerms = tmp

	if err != nil {
		return nil, err, outPerms
	}
	if parentChain == nil {
		assert false // Cannot get here since err == nil ==> res != nil in recursive postcondoition 
		return nil, nil, outPerms
	}
	unfold acc(ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache)), cachePerms)

	if len(issuerEntry.policyHashes) == 0 {
		assert false // Cannot get here since issuerEntry.policyHashes > 0 according to invariant
		return nil, fmt.Errorf("Inconsistent caches: no policy certificate corresponding to immutable hash %s exists", immutableHash), outPerms
	}
	var minMaxTimestampPcEntry *common.PolicyCertificate
	var minMaxTimestamp time.Time

	ghost oldImmutablePolicyCache := dict(immutablePolicyCache)
	ghost oldPolicyCache := dict(policyCache)
	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)

	invariant cachePerms > 0
	invariant cachePerms == old(cachePerms)
	invariant acc(&policyCache, cachePerms)
	invariant acc(&policyDnsNameCache, cachePerms)
	invariant acc(&immutablePolicyCache, cachePerms)
	invariant outPerms > 0
	invariant outPerms <= old(outPerms)
	invariant old(outPerms) <= inPerms
	invariant acc(policyDnsNameCache, cachePerms)
	invariant acc(immutablePolicyCache, cachePerms)
	invariant acc(policyCache, cachePerms)
	invariant dict(policyCache) == oldPolicyCache
	invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
	invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
	invariant i > 0 ==> acc(minMaxTimestampPcEntry, outPerms)
	invariant i > 0 ==> minMaxTimestampPcEntry.Domain() in policyDnsNameCache
	invariant i > 0 ==> acc(cache_SPCTs(minMaxTimestampPcEntry.SPCTs), outPerms)
	invariant i > 0 ==> acc(policy_IssuerHash(minMaxTimestampPcEntry.IssuerHash), outPerms)
	invariant i > 0 ==> acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.AllowedCAs), outPerms) 
	invariant i > 0 ==> acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.AllowedSubdomains), outPerms) 
	invariant i > 0 ==> acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.DisallowedSubdomains), outPerms)
	invariant i > 0 ==> acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.ExcludedSubdomains), outPerms)
	invariant immutableHash in domain(dict(immutablePolicyCache))
	invariant issuerEntry == dict(immutablePolicyCache)[immutableHash]
    invariant (forall str string :: {&dict(immutablePolicyCache)[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes, cachePerms)) &&  // dict needed in trigger to make sure that gobra generates a valid trigger!
    (forall str string :: {&dict(immutablePolicyCache)[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth, cachePerms) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash, cachePerms) && ((immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) && immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache)) ==> immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains, cachePerms))
	invariant forall str string :: {&dict(immutablePolicyCache)[str].policyHashes} str in domain(immutablePolicyCache) && str != immutableHash ==> acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, dict(policyCache)), cachePerms)
	invariant let hashes := issuerEntry.policyHashes in (len(hashes) > 0 && forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k], cachePerms) && hashes[k] in domain(policyCache))
	invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
	invariant parentChain != nil
	invariant (rootChain != nil || issuerEntry.immutableIssuerHash != base64.StdEncoding.EncodeToString(nil)) && rootChain != parentChain ==> acc(acc_policyCertificateChain(parentChain, dict(policyDnsNameCache)), outPerms)
	invariant rootChain == nil && issuerEntry.immutableIssuerHash == base64.StdEncoding.EncodeToString(nil) ==> acc(parentChain) && len(parentChain.PolicyCertificates) == 0
	invariant rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms)
	invariant 0 <= i && i <= len(issuerEntry.policyHashes)
	invariant i > 0 ==> toAbstractPolicyFromBlank(minMaxTimestampPcEntry) == getMinMaxPolicyInner(toSeq(issuerEntry.policyHashes[:i]), true, time.Time{}, AbstractPolicy{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
	for i := 0; i < len(issuerEntry.policyHashes); i += 1 {
		unfold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)

		hash := issuerEntry.policyHashes[i]
	//for i, hash := range issuerEntry.policyHashes {

		pcEntry, ok := policyCache[hash]
		if !ok {
			fold acc(ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache)), cachePerms)
			fold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
			assert false // cannot get here invariant says it must be present in policyCache
			return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", hash), outPerms
		}
		
		unfold acc(cache_policyHashes_policy(pcEntry.policy, hash, dict(policyDnsNameCache)), outPerms)

		tLatest := pcEntry.policy.TimeStamp
		unfold acc(cache_SPCTs(pcEntry.policy.SPCTs), outPerms)
		invariant cachePerms == old(cachePerms)
		invariant acc(&policyCache, cachePerms)
		invariant acc(&policyDnsNameCache, cachePerms)
		invariant acc(&immutablePolicyCache, cachePerms)
		invariant outPerms > 0
		invariant outPerms == old(outPerms)
		invariant acc(policyDnsNameCache, cachePerms)
		invariant acc(immutablePolicyCache, cachePerms)
		invariant acc(policyCache, cachePerms)
		invariant dict(policyCache) == oldPolicyCache
		invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
		invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
		invariant pcEntry == policyCache[hash]
		invariant pcEntry == old(pcEntry)
		invariant forall str string :: {dict(policyCache)[str]} str in domain(dict(policyCache)) ==> 
			acc(dict(policyCache)[str], outPerms) && 
			acc(PolicyCachePermissions_ImmutableHash(dict(policyCache)[str].immutableHash, str, dict(immutablePolicyCache)), outPerms)
		invariant forall str string :: {dict(policyCache)[str]} str in domain(dict(policyCache)) && str != hash ==> acc(cache_policyHashes_policy(dict(policyCache)[str].policy, str, dict(policyDnsNameCache)), outPerms)
		invariant acc(pcEntry.policy, outPerms)
		invariant acc(policy_IssuerHash(pcEntry.policy.IssuerHash), outPerms)
		invariant acc(acc_strs(pcEntry.policy.PolicyAttributes.AllowedCAs), outPerms)
		invariant acc(acc_strs(pcEntry.policy.PolicyAttributes.AllowedSubdomains), outPerms)
		invariant acc(acc_strs(pcEntry.policy.PolicyAttributes.DisallowedSubdomains), outPerms)
		invariant acc(acc_strs(pcEntry.policy.PolicyAttributes.ExcludedSubdomains), outPerms)
		invariant pcEntry.policy.Domain() in policyDnsNameCache
		invariant forall l int :: {&pcEntry.policy.SPCTs[l]} 0 <= l && l < len(pcEntry.policy.SPCTs) ==> acc(cache_SPCT(&pcEntry.policy.SPCTs[l], l), outPerms)
		invariant 0 <= j && j <= len(pcEntry.policy.SPCTs)
		invariant j > 0 ==> tLatest == findMaxSPCT(pcEntry.policy.SPCTs[:j], 0, time.Time{})
		//for _, spct := range pcEntry.policy.SPCTs {
		for j := 0; j < len(pcEntry.policy.SPCTs); j++ {
			unfold acc(cache_SPCT(&pcEntry.policy.SPCTs[j], j), outPerms)
			spct := pcEntry.policy.SPCTs[j]
			ghost oldTLatest := tLatest
			tLatest = maxTime(tLatest, spct.AddedTS)
			fold acc(cache_SPCT(&pcEntry.policy.SPCTs[j], j), outPerms)
			reveal findMaxSPCT(pcEntry.policy.SPCTs[:j], 0, time.Time{})
			reveal findMaxSPCT(pcEntry.policy.SPCTs[:j+1], 0, time.Time{})
		}
		if i == 0 || tLatest.Before(minMaxTimestamp) {
			minMaxTimestamp = tLatest
			//unfold acc(policy_IssuerHash(pcEntry.policy.IssuerHash), outPerms)
			ghost outPerms = outPerms / 2
			minMaxTimestampPcEntry = pcEntry.policy

/*
			ghost if (rootChain != nil) {
				refoldChain(rootChain, dict(policyDnsNameCache),origOutPerms, outPerms)
			}
			ghost if ((rootChain != nil || issuerEntry.immutableIssuerHash != base64.StdEncoding.EncodeToString(nil)) && rootChain != parentChain) {
				refoldChain(parentChain, dict(policyDnsNameCache),origOutPerms, outPerms)
			}
			ghost refoldForAllSPCTs(minMaxTimestampPcEntry.SPCTs, origOutPerms, outPerms)*/
			/*fold acc(cache_SPCTs(minMaxTimestampPcEntry.SPCTs), outPerms)
			fold acc(policy_IssuerHash(pcEntry.policy.IssuerHash), outPerms)
			fold acc(policy_IssuerHash(minMaxTimestampPcEntry.IssuerHash), outPerms)
			unfold acc(acc_strs(pcEntry.policy.PolicyAttributes.AllowedCAs), outPerms * 2)
			fold acc(acc_strs(pcEntry.policy.PolicyAttributes.AllowedCAs), outPerms)
			fold acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.AllowedCAs), outPerms)
			unfold acc(acc_strs(pcEntry.policy.PolicyAttributes.AllowedSubdomains), outPerms * 2)
			fold acc(acc_strs(pcEntry.policy.PolicyAttributes.AllowedSubdomains), outPerms)
			fold acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.AllowedSubdomains), outPerms)
			unfold acc(acc_strs(pcEntry.policy.PolicyAttributes.DisallowedSubdomains), outPerms * 2)
			fold acc(acc_strs(pcEntry.policy.PolicyAttributes.DisallowedSubdomains), outPerms)
			fold acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.DisallowedSubdomains), outPerms)
			unfold acc(acc_strs(pcEntry.policy.PolicyAttributes.ExcludedSubdomains), outPerms * 2)
			fold acc(acc_strs(pcEntry.policy.PolicyAttributes.ExcludedSubdomains), outPerms)
			fold acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.ExcludedSubdomains), outPerms)
			//ghost refoldPoliciesExceptFor(dict(policyCache), hash, dict(policyDnsNameCache), origOutPerms, outPerms)*//*
		} 
		fold acc(cache_SPCTs(pcEntry.policy.SPCTs), outPerms)
		fold acc(cache_policyHashes_policy(pcEntry.policy, hash, dict(policyDnsNameCache)), outPerms)
		fold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
		reveal getMinMaxPolicyInner(toSeq(issuerEntry.policyHashes[:i]), true, time.Time{}, AbstractPolicy{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
		reveal getMinMaxPolicyInner(toSeq(issuerEntry.policyHashes[:i+1]), true, time.Time{}, AbstractPolicy{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
	}
	fold acc(ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache)), cachePerms)
	ghost if (rootChain != nil || issuerEntry.immutableIssuerHash != base64.StdEncoding.EncodeToString(nil)) {
		unfold acc(acc_policyCertificateChain(parentChain, dict(policyDnsNameCache)), outPerms)
	}
	isDomainRootCertificate := minMaxTimestampPcEntry.Domain() != "" && (len(parentChain.PolicyCertificates) == 0 || (unfolding acc(acc_inj_chainCertificate(parentChain.PolicyCertificates[0], len(parentChain.PolicyCertificates) - 1, dict(policyDnsNameCache), parentChain), outPerms) in parentChain.PolicyCertificates[0].Domain()) == "")
	isDomainRootCertificateParent := minMaxTimestampPcEntry.Domain() == ""
	domainRootIssuanceTimestamp := parentChain.DomainRootIssuanceTimestamp
	if isDomainRootCertificate {
		domainRootIssuanceTimestamp = minMaxTimestampPcEntry.TimeStamp
	}
	domainRootMinMaxTimestamp := parentChain.DomainRootMinMaxTimestamp
	if isDomainRootCertificate {
		domainRootMinMaxTimestamp = minMaxTimestamp
	}

	rootAndIntermediateLatestMinMaxTimestamp := parentChain.RootAndIntermediateLatestMinMaxTimestamp
	if isDomainRootCertificateParent {
		rootAndIntermediateLatestMinMaxTimestamp = maxTime(rootAndIntermediateLatestMinMaxTimestamp, minMaxTimestamp)
	}
	domainLatestMinMaxTimestamp := parentChain.DomainLatestMinMaxTimestamp
	if !isDomainRootCertificate && !isDomainRootCertificateParent {
		domainLatestMinMaxTimestamp = maxTime(domainLatestMinMaxTimestamp, minMaxTimestamp)
	}

	resChain := &PolicyCertificateChain{
		PolicyCertificates:                       append(perm(1/2), []*common.PolicyCertificate{minMaxTimestampPcEntry}, parentChain.PolicyCertificates...),
		DomainRootIssuanceTimestamp:              domainRootIssuanceTimestamp,
		DomainRootMinMaxTimestamp:                domainRootMinMaxTimestamp,
		RootAndIntermediateLatestMinMaxTimestamp: rootAndIntermediateLatestMinMaxTimestamp,
		DomainLatestMinMaxTimestamp:              domainLatestMinMaxTimestamp,
		// todo: find trust level
		TrustLevel: max(parentChain.TrustLevel, 0),
	}
	/*unfold cache_SPCTs(resChain.PolicyCertificates[0].SPCTs, outPerms)
	refoldForAllSPCTs(resChain.PolicyCertificates[0].SPCTs, outPerms, outPerms / 2)
	fold cache_SPCTs(resChain.PolicyCertificates[0].SPCTs, outPerms / 2)
	unfold policy_IssuerHash(resChain.PolicyCertificates[0].IssuerHash, outPerms)
	fold policy_IssuerHash(resChain.PolicyCertificates[0].IssuerHash, outPerms / 2)
	unfold acc_strs(resChain.PolicyCertificates[0].PolicyAttributes.AllowedCAs, outPerms)
	fold acc_strs(resChain.PolicyCertificates[0].PolicyAttributes.AllowedCAs, outPerms / 2)
	unfold acc_strs(resChain.PolicyCertificates[0].PolicyAttributes.AllowedSubdomains, outPerms)
	fold acc_strs(resChain.PolicyCertificates[0].PolicyAttributes.AllowedSubdomains, outPerms / 2)
	unfold acc_strs(resChain.PolicyCertificates[0].PolicyAttributes.DisallowedSubdomains, outPerms)
	fold acc_strs(resChain.PolicyCertificates[0].PolicyAttributes.DisallowedSubdomains, outPerms / 2)
	unfold acc_strs(resChain.PolicyCertificates[0].PolicyAttributes.ExcludedSubdomains, outPerms)
	fold acc_strs(resChain.PolicyCertificates[0].PolicyAttributes.ExcludedSubdomains, outPerms / 2)// / 2 because in the next loop (in function call) we might fold certificateChain for two chains (if rootChain == parentChain) -> improves simplicity if we just / 2 in any case.*//*
	fold acc(acc_inj_chainCertificate(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 1, dict(policyDnsNameCache), resChain), outPerms / 2)

	//ghost refoldFromParentToResChain(resChain, parentChain, rootChain, outPerms / 2, dict(policyDnsNameCache)) //outPerms / 2 used to be outPerms
	ghost if rootChain == parentChain { 
		fold acc(acc_policyCertificateChain(parentChain, dict(policyDnsNameCache)), outPerms / 2)
	}/* else if rootChain != nil {
		refoldChain(rootChain, dict(policyDnsNameCache), outPerms, outPerms / 2)
	}*//*
	fold acc(acc_policyCertificateChain(resChain, dict(policyDnsNameCache)), outPerms / 2)
	//ghost refoldPolicyCache(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms, outPerms / 2)
	reveal getImmutableHashOfFirstCert(rootChain, dict(policyDnsNameCache))
	reveal abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
	return resChain, nil, outPerms / 2
}*/

// TODO Go's builtin max is not available, so here is a declaration just for this use case
ensures x < y ==> res == y && x >= y ==> res == x
func max(x, y int) (res int)


requires acc(&policyCache, 1/4)
requires acc(&immutablePolicyCache, 1/4)
requires acc(&policyDnsNameCache, 1/4)
requires inPerms > 0
requires acc(policyCache, 1/4)
requires acc(policyDnsNameCache, 1/4)
requires acc(immutablePolicyCache, 1/4)
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
requires acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
requires PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
requires domainVar in domain(policyDnsNameCache)
ensures acc(&policyCache, 1/4)
ensures acc(&immutablePolicyCache, 1/4)
ensures acc(&policyDnsNameCache, 1/4)
ensures outPerms > 0
ensures outPerms <= 1
ensures outPerms <= inPerms
ensures acc(policyCache, 1/4)
ensures acc(policyDnsNameCache, 1/4)
ensures acc(immutablePolicyCache, 1/4)
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
ensures PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
ensures domainVar in domain(policyDnsNameCache) ==> !(res == nil && err == nil)
ensures err == nil ==> res != nil
ensures err == nil ==> (forall k int :: {&res[k]} 0 <= k && k < len(res) ==> (acc(&res[k]) && res[k] != nil && acc(acc_inj_policyCertificateChain(res[k], k, dict(policyDnsNameCache)), outPerms)))
ensures err == nil ==> toAbstractChains(res, dict(policyDnsNameCache)) == old(abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache)))
func findPolicyCertificateChainsForE2LD(domainVar string, ghost inPerms perm) (res []*PolicyCertificateChain, err error, ghost outPerms perm) /*{
	leafHashes, ok := policyDnsNameCache[domainVar]
	ghost outPerms = inPerms
	if !ok {
		return nil, nil, outPerms
	}
	//unfold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
	//unfold acc_leafHashes(leafHashes, domainVar, dict(policyCache))
	chains := []*PolicyCertificateChain{}

	ghost oldPolicyCache := dict(policyCache)
	ghost oldImmutablePolicyCache := dict(immutablePolicyCache)
	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)

	invariant acc(&policyCache, 1/4)
	invariant acc(&policyDnsNameCache, 1/4)
	invariant acc(&immutablePolicyCache, 1/4)
	invariant acc(policyCache, 1/4)
	invariant acc(policyDnsNameCache, 1/4)
	invariant acc(immutablePolicyCache, 1/4)
	invariant dict(policyCache) == oldPolicyCache
	invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
	invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
	invariant chains != nil
	invariant outPerms <= old(outPerms)
	invariant outPerms > 0
	invariant outPerms <= inPerms
	//invariant forall k int :: 0 <= k && k < len(leafHashes) ==> acc(&leafHashes[k]) && leafHashes[k] in domain(policyCache)
	//invariant forall str string :: {dict(policyDnsNameCache)[str]} str in domain(dict(policyDnsNameCache)) && str != domainVar ==> acc_leafHashes(dict(policyDnsNameCache)[str], str, dict(policyCache))
	invariant acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
	invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
	invariant PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
	invariant forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> (acc(&chains[k]) && chains[k] != nil && acc(acc_inj_policyCertificateChain(chains[k], k, dict(policyDnsNameCache)), outPerms))
	invariant 0 <= i && i <= len(leafHashes)
    invariant toAbstractChains(chains, dict(policyDnsNameCache)) == abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))[:i]
	for i := 0; i < len(leafHashes); i++ {
		//ghost oldOutPerms := outPerms
		unfold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
		unfold acc_leafHashes(leafHashes, domainVar, dict(policyCache))
		leafHash := leafHashes[i]
	//for _, leafHash := range leafHashes {
		leafCacheEntry, ok := policyCache[leafHash]
		if !ok {
			assert false
			fold acc_leafHashes(leafHashes, domainVar, dict(policyCache))
			fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
			return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", leafHash), outPerms
		}

		/*
		fold acc_leafHashes(leafHashes, domainVar, dict(policyCache))
		fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
		assert toAbstractChains(chains, dict(policyDnsNameCache)) == abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))[:i]
		ghost gtmp := abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))[:i]
		unfold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
		unfold acc_leafHashes(leafHashes, domainVar, dict(policyCache))*//*

		unfold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 2) // needs to be / 2 otherwise we cannot prove that abstractFindChains is still the same 
		unfold acc(PolicyCachePermissions_ImmutableHash(leafCacheEntry.immutableHash, leafHash, dict(immutablePolicyCache)), outPerms / 2)
		fold acc(PolicyCachePermissions_ImmutableHash(leafCacheEntry.immutableHash, leafHash, dict(immutablePolicyCache)), outPerms / 2) // invariant that leafCacheEntry.immutableHash is not nil lies in here -> needed so we get back chain predicate
		fold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 2)

		unfold acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
		chain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms) in unfolding acc(PolicyCachePermissions_ImmutableHash(leafCacheEntry.immutableHash, leafHash, dict(immutablePolicyCache)), outPerms) in leafCacheEntry.immutableHash, nil, outPerms / 2, 1/8) // outPerms / 2 so we know that the policies haven't changed and findAbstractChains is still true. this will lower the permissions for all policies though.
		fold acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)



		/*fold acc_leafHashes(leafHashes, domainVar, dict(policyCache))
		fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
		assert oldPolicyCache == dict(policyCache)
		assert oldImmutablePolicyCache == dict(immutablePolicyCache)
		assert oldPolicyDnsNameCache == dict(policyDnsNameCache)
		assert gtmp == abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))[:i]
		assert toAbstractChains(chains, dict(policyDnsNameCache)) == abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))[:i]
		unfold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
		unfold acc_leafHashes(leafHashes, domainVar, dict(policyCache))*//*



		//ghost refoldChains(chains, dict(policyDnsNameCache), outPerms, tmp)
		ghost outPerms = tmp
		if err != nil {
			fold acc_leafHashes(leafHashes, domainVar, dict(policyCache))
			fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
			return chains, fmt.Errorf("Failed to get policy cert chain with latest timestamp: %s", err), outPerms
		}

		/*fold acc_leafHashes(leafHashes, domainVar, dict(policyCache))
		fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
		assert gtmp == abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))[:i]
		assert toAbstractChains(chains, dict(policyDnsNameCache)) == abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))[:i]
		unfold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
		unfold acc_leafHashes(leafHashes, domainVar, dict(policyCache))*//*
		

			chains = append(perm(1/2), chains, chain)
/*	fold acc_leafHashes(leafHashes, domainVar, dict(policyCache))
		fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
assert toAbstractChains(chains, dict(policyDnsNameCache)) == abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))[:i]
unfold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
		unfold acc_leafHashes(leafHashes, domainVar, dict(policyCache))*//*
		
		fold acc(acc_inj_policyCertificateChain(chain, len(chains) - 1, dict(policyDnsNameCache)), outPerms)
		fold acc_leafHashes(leafHashes, domainVar, dict(policyCache))
		fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
/*
		assert gtmp == abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))[:i]
		assert toAbstractChains(chains[:len(chains)-1], dict(policyDnsNameCache)) == abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))[:i]
		assert toAbstractChains(chains, dict(policyDnsNameCache)) == abstractFindChain(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))[:i+1]
*/		/*
	}
	//assume false
	//fold acc_leafHashes(leafHashes, domainVar, dict(policyCache))
	//fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
	return chains, nil, outPerms
}*/

requires acc(&policyCache, 1/4)
requires acc(&immutablePolicyCache, 1/4)
requires acc(&policyDnsNameCache, 1/4)
requires inPerms > 0
requires domainRootPolicyCertificateChain != nil
requires acc(immutablePolicyCache, 1/4)
requires acc(policyCache, 1/4)
requires acc(policyDnsNameCache, 1/4)
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
requires acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
requires PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
requires acc(acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), inPerms)
ensures acc(&policyCache, 1/4)
ensures acc(&immutablePolicyCache, 1/4)
ensures acc(&policyDnsNameCache, 1/4)
ensures outPerms > 0
ensures outPerms <= inPerms
ensures acc(immutablePolicyCache, 1/4)
ensures acc(policyCache, 1/4)
ensures acc(policyDnsNameCache, 1/4)
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
ensures PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
ensures err == nil ==> acc(acc_policyCertificateChain(res, dict(policyDnsNameCache)), outPerms)
func findPolicyCertificateChainForDomain(domainVar string, domainRootPolicyCertificateChain *PolicyCertificateChain, ghost inPerms perm) (res *PolicyCertificateChain, err error, ghost outPerms perm) {
	ghost outPerms = inPerms
	unfold acc(acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), outPerms)
	e2ld := unfolding acc(acc_inj_chainCertificate(domainRootPolicyCertificateChain.PolicyCertificates[0], len(domainRootPolicyCertificateChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache), domainRootPolicyCertificateChain), outPerms) in domainRootPolicyCertificateChain.PolicyCertificates[0].Domain()
	fold acc(acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), outPerms)
	subdomainsString, found := strings.CutSuffix(domainVar, e2ld)
	if !found {
		return nil, fmt.Errorf("Domain is not a subdomain of e2ld"), outPerms
	}
	subdomains := strings.Split(subdomainsString, ".")
	currentDomain := e2ld

	ghost oldPolicyCache := dict(policyCache)
	ghost oldImmutablePolicyCache := dict(immutablePolicyCache)
	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)

	var finalChain *PolicyCertificateChain
	invariant outPerms > 0
	invariant acc(&policyCache, 1/4)
	invariant acc(&policyDnsNameCache, 1/4)
	invariant acc(&immutablePolicyCache, 1/4)
	invariant acc(policyCache, 1/4)
	invariant acc(policyDnsNameCache, 1/4)
	invariant acc(immutablePolicyCache, 1/4)
	invariant dict(policyCache) == oldPolicyCache
	invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
	invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
	invariant acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
	invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
	invariant PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
	invariant outPerms == old(outPerms)
	invariant outPerms <= inPerms
	invariant domainRootPolicyCertificateChain != nil
	invariant acc(acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), outPerms)
	invariant acc(subdomains)
	invariant i == 0 ==> currentDomain == e2ld
	invariant i == 0 ==> currentDomain in policyDnsNameCache
	invariant i > 0 ==> finalChain != nil
	invariant finalChain != nil && finalChain != domainRootPolicyCertificateChain ==> acc(acc_policyCertificateChain(finalChain, dict(policyDnsNameCache)), outPerms)
	invariant 0 <= i && i <= len(subdomains)
	for i := 0; i < len(subdomains); i++ {
		// skip last item since it is an empty string
		if i > 0 {
			currentDomain = subdomains[len(subdomains)-1-i] + "." + currentDomain
		}
		leafHashes, ok := policyDnsNameCache[currentDomain]
		assert i == 0 ==> ok
		if ok {
			unfold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
			invariant outPerms == old(outPerms)
			invariant outPerms > 0
			invariant outPerms <= inPerms
			invariant acc(&policyCache, 1/4)
			invariant acc(&policyDnsNameCache, 1/4)
			invariant acc(&immutablePolicyCache, 1/4)
			invariant acc(policyCache, 1/4)
			invariant acc(policyDnsNameCache, 1/4)
			invariant acc(immutablePolicyCache, 1/4)
			invariant dict(policyCache) == oldPolicyCache
			invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
			invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
			invariant acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
			invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
			invariant forall str string :: {policyDnsNameCache[str]} str in domain(policyDnsNameCache) ==> let leafHashes, ok := policyDnsNameCache[str] in len(leafHashes) > 0 && acc_leafHashes(leafHashes, str, dict(policyCache)) && len(leafHashes) > 0
			invariant domainRootPolicyCertificateChain != nil
			invariant acc(acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), outPerms)
			invariant acc(subdomains)
			invariant currentDomain in policyDnsNameCache
			invariant let lH, ok := policyDnsNameCache[currentDomain] in lH === leafHashes
			invariant j > 0 ==> finalChain != nil
			invariant finalChain != nil && finalChain != domainRootPolicyCertificateChain ==> acc(acc_policyCertificateChain(finalChain, dict(policyDnsNameCache)), outPerms)
			invariant 0 <= j && j <= len(leafHashes)
			for j := 0; j < len(leafHashes); j++ {
				unfold acc_leafHashes(leafHashes, currentDomain, dict(policyCache))
				leafHash := leafHashes[j]
				leafCacheEntry, ok := policyCache[leafHash]
				if !ok {
					fold acc_leafHashes(leafHashes, currentDomain, dict(policyCache))
					fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
					return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", leafHash), outPerms
				}
				unfold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
				unfold acc(PolicyCachePermissions_ImmutableHash(leafCacheEntry.immutableHash, leafHash, dict(immutablePolicyCache)), outPerms)
				fold acc(PolicyCachePermissions_ImmutableHash(leafCacheEntry.immutableHash, leafHash, dict(immutablePolicyCache)), outPerms)
				fold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
				unfold acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
				chain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms) in leafCacheEntry.immutableHash, domainRootPolicyCertificateChain, outPerms, 1/8)
				fold acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)

				/*ghost if finalChain != nil && finalChain != domainRootPolicyCertificateChain {
					refoldChain(finalChain, dict(policyDnsNameCache), outPerms, tmp)
				}*/
				ghost outPerms = tmp
				if err != nil {
					fold acc_leafHashes(leafHashes, currentDomain, dict(policyCache))
					fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
					return nil, fmt.Errorf("Failed to get policy cert chain with latest timestamp: %s", err), outPerms
				}

				fold acc_leafHashes(leafHashes, currentDomain, dict(policyCache))
				if chain != nil {
					if finalChain == nil || (unfolding acc(acc_policyCertificateChain(chain, dict(policyDnsNameCache)), outPerms) in (chain.DomainLatestMinMaxTimestamp)).After(unfolding acc(acc_policyCertificateChain(finalChain, dict(policyDnsNameCache)), outPerms) in finalChain.DomainLatestMinMaxTimestamp) {
						finalChain = chain
					}
				}
			}
			fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
		}
	}
	return finalChain, nil, outPerms
}

requires perms > 0
requires acc(&policyDnsNameCache, 1/4)
preserves len(chains) > 0
requires acc(policyDnsNameCache, 1/4)
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> (acc(&chains[k]) && chains[k] != nil && acc(acc_inj_policyCertificateChain(chains[k], k, dict(policyDnsNameCache)), perms))
ensures acc(&policyDnsNameCache, 1/4)
ensures acc(policyDnsNameCache, 1/4)
ensures err == nil  ==> res != nil && acc(acc_policyCertificateChain(res, dict(policyDnsNameCache)), perms)
func getNewestChain(chains []*PolicyCertificateChain, ghost perms perm) (res *PolicyCertificateChain, err error) {
	// TODO: handle cool-off period

	var newestChain *PolicyCertificateChain

	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)
	invariant acc(&policyDnsNameCache, 1/4)
	invariant acc(policyDnsNameCache, 1/4)
	invariant oldPolicyDnsNameCache === dict(policyDnsNameCache)
	invariant 0 <= i && i <= len(chains)
	invariant forall k int :: k >= i && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil && acc(acc_inj_policyCertificateChain(chains[k], k, dict(policyDnsNameCache)), perms)
	invariant i > 0 ==> newestChain != nil && acc(acc_policyCertificateChain(newestChain, dict(policyDnsNameCache)), perms)
	//for i, chain := range chains {
	for i := 0; i < len(chains); i++ {
		chain := chains[i]
		unfold acc(acc_inj_policyCertificateChain(chain, i, dict(policyDnsNameCache)), perms)
		if i == 0 {
			newestChain = chain
		} else {
			chainTime := unfolding acc(acc_policyCertificateChain(chain, dict(policyDnsNameCache)), perms) in chain.DomainRootIssuanceTimestamp
			newestChainTime := unfolding acc(acc_policyCertificateChain(newestChain, dict(policyDnsNameCache)), perms) in newestChain.DomainRootIssuanceTimestamp
			if chainTime.After(newestChainTime) {
		//if i == 0 || chain.DomainRootIssuanceTimestamp.After(newestChain.DomainRootIssuanceTimestamp) {
				newestChain = chain
			}
		}
	}
	return newestChain, nil
}

ghost
decreases
opaque
pure func normalizeDomainSpec(d string) string {
	return strings.HasSuffix(d, ".") ? d[:len(d) - 1] : d
}

// remove trailing dots from domain names
ensures res == normalizeDomainSpec(d)
func normalizeDomain(d string) (res string) { // added return param name
	dNormalized := d
	if strings.HasSuffix(dNormalized, ".") {
		dNormalized = dNormalized[:len(dNormalized)-1]
	}
	reveal normalizeDomainSpec(d)
	return dNormalized
}

// checks whether d1 is a subdomain of d2
// assumes that both inputs are valid domains without any wildcards
func isSameOrSubdomain(d1, d2 string) bool {
	d2Suffix := normalizeDomain(d2)
	if len(d2Suffix) > 0 {
		d2Suffix = "." + d2Suffix
	}
	return d1 == d2 || strings.HasSuffix(d1, d2Suffix)
}

ghost 
requires perms > 0
requires len(chainPolicies) == len(trustInfoPolicies)
requires forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
requires forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(&chainPolicies[k], perms)
requires forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> trustInfoPolicies[k] == chainPolicies[k]
requires forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, chain), perms)
ensures forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
ensures forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(&chainPolicies[k], perms)
ensures forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> trustInfoPolicies[k] == chainPolicies[k]
ensures forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, chain), perms)
ensures forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(acc_inj_trustInfo_policy(trustInfoPolicies[k], k), perms / 2)
decreases 
func halveTrustInfoApplicableChainPermissions(trustInfoPolicies []*common.PolicyCertificate, chainPolicies []*common.PolicyCertificate, chain *PolicyCertificateChain, policyDnsNameCache dict[string][]string, perms perm) /*{
	invariant oldLen >= 0
	invariant oldLen + len(chainPolicies) == len(trustInfoPolicies)
	invariant 0 <= i && i <= oldLen
	invariant forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < oldLen ==> acc(&trustInfoPolicies[k])
	invariant forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < i ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms / 2)
	invariant forall k int :: {&trustInfoPolicies[k]} i <= k && k < oldLen ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
	decreases len(trustInfoPolicies) - i
	for i := 0; i < oldLen; i++ {
		unfold acc_inj_trustInfo_policy(trustInfoPolicies[i], i, perms)
		unfold cache_SPCTs(trustInfoPolicies[i].SPCTs, perms)
		refoldForAllSPCTs(trustInfoPolicies[i].SPCTs, perms, perms / 2)
		fold cache_SPCTs(trustInfoPolicies[i].SPCTs, perms / 2)
		unfold policy_IssuerHash(trustInfoPolicies[i].IssuerHash, perms)
		fold policy_IssuerHash(trustInfoPolicies[i].IssuerHash, perms / 2)
		unfold acc_strs(trustInfoPolicies[i].PolicyAttributes.AllowedCAs, perms)
		fold acc_strs(trustInfoPolicies[i].PolicyAttributes.AllowedCAs, perms / 2)
		unfold acc_strs(trustInfoPolicies[i].PolicyAttributes.AllowedSubdomains, perms)
		fold acc_strs(trustInfoPolicies[i].PolicyAttributes.AllowedSubdomains, perms / 2)
		unfold acc_strs(trustInfoPolicies[i].PolicyAttributes.DisallowedSubdomains, perms)
		fold acc_strs(trustInfoPolicies[i].PolicyAttributes.DisallowedSubdomains, perms / 2)
		unfold acc_strs(trustInfoPolicies[i].PolicyAttributes.ExcludedSubdomains, perms)
		fold acc_strs(trustInfoPolicies[i].PolicyAttributes.ExcludedSubdomains, perms / 2)
		fold acc_inj_trustInfo_policy(trustInfoPolicies[i], i, perms / 2)
	}
	
	invariant perms > 0
	invariant oldLen >= 0
	invariant oldLen + len(chainPolicies) == len(trustInfoPolicies)
	invariant oldLen <= i && i <= len(trustInfoPolicies)
	invariant forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
	invariant forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(&chainPolicies[k])
	invariant forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < len(trustInfoPolicies) ==> trustInfoPolicies[k] == chainPolicies[k - oldLen]
	invariant forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < oldLen ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms / 2)
	invariant forall k int :: {&chainPolicies[k]} i - oldLen <= k && k < len(chainPolicies) ==> acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, perms, chain)
	invariant forall k int :: {&chainPolicies[k]} 0 <= k && k < i - oldLen ==> acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, perms / 2, chain)
	invariant forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < i ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms / 2)
	decreases len(trustInfoPolicies) - i
	for i := oldLen; i < len(trustInfoPolicies); i++ {
		unfold acc_inj_chainCertificate(chainPolicies[i - oldLen], len(chainPolicies) - (i - oldLen) - 1, policyDnsNameCache, perms, chain)
		unfold acc_strs(chainPolicies[i - oldLen].PolicyAttributes.AllowedCAs, perms)
		fold acc_strs(chainPolicies[i - oldLen].PolicyAttributes.AllowedCAs, perms / 2)
		fold acc_strs(trustInfoPolicies[i].PolicyAttributes.AllowedCAs, perms / 2)
		unfold acc_strs(chainPolicies[i - oldLen].PolicyAttributes.AllowedSubdomains, perms)
		fold acc_strs(chainPolicies[i - oldLen].PolicyAttributes.AllowedSubdomains, perms / 2)
		fold acc_strs(trustInfoPolicies[i].PolicyAttributes.AllowedSubdomains, perms / 2)
		unfold acc_strs(chainPolicies[i - oldLen].PolicyAttributes.DisallowedSubdomains, perms)
		fold acc_strs(chainPolicies[i - oldLen].PolicyAttributes.DisallowedSubdomains, perms / 2)
		fold acc_strs(trustInfoPolicies[i].PolicyAttributes.DisallowedSubdomains, perms / 2)
		unfold acc_strs(chainPolicies[i - oldLen].PolicyAttributes.ExcludedSubdomains, perms)
		fold acc_strs(chainPolicies[i - oldLen].PolicyAttributes.ExcludedSubdomains, perms / 2)
		fold acc_strs(trustInfoPolicies[i].PolicyAttributes.ExcludedSubdomains, perms / 2)
		unfold cache_SPCTs(chainPolicies[i - oldLen].SPCTs, perms)
		refoldForAllSPCTs(chainPolicies[i - oldLen].SPCTs, perms, perms / 2)
		fold cache_SPCTs(chainPolicies[i - oldLen].SPCTs, perms / 2)
		fold cache_SPCTs(trustInfoPolicies[i].SPCTs, perms / 2)
		unfold policy_IssuerHash(chainPolicies[i - oldLen].IssuerHash, perms)
		fold policy_IssuerHash(chainPolicies[i - oldLen].IssuerHash, perms / 2)
		fold policy_IssuerHash(trustInfoPolicies[i].IssuerHash, perms / 2)
		fold acc_inj_chainCertificate(chainPolicies[i - oldLen], len(chainPolicies) - (i - oldLen) - 1, policyDnsNameCache, perms / 2, chain)
		fold acc_inj_trustInfo_policy(trustInfoPolicies[i], i, perms / 2)
	}
}*/

/*
ghost
decreases
requires perms > 0
requires oldLen >= 0
requires oldLen + len(chainPolicies) == len(trustInfoPolicies)
requires forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
requires forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(&chainPolicies[k])
requires forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < len(trustInfoPolicies) ==> trustInfoPolicies[k] == chainPolicies[k - oldLen]
requires forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < oldLen ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
requires forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, perms / 2, chain)
requires forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < len(trustInfoPolicies) ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms / 2)
ensures forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
ensures forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
func combiningTrustInfoApplicableChainPermissions(trustInfoPolicies []*common.PolicyCertificate, chainPolicies []*common.PolicyCertificate, chain *PolicyCertificateChain, oldLen int, policyDnsNameCache dict[string][]string, perms perm) {
	invariant perms > 0
	invariant oldLen >= 0
	invariant oldLen + len(chainPolicies) == len(trustInfoPolicies)
	invariant oldLen <= i && i <= len(trustInfoPolicies)
	invariant forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
	invariant forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(&chainPolicies[k])
	invariant forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < len(trustInfoPolicies) ==> trustInfoPolicies[k] == chainPolicies[k - oldLen]
	invariant forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < oldLen ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
	invariant forall k int :: {&trustInfoPolicies[k]} i <= k && k < len(trustInfoPolicies) ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms / 2)
	invariant forall k int :: {&chainPolicies[k]} i - oldLen <= k && k < len(chainPolicies) ==> acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, perms / 2, chain)
	invariant forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < i ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
	decreases len(trustInfoPolicies) - i
	for i := oldLen; i < len(trustInfoPolicies); i++ {
		unfold acc_inj_chainCertificate(chainPolicies[i - oldLen], len(chainPolicies) - (i - oldLen) - 1, policyDnsNameCache, perms / 2, chain)
		unfold acc_inj_trustInfo_policy(trustInfoPolicies[i], i, perms / 2)
		unfold cache_SPCTs(chainPolicies[i - oldLen].SPCTs, perms / 2)
		unfold cache_SPCTs(trustInfoPolicies[i].SPCTs, perms / 2)
		combineSPCTs(trustInfoPolicies[i].SPCTs, perms / 2, perms)
		fold cache_SPCTs(chainPolicies[i - oldLen].SPCTs, perms)
		unfold policy_IssuerHash(chainPolicies[i - oldLen].IssuerHash, perms / 2)
		unfold policy_IssuerHash(trustInfoPolicies[i].IssuerHash, perms / 2)
		fold policy_IssuerHash(chainPolicies[i - oldLen].IssuerHash, perms)
		fold acc_inj_trustInfo_policy(trustInfoPolicies[i], i, perms)
	}
}*/

// Evaluate whether connection should be allowed according to
// policy mode based on current state of the cache.
requires acc(&policyCache, 1/2)
requires acc(&immutablePolicyCache, 1/2)
requires acc(&policyDnsNameCache, 1/2)
requires inPerms > 0
requires acc(immutablePolicyCache, 1/2)
requires acc(policyCache, 1/2)
requires acc(policyDnsNameCache, 1/2)
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
requires acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
requires PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)) 
requires acc_trustInfo(trustInfo, dict(policyDnsNameCache))
requires unfolding acc_trustInfo(trustInfo, dict(policyDnsNameCache)) in (trustInfo.EvaluationResult == 0 && len(trustInfo.ConflictingPolicyAttributes) == 0)
requires unfolding acc_trustInfo(trustInfo, dict(policyDnsNameCache)) in len(trustInfo.PolicyChain) == 0
ensures acc(&policyCache, 1/2)
ensures acc(&immutablePolicyCache, 1/2)
ensures acc(&policyDnsNameCache, 1/2)
ensures outPerms > 0
ensures outPerms <= inPerms
ensures acc(immutablePolicyCache, 1/2)
ensures acc(policyCache, 1/2)
ensures acc(policyDnsNameCache, 1/2)
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
ensures PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)) 
ensures acc(acc_trustInfo(trustInfo, dict(policyDnsNameCache)), outPerms)
ensures err == nil ==> (unfolding acc(acc_trustInfo(trustInfo, dict(policyDnsNameCache)), outPerms) in (toAbstractChain(trustInfo.PolicyChain) == genAbstractChain(dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))))
ensures err == nil ==> (unfolding acc(acc_trustInfo(trustInfo, dict(policyDnsNameCache)), outPerms) in (trustInfo.EvaluationResult == 0 ==> len(trustInfo.ConflictingPolicyAttributes) > 0 && !(validAgainstAllPolicies(toAbstractChain(trustInfo.PolicyChain), toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), len(trustInfo.PolicyChain)))))
ensures err == nil ==> (unfolding acc(acc_trustInfo(trustInfo, dict(policyDnsNameCache)), outPerms) in (trustInfo.EvaluationResult == 1 ==> len(trustInfo.ConflictingPolicyAttributes) == 0 && (validAgainstAllPolicies(toAbstractChain(trustInfo.PolicyChain), toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), len(trustInfo.PolicyChain)))))
func VerifyPolicy(trustInfo *PolicyTrustInfo, ghost inPerms perm) (err error, ghost outPerms perm) {

	ghost policyCacheView := dict(policyCache)
	ghost immutablePolicyCacheView := dict(immutablePolicyCache)
	ghost policyDnsNameCacheView := dict(policyDnsNameCache)

	ghost abstractChain := genAbstractChain(dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))

	unfold acc_trustInfo(trustInfo, policyDnsNameCacheView)

	// Gobra can only have one return element for pure functions
	/*e2ld, err := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName)
	if err != nil {
		return fmt.Errorf("Failed to get E2LD of %s: %s", trustInfo.DNSName, err)
	}*/

	e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName)

	// TODO (cyrill): ensure that enough map servers are queried and that enough full responses were returned

	// debug
	// fmt.Printf("root cert subject: %s\n", trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1].Subject.ToRDNSequence().String())
	// get all certificate chains for the E2LD
	e2ldChains, err, tmp := findPolicyCertificateChainsForE2LD(e2ld, inPerms)
	ghost outPerms = tmp
	//ghost refoldTrustInfoPolicy(trustInfo.PolicyChain, inPerms, outPerms)
	//ghost refoldTrustInfoConflictingPolicyAttributes(trustInfo.ConflictingPolicyAttributes, inPerms, outPerms) 
	if err != nil {
		fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms)
		return err, outPerms
	}
	fmt.Printf("domain root chains: %+v\n", e2ldChains)
	if len(e2ldChains) == 0 {
		// no applicable policy certificates exist
		trustInfo.EvaluationResult = 1
		assume len(abstractChain) == 0
		//reveal validAgainstAllPolicies(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), 0)
		//lemmaEmptyConflictingPolicyAttributes(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
		lemmaCheckNoPolicy(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
	/*	assert acc(trustInfo)
		assert outPerms > 0
		assert outPerms <= 1*/
		fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms)
		return nil, outPerms
	}
	// find newest chain for e2ld	
	newestE2ldChain, err := getNewestChain(e2ldChains, outPerms)
	if err != nil {
		fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms)
		return err, outPerms
	}
	// find newest chain containing e2ld
	applicableChain, err, tmp := findPolicyCertificateChainForDomain(trustInfo.DNSName, newestE2ldChain, outPerms)
	//ghost refoldTrustInfoPolicy(trustInfo.PolicyChain, outPerms, tmp)
	//ghost refoldTrustInfoConflictingPolicyAttributes(trustInfo.ConflictingPolicyAttributes, outPerms, tmp)
	ghost outPerms = tmp
	if err != nil {
		fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms)
		return err, outPerms
	}
	fmt.Printf("applicable chain: %+v\n", applicableChain)
	unfold acc(acc_policyCertificateChain(applicableChain, policyDnsNameCacheView), outPerms)

	trustInfo.PolicyChain = append(outPerms / 2, trustInfo.PolicyChain, applicableChain.PolicyCertificates...)
	
	ghost halveTrustInfoApplicableChainPermissions(trustInfo.PolicyChain, applicableChain.PolicyCertificates, applicableChain, policyDnsNameCacheView, outPerms)
	//ghost refoldPolicyCache(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms, outPerms/2)
	//ghost refoldTrustInfoConflictingPolicyAttributes(trustInfo.ConflictingPolicyAttributes, outPerms, outPerms / 2)
	// extract policies and validate certificate based on extracted policies
	rootCertificate := trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1].Subject.ToRDNSequence().String()

	assume abstractChain == toAbstractChain(trustInfo.PolicyChain)

	//assume abstractChain == genAbstractChain(dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
	//reveal validAgainstAllPolicies(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), 0)

	lemmaCheckNoPolicy(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))

	invariant outPerms <= inPerms
	invariant outPerms == old(outPerms)
	invariant outPerms > 0
	invariant acc(&policyCache, 1/2)
	invariant acc(&policyDnsNameCache, 1/2)
	invariant acc(&immutablePolicyCache, 1/2)
	invariant acc(policyCache, 1/2)
	invariant acc(policyDnsNameCache, 1/2)
	invariant acc(immutablePolicyCache, 1/2)
	invariant policyCacheView == dict(policyCache)
	invariant immutablePolicyCacheView == dict(immutablePolicyCache)
	invariant policyDnsNameCacheView == dict(policyDnsNameCache)
	invariant acc(PolicyCachePermissions(policyCacheView, immutablePolicyCacheView, policyDnsNameCacheView), outPerms / 2)
	invariant acc(ImmutablePolicyCachePermissions(immutablePolicyCacheView, policyCacheView), 1/4)
	invariant PolicyDnsNameCachePermissions(policyDnsNameCacheView, policyCacheView) 
	invariant acc(trustInfo)
	invariant forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(&trustInfo.ConflictingPolicyAttributes[k])
	invariant forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(acc_inj_trustInfo_conflictingPolicyAttributes_attr(trustInfo.ConflictingPolicyAttributes[k], k), outPerms / 2)
	invariant forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(&trustInfo.PolicyChain[k], outPerms / 2)
	invariant len(trustInfo.CertificateChain) > 0 && acc(&trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1], outPerms / 2) && acc(trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1], outPerms / 2)
	invariant let e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName) in (e2ld in domain(policyDnsNameCacheView))
	invariant acc(applicableChain, outPerms / 2)
	invariant len(applicableChain.PolicyCertificates) >= 1
	invariant (forall l int :: {&applicableChain.PolicyCertificates[l]} 0 <= l && l < len(applicableChain.PolicyCertificates) ==> acc(&applicableChain.PolicyCertificates[l], outPerms / 2))
	invariant 0 <= idx && idx <= len(applicableChain.PolicyCertificates)
	invariant (forall l int :: {&applicableChain.PolicyCertificates[l]} idx <= l && l < len(applicableChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(applicableChain.PolicyCertificates[l], len(applicableChain.PolicyCertificates) - l - 1, policyDnsNameCacheView, applicableChain), outPerms / 2)) // do not fold back in case we add attributes arrays to trustInfo. Use permissions for that!
	invariant len(applicableChain.PolicyCertificates) == len(trustInfo.PolicyChain)
	invariant forall k int :: {&trustInfo.PolicyChain[k]} {&applicableChain.PolicyCertificates[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> trustInfo.PolicyChain[k] == applicableChain.PolicyCertificates[k]
	invariant forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(acc_inj_trustInfo_policy(trustInfo.PolicyChain[k], k), outPerms / 2)
	invariant len(trustInfo.PolicyChain) == len(abstractChain)
	invariant abstractChain == old(abstractChain)
	invariant abstractChain == genAbstractChain(dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
	invariant abstractChain == toAbstractChain(trustInfo.PolicyChain)
	invariant len(trustInfo.ConflictingPolicyAttributes) > 0 ==> !(validAgainstAllPolicies(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), idx))
	invariant len(trustInfo.ConflictingPolicyAttributes) == 0 ==> (validAgainstAllPolicies(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), idx))
	invariant rootCertificate == trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1].Subject.ToRDNSequence().String()
	decreases len(applicableChain.PolicyCertificates) - idx//i0
	//for idx, policyCert := range applicableChain.PolicyCertificates with i0 {
	for idx := 0; idx < len(applicableChain.PolicyCertificates); idx++ {
		policyCert := applicableChain.PolicyCertificates[idx]

		unfold acc(acc_inj_chainCertificate(applicableChain.PolicyCertificates[idx], len(applicableChain.PolicyCertificates) - idx - 1, policyDnsNameCacheView, applicableChain), outPerms / 2)

		err := policyCert.PolicyAttributes.ValidateAttributes()

		if err != nil {
			dom := policyCert.Domain()
			fold acc(acc_inj_chainCertificate(applicableChain.PolicyCertificates[idx], len(applicableChain.PolicyCertificates) - idx - 1, policyDnsNameCacheView, applicableChain), outPerms / 2)
			//ghost combiningTrustInfoApplicableChainPermissions(trustInfo.PolicyChain, applicableChain.PolicyCertificates, applicableChain, oldLen, policyDnsNameCacheView, outPerms)
			fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms / 2)
			return fmt.Errorf("Failed to validate attributes for domain %s: %s", dom, err), outPerms / 2
		}

		// check for the status of the subdomains
		policyCertDomain := normalizeDomain(policyCert.Domain()) // TODO ISN'T THIS DONE BY CheckDomainValidity ANYWAY?
		unfold acc(acc_strs(policyCert.PolicyAttributes.AllowedCAs), outPerms / 4)
		unfold acc(acc_strs(policyCert.PolicyAttributes.AllowedSubdomains), outPerms / 4)
		unfold acc(acc_strs(policyCert.PolicyAttributes.DisallowedSubdomains), outPerms / 4)
		unfold acc(acc_strs(policyCert.PolicyAttributes.ExcludedSubdomains), outPerms / 4)
		domainValidity := policyCert.PolicyAttributes.CheckDomainValidity(policyCertDomain, trustInfo.DNSName, outPerms / 8)
		fold acc(acc_strs(policyCert.PolicyAttributes.AllowedCAs), outPerms / 4)
		fold acc(acc_strs(policyCert.PolicyAttributes.AllowedSubdomains), outPerms / 4)
		fold acc(acc_strs(policyCert.PolicyAttributes.DisallowedSubdomains), outPerms / 4)
		fold acc(acc_strs(policyCert.PolicyAttributes.ExcludedSubdomains), outPerms / 4)


		// check if the domain should not consider policies
		if idx == 0 && domainValidity == common.PolicyAttributeDomainExcluded {
			trustInfo.DomainExcluded = true
		}

		// check if the domain is allowed or not
		if domainValidity == common.PolicyAttributeDomainAllowed {
			
			lemmaDomainAllowedValid(trustInfo.PolicyChain[idx], idx, abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), outPerms / 4)
			//assert validityOfDomain(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))

			// no conflicting domain attribute
		} else if domainValidity == common.PolicyAttributeDomainDisallowed {
			
			lemmaDomainDisallowedInvalid(trustInfo.PolicyChain[idx], idx, abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), outPerms / 4)
			assert !validityOfDomain(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
			attr := &common.PolicyAttributes{AllowedSubdomains: policyCert.PolicyAttributes.AllowedSubdomains, DisallowedSubdomains: policyCert.PolicyAttributes.DisallowedSubdomains}
			fold acc(acc_strs(attr.AllowedCAs), outPerms / 2)
			fold acc(acc_strs(attr.ExcludedSubdomains), outPerms / 2)
			fold acc(acc_policyAttributes(attr), outPerms / 2)
			confAttr := &ConflictingPolicyAttribute{Domain: policyCert.Domain(), Attribute: attr}
			trustInfo.ConflictingPolicyAttributes = append(perm(1/2), trustInfo.ConflictingPolicyAttributes, confAttr)
			fold acc(acc_inj_trustInfo_conflictingPolicyAttributes_attr(confAttr, len(trustInfo.ConflictingPolicyAttributes) - 1), outPerms / 2)
			//assert !validityOfDomain(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
		} /*added*/ else {
			//assert domainValidity == common.PolicyAttributeDomainExcluded // TODO DO WE REALLY NEED THIS?
			lemmaDomainExcludedValid(trustInfo.PolicyChain[idx], idx, abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), outPerms / 4)
			//assert validityOfDomain(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
		}

		// check for allowed CAs
		if len(policyCert.PolicyAttributes.AllowedCAs) > 0 {
			fmt.Printf("Checking if %s is contained in %+v\n", rootCertificate, policyCert.PolicyAttributes.AllowedCAs)
			if !Contains(policyCert.PolicyAttributes.AllowedCAs, rootCertificate, outPerms / 4) { // changed from !slices.Contains
				
				attr := &common.PolicyAttributes{AllowedCAs: policyCert.PolicyAttributes.AllowedCAs}
				fold acc(acc_strs(attr.AllowedSubdomains), outPerms / 2)
				fold acc(acc_strs(attr.DisallowedSubdomains), outPerms / 2)
				fold acc(acc_strs(attr.ExcludedSubdomains), outPerms / 2)
				reveal strsToSeq(policyCert.PolicyAttributes.AllowedCAs)
				
				
				lemmaNotValidAgainstCA(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
				fold acc(acc_policyAttributes(attr), outPerms / 2)
				confAttr := &ConflictingPolicyAttribute{Domain: policyCert.Domain(), Attribute: attr}
				trustInfo.ConflictingPolicyAttributes = append(perm(1/2), trustInfo.ConflictingPolicyAttributes, confAttr)
				fold acc(acc_inj_trustInfo_conflictingPolicyAttributes_attr(confAttr, len(trustInfo.ConflictingPolicyAttributes) - 1), outPerms / 2)
				
				//assert !validityOfCA(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
			} /* added */ else {
				reveal strsToSeq(policyCert.PolicyAttributes.AllowedCAs)
				assert len(unfolding acc(acc_inj_trustInfo_policy(trustInfo.PolicyChain[idx], idx), outPerms / 2) in trustInfo.PolicyChain[idx].PolicyAttributes.AllowedCAs) == len(abstractChain[idx].AllowedCAs)
			lemmaValidAgainstCA(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
				assert validityOfCA(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
				
			}
		}/* added */ else {
			reveal strsToSeq(policyCert.PolicyAttributes.AllowedCAs)
				
			lemmaValidAgainstCA(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
				
				
				//assert validityOfCA(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
			}

		
		lemmaValidAgainstAllPoliciesPlus1(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), idx)
	}
	if len(trustInfo.ConflictingPolicyAttributes) > 0 {
		trustInfo.EvaluationResult = 0
	} else {
		trustInfo.EvaluationResult = 1
	}
	fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms / 2)
	return nil, outPerms / 2
}

// Gobra does not support Generics. Thus, we can not use the Contains function from slices. 
// The import from slices was also removed for this reason!
requires perms > 0
requires acc(acc_strs(s), perms)
ensures acc(acc_strs(s), perms)
ensures res == unfolding acc(acc_strs(s), perms) in (exists k int :: {&s[k]} 0 <= k && k < len(s) && s[k] == e)
//ensures res == unfolding acc_strs(s, perms) in (e in toSeq(s))
func Contains(s []string, e string, ghost perms perm) (res bool)

// added
ghost
requires acc_strs(s)
ensures res == unfolding acc_strs(s) in (exists k int :: {&s[k]} 0 <= k && k < len(s) && s[k] == e)
//ensures res == unfolding acc_strs(s, perms) in (e in toSeq(s))
decreases
pure func AContains(s []string, e string) (res bool)
