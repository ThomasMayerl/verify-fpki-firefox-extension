package cache_v2

import (
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
	"time"
	
	"fpki/pkg/common"
	"net/publicsuffix"
)

// create new PolicyTrustInfo
func NewPolicyTrustInfo(dnsName string, certificateChain []*x509.Certificate) *PolicyTrustInfo {
	policyTrustInfo := &PolicyTrustInfo{
		DNSName:                     dnsName,
		CertificateChain:            certificateChain,
		PolicyChain:                 nil,
		ConflictingPolicyAttributes: nil,
		PolicyChainTrustLevel:       0,
		EvaluationResult:            0,
		MaxValidity:                 time.Unix(0, 0),
		DomainExcluded:              false,
	}
	return policyTrustInfo
}

type PolicyTrustPreference struct {
	// PCA public keys
	PCAPublicKey string

	// TODO (cyrill): also implement setting the trust preferences for specific policy certificate
	// // Immutable hash of PCA certificate
	// PCAImmutableHash string

	// map CA set to TrustLevel
	TrustLevel int
}

type ConflictingPolicyAttribute struct {
	Domain    string
	Attribute *common.PolicyAttributes
}

type PolicyTrustInfo struct {
	// domain name used in the connection
	DNSName string

	// certificate chain received during the connection establishment
	CertificateChain []*x509.Certificate

	// CA set ID's and example subjects, and trust level of the
	// cached certificate chains that led to a failed
	// validation
	// (might be useful to construct error messages)

	// json encoded policy certifcates
	PolicyChain                 []*common.PolicyCertificate
	ConflictingPolicyAttributes []*ConflictingPolicyAttribute
	PolicyChainTrustLevel       int `default:"0"`

	// result of legacy validation
	// a value of 1 indicates that validation
	// was passed.
	// a value != 1 indicates failed validation
	EvaluationResult int `default:"0"`

	// timestamp indicating how long this
	// legacy validation outcome can be cached
	MaxValidity time.Time

	// true if the most specific policy (i.e., highest number of subdomains) added DNSName (or a
	// parent of DNSName) as an excluded subdomain where no policy attributes are applied
	DomainExcluded bool
}

// maps a domain name to a set of legacy trust preferences
// to be used to compute certificate chain trust levels
// TODO Unused? Only breaks verification because of assigning to global variables, but we never read from it
// var policyTrustPreferences = map[string][]*PolicyTrustPreference{}

type PolicyCertificateChain struct {
	PolicyCertificates                       []*common.PolicyCertificate
	DomainRootIssuanceTimestamp              time.Time
	DomainRootMinMaxTimestamp                time.Time
	RootAndIntermediateLatestMinMaxTimestamp time.Time
	DomainLatestMinMaxTimestamp              time.Time
	TrustLevel                               int

	// DisseminationTime  time.Time
}

preserves forall k int :: {pcChain.PolicyCertificates[k]} 0 <= k && k < len(pcChain.PolicyCertificates) ==> (acc(&pcChain.PolicyCertificates[k]) && (forall l int :: {pcChain.PolicyCertificates[l]} 0 <= l && l < len(pcChain.PolicyCertificates) && k != l ==> &pcChain.PolicyCertificates[k] != &pcChain.PolicyCertificates[l]) && acc(pcChain.PolicyCertificates[k], _/*getCertificatePerm(pcChain.PolicyCertificates[k])*/))// && acc(&pcChain.PolicyCertificates[k].PolicyAttributes))
func (pcChain PolicyCertificateChain) String() string {
	str := fmt.Sprintf("<PolicyCertificateChain len=%d", len(pcChain.PolicyCertificates))
	str += fmt.Sprintf(", DomainRootIssuanceTimestamp=%v", pcChain.DomainRootIssuanceTimestamp)
	str += fmt.Sprintf(", DomainRootMinMaxTimestamp=%v", pcChain.DomainRootMinMaxTimestamp)
	str += fmt.Sprintf(", RootAndIntermediateLatestMinMaxTimestamp=%v", pcChain.RootAndIntermediateLatestMinMaxTimestamp)
	str += ", certs="
	invariant forall k int :: 0 <= k && k < len(pcChain.PolicyCertificates) ==> (acc(&pcChain.PolicyCertificates[k]) && (forall l int :: {pcChain.PolicyCertificates[l]} 0 <= l && l < len(pcChain.PolicyCertificates) && k != l ==> &pcChain.PolicyCertificates[k] != &pcChain.PolicyCertificates[l]) && acc(pcChain.PolicyCertificates[k], _))
	invariant 0 <= i && i <= len(pcChain.PolicyCertificates)
	//for _, pc := range pcChain.PolicyCertificates {
	for i := 0; i < len(pcChain.PolicyCertificates); i++ {
		pc := pcChain.PolicyCertificates[i]
		if pc == nil {
			str += "nil, "
			continue
		}
		attributes, err := json.Marshal(pc.PolicyAttributes)
		if err != nil {
			break
		}
		pcStr := fmt.Sprintf("<Policy domain=%s, attributes=%s, #SPCTs=%d, hash=%s, immHash=%s >", pc.Domain(), attributes, len(pc.SPCTs), getPolicyHash(pc), getImmutablePolicyHash(pc))
		// pcStr, err := common.ToJSON(pc)
		// if err != nil {
		// break
		// }
		str += fmt.Sprintf("%s, ", pcStr)
	}
	return str + ">"
}

ensures acc(res) && len(res.PolicyCertificates) == 0
func NewPolicyCertificateChain() (res *PolicyCertificateChain) { // Named return variable for postcondition
	return &PolicyCertificateChain{
		PolicyCertificates:                       []*common.PolicyCertificate{},
		DomainRootIssuanceTimestamp:              time.Unix(0, 0),
		DomainRootMinMaxTimestamp:                time.Unix(0, 0),
		RootAndIntermediateLatestMinMaxTimestamp: time.Unix(0, 0),
		DomainLatestMinMaxTimestamp:              time.Unix(0, 0),
		TrustLevel:                               0,
	}
}

// initialize legacyTrustPreferences with a config
// TODO Unused? Only breaks verification because of assigning to global variables, but we never read from it
/* func InitializePolicyTrustPreferences(configMap map[string]interface{}) {
	policyTrustPreferences = map[string][]*PolicyTrustPreference{}

	// parse policy CA sets
	pcaSetsMap := map[string][]string{}
	pcaSets := configMap["policy-ca-sets"].(map[string]interface{})
	for pcaSetID, values := range pcaSets {
		pcaSetsMap[pcaSetID] = []string{}
		v := values.(map[string]interface{})
		for _, value := range v["pcas"].([]interface{}) {
			pcaSetsMap[pcaSetID] = append(pcaSetsMap[pcaSetID], value.(string))
		}
	}

	// parse policy CAs
	pcasPublicKeyMap := map[string]string{}
	pcas := configMap["policy-cas"].(map[string]interface{})
	for pcaID, values := range pcas {
		v := values.(map[string]interface{})
		pcasPublicKeyMap[pcaID] = v["publickey"].(string)
	}

	// get trust level map
	trustLevelMap := configMap["trust-levels"].(map[string]interface{})

	// parse policy trust preferences
	policyTrustPreferencesJSON := configMap["policy-trust-preference"].(map[string]interface{})
	for domainVar, entry := range policyTrustPreferencesJSON {
		domainTrustPreferences := []*PolicyTrustPreference{}
		objects := entry.([]interface{})
		for _, object := range objects {
			objectMap := object.(map[string]interface{})
			trustLevel := int(trustLevelMap[objectMap["level"].(string)].(float64))
			pcaSetID := objectMap["policy-ca-set"].(string)
			for _, pca := range pcaSetsMap[pcaSetID] {
				policyTrustPreference := &PolicyTrustPreference{
					PCAPublicKey: pcasPublicKeyMap[pca],
					TrustLevel:   trustLevel,
				}
				domainTrustPreferences = append(domainTrustPreferences, policyTrustPreference)
			}
		}
		policyTrustPreferences[domainVar] = domainTrustPreferences
	}
} */

ghost 
decreases
requires outPerms <= inPerms
requires inPerms > 0
requires outPerms > 0
requires forall k int :: {chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil
requires forall k int :: {chains[k]} 0 <= k && k < len(chains) ==> acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache, inPerms)
ensures forall k int :: {chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil
ensures forall k int :: {chains[k]} 0 <= k && k < len(chains) ==> acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache, outPerms)
func refoldChains(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string, inPerms perm, outPerms perm) {
	invariant 0 <= i && i <= len(chains)
	invariant outPerms <= inPerms
	invariant outPerms > 0
	invariant inPerms > 0
	invariant inPerms == old(inPerms)
	invariant outPerms == old(outPerms) 
	invariant forall k int :: {chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil
	invariant forall k int :: {chains[k]} 0 <= k && k < i ==> acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache, outPerms)
	invariant forall k int :: {chains[k]} i <= k && k < len(chains) ==> acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache, inPerms)
	decreases len(chains) - i
	for i := 0; i < len(chains); i++ {
		unfold acc_inj_policyCertificateChain(chains[i], i, policyDnsNameCache, inPerms)
		refoldChain(chains[i], policyDnsNameCache, inPerms, outPerms)
		fold acc_inj_policyCertificateChain(chains[i], i, policyDnsNameCache, outPerms)
	}
}

ghost 
decreases
requires outPerms <= inPerms
requires inPerms > 0
requires outPerms > 0
requires acc_policyCertificateChain(chain, policyDnsNameCache, inPerms)
ensures acc_policyCertificateChain(chain, policyDnsNameCache, outPerms)
func refoldChain(chain *PolicyCertificateChain, policyDnsNameCache dict[string][]string, inPerms perm, outPerms perm) {
	unfold acc_policyCertificateChain(chain, policyDnsNameCache, inPerms)
	invariant acc(chain)
	invariant 0 <= i && i <= len(chain.PolicyCertificates)
	invariant outPerms <= inPerms
	invariant outPerms > 0
	invariant inPerms > 0
	invariant inPerms == old(inPerms)
	invariant outPerms == old(outPerms)
	invariant len(chain.PolicyCertificates) >= 1
	invariant forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc(&chain.PolicyCertificates[l])
	invariant forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < i ==> acc_inj_chainCertificate(chain.PolicyCertificates[l], len(chain.PolicyCertificates) - l - 1, policyDnsNameCache,outPerms, chain)
	invariant forall l int :: {&chain.PolicyCertificates[l]} i <= l && l < len(chain.PolicyCertificates) ==> acc_inj_chainCertificate(chain.PolicyCertificates[l], len(chain.PolicyCertificates) - l - 1, policyDnsNameCache,inPerms, chain)
	invariant i == 0 ==> unfolding acc_inj_chainCertificate(chain.PolicyCertificates[0], len(chain.PolicyCertificates) - 0 - 1, policyDnsNameCache,inPerms, chain) in chain.PolicyCertificates[0].Domain() in domain(policyDnsNameCache)
	invariant i > 0 ==> unfolding acc_inj_chainCertificate(chain.PolicyCertificates[0], len(chain.PolicyCertificates) - 0 - 1,policyDnsNameCache, outPerms, chain) in chain.PolicyCertificates[0].Domain() in domain(policyDnsNameCache)
	decreases len(chain.PolicyCertificates) - i
	for i := 0; i < len(chain.PolicyCertificates); i++ {
		unfold acc_inj_chainCertificate(chain.PolicyCertificates[i], len(chain.PolicyCertificates) - i - 1, policyDnsNameCache, inPerms, chain)
		fold acc_inj_chainCertificate(chain.PolicyCertificates[i], len(chain.PolicyCertificates) - i - 1, policyDnsNameCache, outPerms, chain)
	}
	fold acc_policyCertificateChain(chain, policyDnsNameCache, outPerms)
}

ghost
decreases
requires outPerms <= inPerms
requires outPerms > 0
requires inPerms > 0
requires forall l int :: {&spcts[l]} 0 <= l && l < len(spcts) ==> cache_SPCT(&spcts[l], l, inPerms)
ensures forall l int :: {&spcts[l]} 0 <= l && l < len(spcts) ==> cache_SPCT(&spcts[l], l, outPerms)
ensures outPerms == inPerms / 2 ==> forall l int :: {&spcts[l]} 0 <= l && l < len(spcts) ==> cache_SPCT(&spcts[l], l, outPerms) // so we can use the predicate inside of another cache_SPCTs
func refoldForAllSPCTs(spcts []common.SignedPolicyCertificateTimestamp, inPerms perm, outPerms perm) {
	invariant 0 <= i && i <= len(spcts)
	invariant outPerms <= inPerms
	invariant outPerms > 0
	invariant inPerms > 0
	invariant inPerms == old(inPerms)
	invariant outPerms == old(outPerms)
	invariant forall k int :: {&spcts[k]} 0 <= k && k < i ==> cache_SPCT(&spcts[k], k, outPerms)
	invariant forall k int :: {&spcts[k]} i <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k, inPerms)
	invariant outPerms == inPerms / 2 ==> forall k int :: {&spcts[k]} 0 <= k && k < i ==> cache_SPCT(&spcts[k], k, outPerms)
	decreases len(spcts) - i
	for i := 0; i < len(spcts); i++ {
		unfold cache_SPCT(&spcts[i], i, inPerms)
		fold cache_SPCT(&spcts[i], i, outPerms)
		if outPerms == inPerms / 2 {
			fold cache_SPCT(&spcts[i], i, outPerms)
		}
	}
}

ghost decreases
requires outPerms <= inPerms
requires outPerms > 0
requires inPerms > 0
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache, inPerms)
ensures PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache, outPerms)
func refoldPolicyCache(policyCache dict[string]*PolicyCacheEntry, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyDnsNameCache dict[string][]string, inPerms perm, outPerms perm)

ghost decreases
requires outPerms <= inPerms
requires outPerms > 0
requires inPerms > 0
// acc(..., 1/2) so we know that we don't change any other invariants!
requires forall str string :: {policyCache[str]} str in domain(policyCache) && str != excl ==> acc(policyCache[str], 1/2) && cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache, inPerms)
ensures forall str string :: {policyCache[str]} str in domain(policyCache) && str != excl ==> acc(policyCache[str], 1/2) && cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache, outPerms)
func refoldPoliciesExceptFor(policyCache dict[string]*PolicyCacheEntry, excl string, policyDnsNameCache dict[string][]string, inPerms perm, outPerms perm)

ghost
requires outPerms <= inPerms
requires inPerms > 0
requires outPerms > 0
requires forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> acc(&policies[k]) && acc_inj_trustInfo_policy(policies[k], k, inPerms)
ensures forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> acc(&policies[k]) && acc_inj_trustInfo_policy(policies[k], k, outPerms)
decreases
func refoldTrustInfoPolicy(policies []*common.PolicyCertificate, inPerms perm, outPerms perm) {
	invariant 0 <= i && i <= len(policies)
	invariant outPerms <= inPerms
	invariant outPerms > 0
	invariant inPerms > 0
	invariant inPerms == old(inPerms)
	invariant outPerms == old(outPerms)
	invariant forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> acc(&policies[k])
	invariant forall k int :: {&policies[k]} 0 <= k && k < i ==> acc_inj_trustInfo_policy(policies[k], k, outPerms)
	invariant forall k int :: {&policies[k]} i <= k && k < len(policies) ==> acc_inj_trustInfo_policy(policies[k], k, inPerms)
	decreases len(policies) - i
	for i := 0; i < len(policies); i++ {
		unfold acc_inj_trustInfo_policy(policies[i], i, inPerms)
		fold acc_inj_trustInfo_policy(policies[i], i, outPerms)
	}
}

// find the policy certificate chain which has the latest max timestamp in the set [issuance, SPCT time 1, SPCT time 2, ...].
// The second parameter is an optional root chain (e.g., domain root cert to root cert) that must be used. If nil is passed as an argument, any chain is accepted. If no acceptable chain can be generated, nil is returned.
requires cachePerms > 0
requires acc(immutablePolicyCache, cachePerms)
requires acc(policyCache, cachePerms)
requires acc(policyDnsNameCache, cachePerms)
requires inPerms > 0
requires rootChain != nil ==> acc_policyCertificateChain(rootChain, dict(policyDnsNameCache), inPerms)
requires forall str string :: {immutablePolicyCache[str]} str in domain(immutablePolicyCache) ==> 
    acc(immutablePolicyCache[str], cachePerms) &&
    ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, dict(policyCache))
requires PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), inPerms)
ensures acc(immutablePolicyCache, cachePerms)
ensures acc(policyCache, cachePerms)
ensures acc(policyDnsNameCache, cachePerms)
ensures outPerms > 0
ensures outPerms <= inPerms
ensures err == nil ==> res != nil
ensures rootChain != nil ==> acc_policyCertificateChain(rootChain, dict(policyDnsNameCache), outPerms)
ensures forall str string :: {immutablePolicyCache[str]} str in domain(immutablePolicyCache) ==> 
    acc(immutablePolicyCache[str], cachePerms) &&
    ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, dict(policyCache))
ensures PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
ensures (rootChain != nil || immutableHash != base64.StdEncoding.EncodeToString(nil)) && res != rootChain && err == nil ==>  acc_policyCertificateChain(res, dict(policyDnsNameCache), outPerms)
ensures rootChain == nil && err == nil && immutableHash == base64.StdEncoding.EncodeToString(nil) ==> acc(res) && len(res.PolicyCertificates) == 0
func getPolicyCertificateChainWithLatestTimestamp(immutableHash string, rootChain *PolicyCertificateChain, ghost inPerms perm, ghost cachePerms perm) (res *PolicyCertificateChain, err error, ghost outPerms perm) { // added names to reference return variables in postcondition 
	ghost outPerms = inPerms
	if rootChain != nil {
		if immutableHash == unfolding acc_policyCertificateChain(rootChain, dict(policyDnsNameCache), outPerms) in unfolding acc_inj_chainCertificate(rootChain.PolicyCertificates[0], len(rootChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache), outPerms, rootChain) in getImmutablePolicyHash(rootChain.PolicyCertificates[0]) {
			return rootChain, nil, outPerms
		}
	} else {
		if immutableHash == base64.StdEncoding.EncodeToString(nil) {
			return NewPolicyCertificateChain(), nil, outPerms
		}
	}
	issuerEntry, ok := immutablePolicyCache[immutableHash]
	
	if !ok {
		return nil, fmt.Errorf("Inconsistent caches: policy with immutable hash %s does not exist", immutableHash), outPerms
	}
	parentChain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(issuerEntry.immutableIssuerHash, rootChain, inPerms, cachePerms / 2)
	ghost outPerms = tmp

	if err != nil {
		return nil, err, outPerms
	}
	if parentChain == nil {
		assert false // Cannot get here since err == nil ==> res != nil in recursive postcondoition 
		return nil, nil, outPerms
	}

	unfold ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache))

	if len(issuerEntry.policyHashes) == 0 {
		assert false // Cannot get here since issuerEntry.policyHashes > 0 according to invariant
		return nil, fmt.Errorf("Inconsistent caches: no policy certificate corresponding to immutable hash %s exists", immutableHash), outPerms
	}
	var minMaxTimestampPcEntry *common.PolicyCertificate
	var minMaxTimestamp time.Time

	ghost oldImmutablePolicyCache := dict(immutablePolicyCache)
	ghost oldPolicyCache := dict(policyCache)
	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)
	invariant cachePerms > 0
	invariant cachePerms == old(cachePerms)
	invariant outPerms > 0
	invariant outPerms <= old(outPerms)
	invariant old(outPerms) <= inPerms
	invariant acc(policyDnsNameCache, cachePerms)
	invariant acc(immutablePolicyCache, cachePerms)
	invariant acc(policyCache, cachePerms)
	invariant dict(policyCache) == oldPolicyCache
	invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
	invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
	invariant i > 0 ==> acc(minMaxTimestampPcEntry, outPerms)
	invariant i > 0 ==> minMaxTimestampPcEntry.Domain() in policyDnsNameCache
	invariant i > 0 ==> cache_SPCTs(minMaxTimestampPcEntry.SPCTs, outPerms)
	invariant immutableHash in domain(dict(immutablePolicyCache))
	invariant issuerEntry == dict(immutablePolicyCache)[immutableHash]
    invariant forall str string :: {dict(immutablePolicyCache)[str]} str in domain(dict(immutablePolicyCache)) ==> acc(dict(immutablePolicyCache)[str], cachePerms)
	invariant forall str string :: {dict(immutablePolicyCache)[str]} str in domain(dict(immutablePolicyCache)) && str != immutableHash ==> ImmutablePolicyCachePermissions_policyHashes(dict(immutablePolicyCache)[str].policyHashes, str, dict(policyCache))
	invariant let hashes := issuerEntry.policyHashes in (len(hashes) > 0 && forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k]) && hashes[k] in domain(policyCache))
	invariant PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
	invariant parentChain != nil
	invariant (rootChain != nil || issuerEntry.immutableIssuerHash != base64.StdEncoding.EncodeToString(nil)) && rootChain != parentChain ==> acc_policyCertificateChain(parentChain, dict(policyDnsNameCache), outPerms)
	invariant rootChain == nil && issuerEntry.immutableIssuerHash == base64.StdEncoding.EncodeToString(nil) ==> acc(parentChain) && len(parentChain.PolicyCertificates) == 0
	invariant rootChain != nil ==> acc_policyCertificateChain(rootChain, dict(policyDnsNameCache), outPerms)
	invariant 0 <= i && i <= len(issuerEntry.policyHashes)
	for i := 0; i < len(issuerEntry.policyHashes); i += 1 {
		unfold PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
		ghost origOutPerms := outPerms
		
		hash := issuerEntry.policyHashes[i]
	//for i, hash := range issuerEntry.policyHashes {

		pcEntry, ok := policyCache[hash]
		if !ok {
			fold ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache))
			fold PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
			assert false // cannot get here invariant says it must be present in policyCache
			return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", hash), outPerms
		}
		
		unfold cache_policyHashes_policy(pcEntry.policy, hash, dict(policyDnsNameCache), outPerms)

		tLatest := pcEntry.policy.TimeStamp
		unfold cache_SPCTs(pcEntry.policy.SPCTs, outPerms)
		invariant cachePerms == old(cachePerms)
		invariant outPerms > 0
		invariant outPerms == old(outPerms)
		invariant acc(policyDnsNameCache, cachePerms)
		invariant acc(immutablePolicyCache, cachePerms)
		invariant acc(policyCache, cachePerms)
		invariant dict(policyCache) == oldPolicyCache
		invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
		invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
		invariant pcEntry == policyCache[hash]
		invariant pcEntry == old(pcEntry)
		invariant forall str string :: {dict(policyCache)[str]} str in domain(dict(policyCache)) ==> 
			acc(dict(policyCache)[str]) && 
			dict(policyCache)[str].immutableHash != base64.StdEncoding.EncodeToString(nil) && 
			dict(policyCache)[str].immutableHash in domain(dict(immutablePolicyCache))
		invariant forall str string :: {dict(policyCache)[str]} str in domain(dict(policyCache)) && str != hash ==> cache_policyHashes_policy(dict(policyCache)[str].policy, str, dict(policyDnsNameCache), outPerms)
		invariant acc(pcEntry.policy, outPerms)
		invariant pcEntry.policy.Domain() in policyDnsNameCache
		invariant forall l int :: {&pcEntry.policy.SPCTs[l]} 0 <= l && l < len(pcEntry.policy.SPCTs) ==> cache_SPCT(&pcEntry.policy.SPCTs[l], l, outPerms)
		invariant 0 <= j && j <= len(pcEntry.policy.SPCTs)
		//for _, spct := range pcEntry.policy.SPCTs {
		for j := 0; j < len(pcEntry.policy.SPCTs); j++ {
			unfold cache_SPCT(&pcEntry.policy.SPCTs[j], j, outPerms)
			spct := pcEntry.policy.SPCTs[j]
			tLatest = maxTime(tLatest, spct.AddedTS)
			fold cache_SPCT(&pcEntry.policy.SPCTs[j], j, outPerms)
		}
		if i == 0 || tLatest.Before(minMaxTimestamp) {
			minMaxTimestamp = tLatest
			ghost outPerms = outPerms / 2
			minMaxTimestampPcEntry = pcEntry.policy


			ghost if (rootChain != nil) {
				refoldChain(rootChain, dict(policyDnsNameCache),origOutPerms, outPerms)
			}
			ghost if ((rootChain != nil || issuerEntry.immutableIssuerHash != base64.StdEncoding.EncodeToString(nil)) && rootChain != parentChain) {
				refoldChain(parentChain, dict(policyDnsNameCache),origOutPerms, outPerms)
			}

			ghost refoldForAllSPCTs(minMaxTimestampPcEntry.SPCTs, origOutPerms, outPerms)
			fold cache_SPCTs(minMaxTimestampPcEntry.SPCTs, outPerms)
			ghost refoldPoliciesExceptFor(dict(policyCache), hash, dict(policyDnsNameCache), origOutPerms, outPerms)
		} 
		fold cache_SPCTs(pcEntry.policy.SPCTs, outPerms)
		fold cache_policyHashes_policy(pcEntry.policy, hash, dict(policyDnsNameCache), outPerms)
		fold PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
	}
	fold ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache))
	ghost if (rootChain != nil || issuerEntry.immutableIssuerHash != base64.StdEncoding.EncodeToString(nil)) {
		unfold acc_policyCertificateChain(parentChain, dict(policyDnsNameCache), outPerms)
	}
	isDomainRootCertificate := minMaxTimestampPcEntry.Domain() != "" && (len(parentChain.PolicyCertificates) == 0 || (unfolding acc_inj_chainCertificate(parentChain.PolicyCertificates[0], len(parentChain.PolicyCertificates) - 1, dict(policyDnsNameCache), outPerms, parentChain) in parentChain.PolicyCertificates[0].Domain()) == "")
	isDomainRootCertificateParent := minMaxTimestampPcEntry.Domain() == ""
	domainRootIssuanceTimestamp := parentChain.DomainRootIssuanceTimestamp
	if isDomainRootCertificate {
		domainRootIssuanceTimestamp = minMaxTimestampPcEntry.TimeStamp
	}
	domainRootMinMaxTimestamp := parentChain.DomainRootMinMaxTimestamp
	if isDomainRootCertificate {
		domainRootMinMaxTimestamp = minMaxTimestamp
	}

	rootAndIntermediateLatestMinMaxTimestamp := parentChain.RootAndIntermediateLatestMinMaxTimestamp
	if isDomainRootCertificateParent {
		rootAndIntermediateLatestMinMaxTimestamp = maxTime(rootAndIntermediateLatestMinMaxTimestamp, minMaxTimestamp)
	}
	domainLatestMinMaxTimestamp := parentChain.DomainLatestMinMaxTimestamp
	if !isDomainRootCertificate && !isDomainRootCertificateParent {
		domainLatestMinMaxTimestamp = maxTime(domainLatestMinMaxTimestamp, minMaxTimestamp)
	}

	resChain := &PolicyCertificateChain{
		PolicyCertificates:                       append(perm(1/2), []*common.PolicyCertificate{minMaxTimestampPcEntry}, parentChain.PolicyCertificates...),
		DomainRootIssuanceTimestamp:              domainRootIssuanceTimestamp,
		DomainRootMinMaxTimestamp:                domainRootMinMaxTimestamp,
		RootAndIntermediateLatestMinMaxTimestamp: rootAndIntermediateLatestMinMaxTimestamp,
		DomainLatestMinMaxTimestamp:              domainLatestMinMaxTimestamp,
		// todo: find trust level
		TrustLevel: max(parentChain.TrustLevel, 0),
	}
	fold acc_inj_chainCertificate(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 1, dict(policyDnsNameCache), outPerms / 2, resChain) // / 2 because in the next loop we might fold certificateChain for two chains (if rootChain == parentChain) -> improves simplicity if we just / 2 in any case.

	ghost 
	invariant cachePerms > 0
	invariant cachePerms == old(cachePerms)
	invariant acc(policyDnsNameCache, cachePerms)
	invariant acc(immutablePolicyCache, cachePerms)
	invariant acc(policyCache, cachePerms)
	invariant dict(policyCache) == oldPolicyCache
	invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
	invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
	//invariant forall str string :: {dict(immutablePolicyCache)[str]} str in domain(dict(immutablePolicyCache)) ==> acc(dict(immutablePolicyCache)[str], cachePerms) && ImmutablePolicyCachePermissions_policyHashes(dict(immutablePolicyCache)[str].policyHashes, str, dict(policyCache))
	invariant PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
	invariant acc(resChain)
	invariant acc(parentChain)
	invariant rootChain == parentChain ==> len(rootChain.PolicyCertificates) > 0
	invariant parentChain != resChain
	invariant 1 <= i && i <= len(resChain.PolicyCertificates)
	invariant len(resChain.PolicyCertificates) == len(parentChain.PolicyCertificates) + 1
	invariant forall k int :: {&resChain.PolicyCertificates[k]} 0 <= k && k < len(resChain.PolicyCertificates) ==> acc(&resChain.PolicyCertificates[k])
	invariant forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < len(parentChain.PolicyCertificates) ==> acc(&parentChain.PolicyCertificates[k])
	invariant forall k int :: {&resChain.PolicyCertificates[k]} 1 <= k && k < len(resChain.PolicyCertificates) ==> resChain.PolicyCertificates[k] == parentChain.PolicyCertificates[k-1]
	invariant forall k int :: {&resChain.PolicyCertificates[k]} 0 <= k && k < i ==> acc_inj_chainCertificate(resChain.PolicyCertificates[k], len(resChain.PolicyCertificates) - k - 1, dict(policyDnsNameCache), outPerms / 2, resChain)
	invariant forall k int :: {&parentChain.PolicyCertificates[k]} i - 1 <= k && k < len(parentChain.PolicyCertificates) ==> acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1,dict(policyDnsNameCache), outPerms, parentChain)
	invariant unfolding acc_inj_chainCertificate(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache), outPerms / 2, resChain) in resChain.PolicyCertificates[0].Domain() in policyDnsNameCache
	invariant rootChain == parentChain ==> forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < i - 1 ==> acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, dict(policyDnsNameCache),outPerms / 2, parentChain)
	invariant rootChain == parentChain && i == 1 ==> unfolding acc_inj_chainCertificate(parentChain.PolicyCertificates[0], len(parentChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache),outPerms, parentChain) in parentChain.PolicyCertificates[0].Domain() in policyDnsNameCache
	invariant rootChain == parentChain && i > 1 ==> unfolding acc_inj_chainCertificate(parentChain.PolicyCertificates[0], len(parentChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache),outPerms / 2, parentChain) in parentChain.PolicyCertificates[0].Domain() in policyDnsNameCache
	invariant rootChain != parentChain && rootChain != nil ==> acc_policyCertificateChain(rootChain, dict(policyDnsNameCache), outPerms)
	invariant outPerms == old(outPerms)
	invariant inPerms == old(inPerms)
	decreases len(resChain.PolicyCertificates) - i
	for i := 1; i < len(resChain.PolicyCertificates); i++ {
		k := i - 1
		unfold acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, dict(policyDnsNameCache),outPerms, parentChain)
		if rootChain == parentChain {
			fold acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, dict(policyDnsNameCache),outPerms / 2, parentChain)
		}
		fold acc_inj_chainCertificate(resChain.PolicyCertificates[i], len(resChain.PolicyCertificates) - i - 1, dict(policyDnsNameCache),outPerms / 2, resChain)
	}
	ghost if rootChain == parentChain {
		fold acc_policyCertificateChain(parentChain, dict(policyDnsNameCache), outPerms / 2)
	} else if rootChain != nil {
		refoldChain(rootChain, dict(policyDnsNameCache), outPerms, outPerms / 2)
	}
	fold acc_policyCertificateChain(resChain, dict(policyDnsNameCache), outPerms / 2)
	ghost refoldPolicyCache(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms, outPerms / 2)
	return resChain, nil, outPerms / 2
}

// TODO Go's builtin max is not available, so here is a declaration just for this use case
ensures x < y ==> res == y && x >= y ==> res == x
func max(x, y int) (res int)

requires inPerms > 0
requires acc(policyCache, 1/4)
requires acc(policyDnsNameCache, 1/4)
requires acc(immutablePolicyCache, 1/4)
requires PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), inPerms)
requires ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
requires PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
ensures outPerms > 0
ensures outPerms <= inPerms
ensures acc(policyCache, 1/4)
ensures acc(policyDnsNameCache, 1/4)
ensures acc(immutablePolicyCache, 1/4)
ensures PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
ensures ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
ensures PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
ensures domainVar in domain(policyDnsNameCache) ==> !(res == nil && err == nil)
ensures (domainVar in domain(policyDnsNameCache) && res != nil && err == nil) ==> (forall k int :: {res[k]} 0 <= k && k < len(res) ==> (acc(&res[k]) && res[k] != nil && acc_inj_policyCertificateChain(res[k], k, dict(policyDnsNameCache), outPerms)))
func findPolicyCertificateChainsForE2LD(domainVar string, ghost inPerms perm) (res []*PolicyCertificateChain, err error, ghost outPerms perm) {
	leafHashes, ok := policyDnsNameCache[domainVar]
	ghost outPerms = inPerms
	if !ok {
		return nil, nil, outPerms
	}
	unfold PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
	unfold acc_leafHashes(leafHashes)
	chains := []*PolicyCertificateChain{}

	ghost oldPolicyCache := dict(policyCache)
	ghost oldImmutablePolicyCache := dict(immutablePolicyCache)
	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)

	invariant acc(policyCache, 1/4)
	invariant acc(policyDnsNameCache, 1/4)
	invariant acc(immutablePolicyCache, 1/4)
	invariant dict(policyCache) == oldPolicyCache
	invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
	invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
	invariant chains != nil
	invariant outPerms <= old(outPerms)
	invariant outPerms > 0
	invariant outPerms <= inPerms
	invariant forall k int :: 0 <= k && k < len(leafHashes) ==> acc(&leafHashes[k], _)
	invariant forall str string :: {dict(policyDnsNameCache)[str]} str in domain(dict(policyDnsNameCache)) && str != domainVar ==> acc_leafHashes(dict(policyDnsNameCache)[str])
	invariant ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
	invariant PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
	invariant forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> (acc(&chains[k]) && chains[k] != nil && acc_inj_policyCertificateChain(chains[k], k, dict(policyDnsNameCache), outPerms))
	invariant 0 <= i && i <= len(leafHashes)
	for i := 0; i < len(leafHashes); i++ {
		leafHash := leafHashes[i]
	//for _, leafHash := range leafHashes {
		leafCacheEntry, ok := policyCache[leafHash]
		if !ok {
			fold acc_leafHashes(leafHashes)
			fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
			return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", leafHash), outPerms
		}
		unfold PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
		fold PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms) // invariant that leafCacheEntry.immutableHash is not nil lies in here -> needed so we get back chain predicate
		unfold ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
		chain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(unfolding PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms) in leafCacheEntry.immutableHash, nil, outPerms, 1/8)
		fold ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
		ghost refoldChains(chains, dict(policyDnsNameCache), outPerms, tmp)
		ghost outPerms = tmp
		if err != nil {
			fold acc_leafHashes(leafHashes)
			fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
			return chains, fmt.Errorf("Failed to get policy cert chain with latest timestamp: %s", err), outPerms
		}

		fold acc_inj_policyCertificateChain(chain, len(chains), dict(policyDnsNameCache), outPerms)
		chains = append(perm(1/2), chains, chain)
	}
	fold acc_leafHashes(leafHashes)
	fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
	return chains, nil, outPerms
}


requires inPerms > 0
requires domainRootPolicyCertificateChain != nil
requires acc(immutablePolicyCache, 1/4)
requires acc(policyCache, 1/4)
requires acc(policyDnsNameCache, 1/4)
requires PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), inPerms)
requires ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
requires PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
requires acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache), inPerms)
ensures outPerms > 0
ensures outPerms <= inPerms
ensures acc(immutablePolicyCache, 1/4)
ensures acc(policyCache, 1/4)
ensures acc(policyDnsNameCache, 1/4)
ensures PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
ensures ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
ensures PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
ensures err == nil ==> acc_policyCertificateChain(res, dict(policyDnsNameCache), outPerms)
func findPolicyCertificateChainForDomain(domainVar string, domainRootPolicyCertificateChain *PolicyCertificateChain, ghost inPerms perm) (res *PolicyCertificateChain, err error, ghost outPerms perm) {
	ghost outPerms = inPerms
	unfold acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache), outPerms)
	e2ld := unfolding acc_inj_chainCertificate(domainRootPolicyCertificateChain.PolicyCertificates[0], len(domainRootPolicyCertificateChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache), outPerms, domainRootPolicyCertificateChain) in domainRootPolicyCertificateChain.PolicyCertificates[0].Domain()
	fold acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache), outPerms)
	subdomainsString, found := strings.CutSuffix(domainVar, e2ld)
	if !found {
		return nil, fmt.Errorf("Domain is not a subdomain of e2ld"), outPerms
	}
	subdomains := strings.Split(subdomainsString, ".")
	currentDomain := e2ld

	ghost oldPolicyCache := dict(policyCache)
	ghost oldImmutablePolicyCache := dict(immutablePolicyCache)
	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)

	var finalChain *PolicyCertificateChain
	invariant acc(policyCache, 1/4)
	invariant acc(policyDnsNameCache, 1/4)
	invariant acc(immutablePolicyCache, 1/4)
	invariant dict(policyCache) == oldPolicyCache
	invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
	invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
	invariant ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
	invariant PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
	invariant PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
	invariant outPerms == old(outPerms)
	invariant outPerms > 0
	invariant outPerms <= inPerms
	invariant domainRootPolicyCertificateChain != nil
	invariant acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache), outPerms)
	invariant acc(subdomains)
	invariant i == 0 ==> currentDomain == e2ld
	invariant i == 0 ==> currentDomain in policyDnsNameCache
	invariant i > 0 ==> finalChain != nil
	invariant finalChain != nil && finalChain != domainRootPolicyCertificateChain ==> acc_policyCertificateChain(finalChain, dict(policyDnsNameCache), outPerms)
	invariant 0 <= i && i <= len(subdomains)
	for i := 0; i < len(subdomains); i++ {
		// skip last item since it is an empty string
		if i > 0 {
			currentDomain = subdomains[len(subdomains)-1-i] + "." + currentDomain
		}
		leafHashes, ok := policyDnsNameCache[currentDomain]
		assert i == 0 ==> ok
		if ok {
			unfold PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
			invariant acc(policyCache, 1/4)
			invariant acc(policyDnsNameCache, 1/4)
			invariant acc(immutablePolicyCache, 1/4)
			invariant dict(policyCache) == oldPolicyCache
			invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
			invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
			invariant ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
			invariant PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
			invariant forall str string :: {policyDnsNameCache[str]} str in domain(policyDnsNameCache) ==> let leafHashes, ok := policyDnsNameCache[str] in len(leafHashes) > 0 && acc_leafHashes(leafHashes) && len(leafHashes) > 0
			invariant outPerms == old(outPerms)
			invariant outPerms > 0
			invariant outPerms <= inPerms
			invariant domainRootPolicyCertificateChain != nil
			invariant acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache), outPerms)
			invariant acc(subdomains)
			invariant currentDomain in policyDnsNameCache
			invariant let lH, ok := policyDnsNameCache[currentDomain] in lH === leafHashes
			invariant j > 0 ==> finalChain != nil
			invariant finalChain != nil && finalChain != domainRootPolicyCertificateChain ==> acc_policyCertificateChain(finalChain, dict(policyDnsNameCache), outPerms)
			invariant 0 <= j && j <= len(leafHashes)
			for j := 0; j < len(leafHashes); j++ {
				unfold acc_leafHashes(leafHashes)
				leafHash := leafHashes[j]
				leafCacheEntry, ok := policyCache[leafHash]
				if !ok {
					fold acc_leafHashes(leafHashes)
					fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
					return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", leafHash), outPerms
				}
				unfold PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
				fold PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
				unfold ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
				chain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(unfolding PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms) in leafCacheEntry.immutableHash, domainRootPolicyCertificateChain, outPerms, 1/8)
				fold ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)

				ghost if finalChain != nil && finalChain != domainRootPolicyCertificateChain {
					refoldChain(finalChain, dict(policyDnsNameCache), outPerms, tmp)
				}
				ghost outPerms = tmp
				if err != nil {
					fold acc_leafHashes(leafHashes)
					fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
					return nil, fmt.Errorf("Failed to get policy cert chain with latest timestamp: %s", err), outPerms
				}

				fold acc_leafHashes(leafHashes)
				if chain != nil {
					if finalChain == nil || (unfolding acc_policyCertificateChain(chain, dict(policyDnsNameCache), outPerms) in (chain.DomainLatestMinMaxTimestamp)).After(unfolding acc_policyCertificateChain(finalChain, dict(policyDnsNameCache), outPerms) in finalChain.DomainLatestMinMaxTimestamp) {
						finalChain = chain
					}
				}
			}
			fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache))
		}
	}
	return finalChain, nil, outPerms
}

preserves len(chains) > 0
requires acc(policyDnsNameCache, 1/4)
requires forall k int :: {chains[k]} 0 <= k && k < len(chains) ==> (acc(&chains[k]) && chains[k] != nil && acc_inj_policyCertificateChain(chains[k], k, dict(policyDnsNameCache), perms))
ensures acc(policyDnsNameCache, 1/4)
ensures err == nil  ==> res != nil && acc_policyCertificateChain(res, dict(policyDnsNameCache), perms)
func getNewestChain(chains []*PolicyCertificateChain, ghost perms perm) (res *PolicyCertificateChain, err error) {
	// TODO: handle cool-off period

	var newestChain *PolicyCertificateChain

	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)
	invariant acc(policyDnsNameCache, 1/4)
	invariant oldPolicyDnsNameCache === dict(policyDnsNameCache)
	invariant 0 <= i && i <= len(chains)
	invariant forall k int :: k >= i && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil && acc_inj_policyCertificateChain(chains[k], k, dict(policyDnsNameCache), perms)
	invariant i > 0 ==> newestChain != nil && acc_policyCertificateChain(newestChain, dict(policyDnsNameCache), perms)
	//for i, chain := range chains {
	for i := 0; i < len(chains); i++ {
		chain := chains[i]
		unfold acc_inj_policyCertificateChain(chain, i, dict(policyDnsNameCache), perms)
		if i == 0 {
			newestChain = chain
		} else {
			chainTime := unfolding acc_policyCertificateChain(chain, dict(policyDnsNameCache), perms) in chain.DomainRootIssuanceTimestamp
			newestChainTime := unfolding acc_policyCertificateChain(newestChain, dict(policyDnsNameCache), perms) in newestChain.DomainRootIssuanceTimestamp
			if chainTime.After(newestChainTime) {
		//if i == 0 || chain.DomainRootIssuanceTimestamp.After(newestChain.DomainRootIssuanceTimestamp) {
				newestChain = chain
			}
		}
	}
	return newestChain, nil
}

// remove trailing dots from domain names
func normalizeDomain(d string) string {
	dNormalized := d
	if strings.HasSuffix(dNormalized, ".") {
		dNormalized = dNormalized[:len(dNormalized)-1]
	}
	return dNormalized
}

// checks whether d1 is a subdomain of d2
// assumes that both inputs are valid domains without any wildcards
func isSameOrSubdomain(d1, d2 string) bool {
	d2Suffix := normalizeDomain(d2)
	if len(d2Suffix) > 0 {
		d2Suffix = "." + d2Suffix
	}
	return d1 == d2 || strings.HasSuffix(d1, d2Suffix)
}

ghost 
requires perms > 0
requires oldLen >= 0
requires oldLen + len(chainPolicies) == len(trustInfoPolicies)
requires forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
requires forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(&chainPolicies[k])
requires forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < len(trustInfoPolicies) ==> trustInfoPolicies[k] == chainPolicies[k - oldLen]
requires forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, perms, chain)
requires forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < oldLen ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
ensures forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
ensures forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(&chainPolicies[k])
ensures forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < len(trustInfoPolicies) ==> trustInfoPolicies[k] == chainPolicies[k - oldLen]
ensures forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < oldLen ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
ensures forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, perms / 2, chain)
ensures forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < len(trustInfoPolicies) ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms / 2)
decreases 
func halveTrustInfoApplicableChainPermissions(trustInfoPolicies []*common.PolicyCertificate, chainPolicies []*common.PolicyCertificate, chain *PolicyCertificateChain, oldLen int, policyDnsNameCache dict[string][]string, perms perm) {
	invariant perms > 0
	invariant oldLen >= 0
	invariant oldLen + len(chainPolicies) == len(trustInfoPolicies)
	invariant oldLen <= i && i <= len(trustInfoPolicies)
	invariant forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
	invariant forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(&chainPolicies[k])
	invariant forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < len(trustInfoPolicies) ==> trustInfoPolicies[k] == chainPolicies[k - oldLen]
	invariant forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < oldLen ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
	invariant forall k int :: {&chainPolicies[k]} i - oldLen <= k && k < len(chainPolicies) ==> acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, perms, chain)
	invariant forall k int :: {&chainPolicies[k]} 0 <= k && k < i - oldLen ==> acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, perms / 2, chain)
	invariant forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < i ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms / 2)
	decreases len(trustInfoPolicies) - i
	for i := oldLen; i < len(trustInfoPolicies); i++ {
		unfold acc_inj_chainCertificate(chainPolicies[i - oldLen], len(chainPolicies) - (i - oldLen) - 1, policyDnsNameCache, perms, chain)
		fold acc_inj_chainCertificate(chainPolicies[i - oldLen], len(chainPolicies) - (i - oldLen) - 1, policyDnsNameCache, perms / 2, chain)
		fold acc_inj_trustInfo_policy(trustInfoPolicies[i], i, perms / 2)
	}
}

ghost
decreases
requires perms > 0
requires oldLen >= 0
requires oldLen + len(chainPolicies) == len(trustInfoPolicies)
requires forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
requires forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(&chainPolicies[k])
requires forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < len(trustInfoPolicies) ==> trustInfoPolicies[k] == chainPolicies[k - oldLen]
requires forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < oldLen ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
requires forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, perms / 2, chain)
requires forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < len(trustInfoPolicies) ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms / 2)
ensures forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
ensures forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
func combiningTrustInfoApplicableChainPermissions(trustInfoPolicies []*common.PolicyCertificate, chainPolicies []*common.PolicyCertificate, chain *PolicyCertificateChain, oldLen int, policyDnsNameCache dict[string][]string, perms perm) {
	invariant perms > 0
	invariant oldLen >= 0
	invariant oldLen + len(chainPolicies) == len(trustInfoPolicies)
	invariant oldLen <= i && i <= len(trustInfoPolicies)
	invariant forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < len(trustInfoPolicies) ==> acc(&trustInfoPolicies[k])
	invariant forall k int :: {&chainPolicies[k]} 0 <= k && k < len(chainPolicies) ==> acc(&chainPolicies[k])
	invariant forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < len(trustInfoPolicies) ==> trustInfoPolicies[k] == chainPolicies[k - oldLen]
	invariant forall k int :: {&trustInfoPolicies[k]} 0 <= k && k < oldLen ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
	invariant forall k int :: {&trustInfoPolicies[k]} i <= k && k < len(trustInfoPolicies) ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms / 2)
	invariant forall k int :: {&chainPolicies[k]} i - oldLen <= k && k < len(chainPolicies) ==> acc_inj_chainCertificate(chainPolicies[k], len(chainPolicies) - k - 1, policyDnsNameCache, perms / 2, chain)
	invariant forall k int :: {&trustInfoPolicies[k]} oldLen <= k && k < i ==> acc_inj_trustInfo_policy(trustInfoPolicies[k], k, perms)
	decreases len(trustInfoPolicies) - i
	for i := oldLen; i < len(trustInfoPolicies); i++ {
		unfold acc_inj_chainCertificate(chainPolicies[i - oldLen], len(chainPolicies) - (i - oldLen) - 1, policyDnsNameCache, perms / 2, chain)
		unfold acc_inj_trustInfo_policy(trustInfoPolicies[i], i, perms / 2)
		fold acc_inj_trustInfo_policy(trustInfoPolicies[i], i, perms)
	}
}

// Evaluate whether connection should be allowed according to
// policy mode based on current state of the cache.
requires inPerms > 0
requires acc(immutablePolicyCache, 1/2)
requires acc(policyCache, 1/2)
requires acc(policyDnsNameCache, 1/2)
requires PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), inPerms)
requires ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
requires PolicyDnsNameCachePermissions(dict(policyDnsNameCache)) 
requires acc_trustInfo(trustInfo, dict(policyDnsNameCache), inPerms)
ensures outPerms > 0
ensures outPerms <= inPerms
ensures acc(immutablePolicyCache, 1/2)
ensures acc(policyCache, 1/2)
ensures acc(policyDnsNameCache, 1/2)
ensures PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache), outPerms)
ensures ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache), 1/4)
ensures PolicyDnsNameCachePermissions(dict(policyDnsNameCache)) 
ensures acc_trustInfo(trustInfo, dict(policyDnsNameCache), outPerms)
func VerifyPolicy(trustInfo *PolicyTrustInfo, ghost inPerms perm) (err error, ghost outPerms perm) {

	ghost policyCacheView := dict(policyCache)
	ghost immutablePolicyCacheView := dict(immutablePolicyCache)
	ghost policyDnsNameCacheView := dict(policyDnsNameCache)

	unfold acc_trustInfo(trustInfo, policyDnsNameCacheView, inPerms)

	// Gobra can only have one return element for pure functions
	/*e2ld, err := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName)
	if err != nil {
		return fmt.Errorf("Failed to get E2LD of %s: %s", trustInfo.DNSName, err)
	}*/

	e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName)

	// TODO (cyrill): ensure that enough map servers are queried and that enough full responses were returned

	// debug
	// fmt.Printf("root cert subject: %s\n", trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1].Subject.ToRDNSequence().String())
	// get all certificate chains for the E2LD
	e2ldChains, err, tmp := findPolicyCertificateChainsForE2LD(e2ld, inPerms)
	ghost outPerms = tmp
	ghost refoldTrustInfoPolicy(trustInfo.PolicyChain, inPerms, outPerms)
	if err != nil {
		fold acc_trustInfo(trustInfo, policyDnsNameCacheView, outPerms)
		return err, outPerms
	}
	fmt.Printf("domain root chains: %+v\n", e2ldChains)
	if len(e2ldChains) == 0 {
		// no applicable policy certificates exist
		trustInfo.EvaluationResult = 1
		fold acc_trustInfo(trustInfo, policyDnsNameCacheView, outPerms)
		return nil, outPerms
	}
	// find newest chain for e2ld	
	newestE2ldChain, err := getNewestChain(e2ldChains, outPerms)
	if err != nil {
		fold acc_trustInfo(trustInfo, policyDnsNameCacheView, outPerms)
		return err, outPerms
	}
	// find newest chain containing e2ld
	applicableChain, err, tmp := findPolicyCertificateChainForDomain(trustInfo.DNSName, newestE2ldChain, outPerms)
	ghost refoldTrustInfoPolicy(trustInfo.PolicyChain, outPerms, tmp)
	ghost outPerms = tmp
	if err != nil {
		fold acc_trustInfo(trustInfo, policyDnsNameCacheView, outPerms)
		return err, outPerms
	}
	fmt.Printf("applicable chain: %+v\n", applicableChain)
	unfold acc_policyCertificateChain(applicableChain, policyDnsNameCacheView, outPerms)

	ghost oldLen := len(trustInfo.PolicyChain)
	trustInfo.PolicyChain = append(perm(1/2), trustInfo.PolicyChain, applicableChain.PolicyCertificates...) 
	ghost halveTrustInfoApplicableChainPermissions(trustInfo.PolicyChain, applicableChain.PolicyCertificates, applicableChain, oldLen, policyDnsNameCacheView, outPerms)

	// extract policies and validate certificate based on extracted policies
	rootCertificate := trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1].Subject.ToRDNSequence().String()

	invariant acc(policyCache, 1/2)
	invariant acc(policyDnsNameCache, 1/2)
	invariant acc(immutablePolicyCache, 1/2)
	invariant policyCacheView == dict(policyCache)
	invariant immutablePolicyCacheView == dict(immutablePolicyCache)
	invariant policyDnsNameCacheView == dict(policyDnsNameCache)
	invariant PolicyCachePermissions(policyCacheView, immutablePolicyCacheView, policyDnsNameCacheView, outPerms)
	invariant ImmutablePolicyCachePermissions(immutablePolicyCacheView, policyCacheView, 1/4)
	invariant PolicyDnsNameCachePermissions(policyDnsNameCacheView) 
	invariant acc(trustInfo)
	invariant forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(&trustInfo.ConflictingPolicyAttributes[k])
	invariant forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc_inj_trustInfo_conflictingPolicyAttributes_attr(trustInfo.ConflictingPolicyAttributes[k], k)
	invariant forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(&trustInfo.PolicyChain[k])
	invariant len(trustInfo.CertificateChain) > 0 && acc(&trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) && acc(trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1])
	invariant let e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName) in (e2ld in domain(policyDnsNameCacheView))
	invariant outPerms <= inPerms
	invariant outPerms == old(outPerms)
	invariant outPerms > 0
	invariant acc(applicableChain)
	invariant len(applicableChain.PolicyCertificates) >= 1
	invariant (forall l int :: {&applicableChain.PolicyCertificates[l]} 0 <= l && l < len(applicableChain.PolicyCertificates) ==> acc(&applicableChain.PolicyCertificates[l]))
	invariant (forall l int :: {&applicableChain.PolicyCertificates[l]} 0 <= l && l < len(applicableChain.PolicyCertificates) ==> acc_inj_chainCertificate(applicableChain.PolicyCertificates[l], len(applicableChain.PolicyCertificates) - l - 1, policyDnsNameCacheView, outPerms / 2, applicableChain))
	invariant oldLen >= 0
	invariant oldLen + len(applicableChain.PolicyCertificates) == len(trustInfo.PolicyChain)
	invariant forall k int :: {&trustInfo.PolicyChain[k]} oldLen <= k && k < len(trustInfo.PolicyChain) ==> trustInfo.PolicyChain[k] == applicableChain.PolicyCertificates[k - oldLen]
	invariant forall k int :: {&trustInfo.PolicyChain[k]} oldLen <= k && k < len(trustInfo.PolicyChain) ==> acc_inj_trustInfo_policy(trustInfo.PolicyChain[k], k, outPerms / 2)
	invariant forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < oldLen ==> acc_inj_trustInfo_policy(trustInfo.PolicyChain[k], k, outPerms)
	invariant 0 <= idx && idx <= len(applicableChain.PolicyCertificates)
	decreases len(applicableChain.PolicyCertificates) - idx//i0
	//for idx, policyCert := range applicableChain.PolicyCertificates with i0 {
	for idx := 0; idx < len(applicableChain.PolicyCertificates); idx++ {
		policyCert := applicableChain.PolicyCertificates[idx]
		unfold acc_inj_chainCertificate(applicableChain.PolicyCertificates[idx], len(applicableChain.PolicyCertificates) - idx - 1, policyDnsNameCacheView, outPerms / 2, applicableChain)

		err := policyCert.PolicyAttributes.ValidateAttributes()

		if err != nil {
			dom := policyCert.Domain()
			fold acc_inj_chainCertificate(applicableChain.PolicyCertificates[idx], len(applicableChain.PolicyCertificates) - idx - 1, policyDnsNameCacheView, outPerms / 2, applicableChain)
			ghost combiningTrustInfoApplicableChainPermissions(trustInfo.PolicyChain, applicableChain.PolicyCertificates, applicableChain, oldLen, policyDnsNameCacheView, outPerms)
			fold acc_trustInfo(trustInfo, policyDnsNameCacheView, outPerms)
			return fmt.Errorf("Failed to validate attributes for domain %s: %s", dom, err), outPerms
		}

		// check for the status of the subdomains
		policyCertDomain := normalizeDomain(policyCert.Domain())
		domainValidity := policyCert.PolicyAttributes.CheckDomainValidity(policyCertDomain, trustInfo.DNSName)
		// check if the domain should not consider policies
		if idx == 0 && domainValidity == common.PolicyAttributeDomainExcluded {
			trustInfo.DomainExcluded = true
		}

		// check if the domain is allowed or not
		if domainValidity == common.PolicyAttributeDomainAllowed {
			// no conflicting domain attribute
		} else if domainValidity == common.PolicyAttributeDomainDisallowed {
			attr := &common.PolicyAttributes{AllowedSubdomains: policyCert.PolicyAttributes.AllowedSubdomains, DisallowedSubdomains: policyCert.PolicyAttributes.DisallowedSubdomains}
			confAttr := &ConflictingPolicyAttribute{Domain: policyCert.Domain(), Attribute: attr}
			trustInfo.ConflictingPolicyAttributes = append(perm(1/2), trustInfo.ConflictingPolicyAttributes, confAttr)
			fold acc_inj_trustInfo_conflictingPolicyAttributes_attr(confAttr, len(trustInfo.ConflictingPolicyAttributes) - 1)
		}

		// check for allowed CAs
		if len(policyCert.PolicyAttributes.AllowedCAs) > 0 {
			fmt.Printf("Checking if %s is contained in %+v\n", rootCertificate, policyCert.PolicyAttributes.AllowedCAs)
			if !Contains(policyCert.PolicyAttributes.AllowedCAs, rootCertificate) { // changed from !slices.Contains
				attr := &common.PolicyAttributes{AllowedCAs: policyCert.PolicyAttributes.AllowedCAs}
				confAttr := &ConflictingPolicyAttribute{Domain: policyCert.Domain(), Attribute: attr}
				trustInfo.ConflictingPolicyAttributes = append(perm(1/2), trustInfo.ConflictingPolicyAttributes, confAttr)
				fold acc_inj_trustInfo_conflictingPolicyAttributes_attr(confAttr, len(trustInfo.ConflictingPolicyAttributes) - 1)
			}
		}

		fold acc_inj_chainCertificate(applicableChain.PolicyCertificates[idx], len(applicableChain.PolicyCertificates) - idx - 1, policyDnsNameCacheView, outPerms / 2, applicableChain)

	}
	ghost combiningTrustInfoApplicableChainPermissions(trustInfo.PolicyChain, applicableChain.PolicyCertificates, applicableChain, oldLen, policyDnsNameCacheView, outPerms)
	fold acc_trustInfo(trustInfo, policyDnsNameCacheView, outPerms)
	return nil, outPerms
}

// Gobra does not support Generics. Thus, we can not use the Contains function from slices. 
// The import from slices was also removed for this reason!
func Contains(s []string, e string) bool