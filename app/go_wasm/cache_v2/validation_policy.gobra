package cache_v2

import (
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
	"time"
	
	"fpki/pkg/common"
	"net/publicsuffix"
)

// create new PolicyTrustInfo
func NewPolicyTrustInfo(dnsName string, certificateChain []*x509.Certificate) *PolicyTrustInfo {
	policyTrustInfo := &PolicyTrustInfo{
		DNSName:                     dnsName,
		CertificateChain:            certificateChain,
		PolicyChain:                 nil,
		ConflictingPolicyAttributes: nil,
		PolicyChainTrustLevel:       0,
		EvaluationResult:            0,
		MaxValidity:                 time.Unix(0, 0),
		DomainExcluded:              false,
	}
	return policyTrustInfo
}

type PolicyTrustPreference struct {
	// PCA public keys
	PCAPublicKey string

	// TODO (cyrill): also implement setting the trust preferences for specific policy certificate
	// // Immutable hash of PCA certificate
	// PCAImmutableHash string

	// map CA set to TrustLevel
	TrustLevel int
}

type ConflictingPolicyAttribute struct {
	Domain    string
	Attribute *common.PolicyAttributes
}

type PolicyTrustInfo struct {
	// domain name used in the connection
	DNSName string

	// certificate chain received during the connection establishment
	CertificateChain []*x509.Certificate

	// CA set ID's and example subjects, and trust level of the
	// cached certificate chains that led to a failed
	// validation
	// (might be useful to construct error messages)

	// json encoded policy certifcates
	PolicyChain                 []*common.PolicyCertificate
	ConflictingPolicyAttributes []*ConflictingPolicyAttribute
	PolicyChainTrustLevel       int `default:"0"`

	// result of legacy validation
	// a value of 1 indicates that validation
	// was passed.
	// a value != 1 indicates failed validation
	EvaluationResult int `default:"0"`

	// timestamp indicating how long this
	// legacy validation outcome can be cached
	MaxValidity time.Time

	// true if the most specific policy (i.e., highest number of subdomains) added DNSName (or a
	// parent of DNSName) as an excluded subdomain where no policy attributes are applied
	DomainExcluded bool
}

// maps a domain name to a set of legacy trust preferences
// to be used to compute certificate chain trust levels
// TODO Unused? Only breaks verification because of assigning to global variables, but we never read from it
// var policyTrustPreferences = map[string][]*PolicyTrustPreference{}

type PolicyCertificateChain struct {
	PolicyCertificates                       []*common.PolicyCertificate
	DomainRootIssuanceTimestamp              time.Time
	DomainRootMinMaxTimestamp                time.Time
	RootAndIntermediateLatestMinMaxTimestamp time.Time
	DomainLatestMinMaxTimestamp              time.Time
	TrustLevel                               int

	// DisseminationTime  time.Time
}

//preserves acc(certificatePermission, _)
preserves forall k int :: {pcChain.PolicyCertificates[k]} 0 <= k && k < len(pcChain.PolicyCertificates) ==> (acc(&pcChain.PolicyCertificates[k]) && (forall l int :: {pcChain.PolicyCertificates[l]} 0 <= l && l < len(pcChain.PolicyCertificates) && k != l ==> &pcChain.PolicyCertificates[k] != &pcChain.PolicyCertificates[l]) && acc(pcChain.PolicyCertificates[k], _/*getCertificatePerm(pcChain.PolicyCertificates[k])*/))// && acc(&pcChain.PolicyCertificates[k].PolicyAttributes))
func (pcChain PolicyCertificateChain) String() string {
	str := fmt.Sprintf("<PolicyCertificateChain len=%d", len(pcChain.PolicyCertificates))
	str += fmt.Sprintf(", DomainRootIssuanceTimestamp=%v", pcChain.DomainRootIssuanceTimestamp)
	str += fmt.Sprintf(", DomainRootMinMaxTimestamp=%v", pcChain.DomainRootMinMaxTimestamp)
	str += fmt.Sprintf(", RootAndIntermediateLatestMinMaxTimestamp=%v", pcChain.RootAndIntermediateLatestMinMaxTimestamp)
	str += ", certs="
	//invariant acc(certificatePermission, _)
	invariant forall k int :: /*{pcChain.PolicyCertificates[k]}*/ 0 <= k && k < len(pcChain.PolicyCertificates) ==> (acc(&pcChain.PolicyCertificates[k]) && (forall l int :: {pcChain.PolicyCertificates[l]} 0 <= l && l < len(pcChain.PolicyCertificates) && k != l ==> &pcChain.PolicyCertificates[k] != &pcChain.PolicyCertificates[l]) && acc(pcChain.PolicyCertificates[k], _/*getCertificatePerm(pcChain.PolicyCertificates[k])*/))// && acc(&pcChain.PolicyCertificates[k].PolicyAttributes))
	invariant 0 <= i && i <= len(pcChain.PolicyCertificates)
	//for _, pc := range pcChain.PolicyCertificates {
	for i := 0; i < len(pcChain.PolicyCertificates); i++ {
		pc := pcChain.PolicyCertificates[i]
		if pc == nil {
			str += "nil, "
			continue
		}
		attributes, err := json.Marshal(pc.PolicyAttributes)
		if err != nil {
			break
		}
		pcStr := fmt.Sprintf("<Policy domain=%s, attributes=%s, #SPCTs=%d, hash=%s, immHash=%s >", pc.Domain(), attributes, len(pc.SPCTs), getPolicyHash(pc), getImmutablePolicyHash(pc))
		// pcStr, err := common.ToJSON(pc)
		// if err != nil {
		// break
		// }
		str += fmt.Sprintf("%s, ", pcStr)
	}
	return str + ">"
}

//preserves acc(certificatePermission, _)
ensures acc(res) && len(res.PolicyCertificates) == 0
func NewPolicyCertificateChain() (res *PolicyCertificateChain) { // Named return variable for postcondition
	return &PolicyCertificateChain{
		PolicyCertificates:                       []*common.PolicyCertificate{},
		DomainRootIssuanceTimestamp:              time.Unix(0, 0),
		DomainRootMinMaxTimestamp:                time.Unix(0, 0),
		RootAndIntermediateLatestMinMaxTimestamp: time.Unix(0, 0),
		DomainLatestMinMaxTimestamp:              time.Unix(0, 0),
		TrustLevel:                               0,
	}
}

// initialize legacyTrustPreferences with a config
// TODO Unused? Only breaks verification because of assigning to global variables, but we never read from it
/* func InitializePolicyTrustPreferences(configMap map[string]interface{}) {
	policyTrustPreferences = map[string][]*PolicyTrustPreference{}

	// parse policy CA sets
	pcaSetsMap := map[string][]string{}
	pcaSets := configMap["policy-ca-sets"].(map[string]interface{})
	for pcaSetID, values := range pcaSets {
		pcaSetsMap[pcaSetID] = []string{}
		v := values.(map[string]interface{})
		for _, value := range v["pcas"].([]interface{}) {
			pcaSetsMap[pcaSetID] = append(pcaSetsMap[pcaSetID], value.(string))
		}
	}

	// parse policy CAs
	pcasPublicKeyMap := map[string]string{}
	pcas := configMap["policy-cas"].(map[string]interface{})
	for pcaID, values := range pcas {
		v := values.(map[string]interface{})
		pcasPublicKeyMap[pcaID] = v["publickey"].(string)
	}

	// get trust level map
	trustLevelMap := configMap["trust-levels"].(map[string]interface{})

	// parse policy trust preferences
	policyTrustPreferencesJSON := configMap["policy-trust-preference"].(map[string]interface{})
	for domainVar, entry := range policyTrustPreferencesJSON {
		domainTrustPreferences := []*PolicyTrustPreference{}
		objects := entry.([]interface{})
		for _, object := range objects {
			objectMap := object.(map[string]interface{})
			trustLevel := int(trustLevelMap[objectMap["level"].(string)].(float64))
			pcaSetID := objectMap["policy-ca-set"].(string)
			for _, pca := range pcaSetsMap[pcaSetID] {
				policyTrustPreference := &PolicyTrustPreference{
					PCAPublicKey: pcasPublicKeyMap[pca],
					TrustLevel:   trustLevel,
				}
				domainTrustPreferences = append(domainTrustPreferences, policyTrustPreference)
			}
		}
		policyTrustPreferences[domainVar] = domainTrustPreferences
	}
} */

// own predicate required for this because otherwise gobra may not mark errors but rather not terminate upon verification errors when cache_SPCTs is unfolded
pred cache_SPCT(spct *common.SignedPolicyCertificateTimestamp, l int, policyPerm perm) {
	policyPerm > 0 && acc(spct, policyPerm)
}

pred cache_SPCTs(arr []common.SignedPolicyCertificateTimestamp, policyPerm perm) {
	policyPerm > 0 && forall l int :: {&arr[l]} 0 <= l && l < len(arr) ==> /*acc(&arr[l], policyPerm)//*/cache_SPCT(&arr[l], l, policyPerm)
}

pred cache_policyHashes_policy(policy *common.PolicyCertificate, hash string, policyPerm perm) {
	policyPerm > 0 && acc(policy, policyPerm) && cache_SPCTs(policy.SPCTs, policyPerm) // TODO wildcard does not work with acc(policy) - can we still make it work regardless? (with wildcard we cannot prove that we have acc to pcEntry after folding it back up - probably because we give away some permissions)
}

pred cache_policyHashes(hashes []string, perms perm) {
	acc(policyCache, _) &&
	(forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k]) && acc(policyCache[hashes[k]])) &&
	(forall k int :: {&hashes[k]} /*{cache_policyHashes_policy(policyCache[hashes[k]].policy, hashes[k], getCertificatePerm(policyCache[hashes[k]].policy))}*/ 0 <= k && k < len(hashes) ==> cache_policyHashes_policy(policyCache[hashes[k]].policy, hashes[k], perms))	
}

pred cache_ImmutableHash(immutableHash string/*, depth int*/, perms perm) {
	acc(immutablePolicyCache, _) &&
	(immutableHash in domain(immutablePolicyCache) ==> (
	acc(immutablePolicyCache[immutableHash]) && 
	len(immutablePolicyCache[immutableHash].policyHashes) > 0 &&
	cache_policyHashes(immutablePolicyCache[immutableHash].policyHashes, perms) &&
	cache_ImmutableHash(immutablePolicyCache[immutableHash].immutableIssuerHash/*, depth + 1*/, perms)))
}

ghost 
decreases
requires cache_policyHashes(hashes, inPerms)
ensures cache_policyHashes(hashes, outPerms)
func refoldPolicyHashesForWeakerPerms(hashes []string, inPerms perm, outPerms perm)

ghost 
decreases
requires acc(policyCache, _)
requires forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) && k != i ==> acc(&hashes[k], 1/2) && acc(policyCache[hashes[k]], 1/2) // using 1/2 s.t. we know that the locations don't change and we suddenly point to the same as i -> would lead to folding issues/termination issues of gobra
requires forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) && k != i ==> cache_policyHashes_policy(policyCache[hashes[k]].policy, hashes[k], inPerms)
//requires acc(policyCache[hash]) && cache_policyHashes_policy(policyCache[hash].policy, hash, outPerms)
ensures acc(policyCache, _)
ensures forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) && k != i ==> acc(&hashes[k], 1/2) && acc(policyCache[hashes[k]], 1/2) 
ensures forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) && k != i ==> cache_policyHashes_policy(policyCache[hashes[k]].policy, hashes[k], outPerms)
//ensures acc(policyCache[hash]) && cache_policyHashes_policy(policyCache[hash].policy, hash, outPerms)
func refoldPolicyHashesPolicyExceptForOneForWeakerPerms(hashes []string, i int, inPerms perm, outPerms perm)

ghost 
decreases
requires acc_policyCertificateChain(chain, inPerms)
ensures acc_policyCertificateChain(chain, outPerms)
func refoldChain(chain *PolicyCertificateChain, inPerms perm, outPerms perm)

ghost
decreases
requires cache_ImmutableHash(hash/*, depth*/, inPerms)
ensures cache_ImmutableHash(hash/*, depth*/, outPerms)
func refoldImmutableHash(hash string/*, depth int*/, inPerms perm, outPerms perm)

ghost
decreases
requires forall l int :: {&spcts[l]} 0 <= l && l < len(spcts) ==> cache_SPCT(&spcts[l], l, inPerms)
ensures forall l int :: {&spcts[l]} 0 <= l && l < len(spcts) ==> cache_SPCT(&spcts[l], l, outPerms)
ensures outPerms == inPerms / 2 ==> forall l int :: {&spcts[l]} 0 <= l && l < len(spcts) ==> cache_SPCT(&spcts[l], l, outPerms) // so we can use the predicate inside of another cache_SPCTs
func refoldForAllSPCTs(spcts []common.SignedPolicyCertificateTimestamp, inPerms perm, outPerms perm)

ghost 
decreases
requires acc(policyCache, _)
requires acc(immutablePolicyCache, _)
requires forall str string :: {str in domain(policyCache)} {policyCache[str]} str in domain(policyCache) && str != hash ==>  (acc(policyCache[str], _) && policyCache[str].immutableHash != base64.StdEncoding.EncodeToString(nil) && policyCache[str].immutableHash in domain(immutablePolicyCache) && cache_ImmutableHash(policyCache[str].immutableHash/*, 0*/, inPerms))
ensures acc(policyCache, _)
ensures acc(immutablePolicyCache, _)
ensures forall str string :: {str in domain(policyCache)} {policyCache[str]} str in domain(policyCache) && str != hash ==>  (acc(policyCache[str], _) && policyCache[str].immutableHash != base64.StdEncoding.EncodeToString(nil) && policyCache[str].immutableHash in domain(immutablePolicyCache) && cache_ImmutableHash(policyCache[str].immutableHash/*, 0*/, outPerms))
func refoldPolicyCacheExceptFor(hash string, inPerms perm, outPerms perm)

ghost 
decreases
requires forall k int :: {chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil
requires forall k int :: {chains[k]} 0 <= k && k < len(chains) ==> acc_inj_policyCertificateChain(chains[k], k, inPerms)
ensures forall k int :: {chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil
ensures forall k int :: {chains[k]} 0 <= k && k < len(chains) ==> acc_inj_policyCertificateChain(chains[k], k, outPerms)
func refoldChains(chains []*PolicyCertificateChain, inPerms perm, outPerms perm)

// ASSUMPTIONS MADE TO VERIFY: AT LEAST ONE POLICY HASH IN immutablePolicyCache[immutableHash]; NO POLICY POINTER IS NIL; INJECTIVITY: NO POLICY IS USED TWICE

// find the policy certificate chain which has the latest max timestamp in the set [issuance, SPCT time 1, SPCT time 2, ...].
// The second parameter is an optional root chain (e.g., domain root cert to root cert) that must be used. If nil is passed as an argument, any chain is accepted. If no acceptable chain can be generated, nil is returned.
requires inPerms > 0
requires rootChain != nil ==>  acc_policyCertificateChain(rootChain, inPerms)
requires cache_ImmutableHash(immutableHash/*, depth*/, inPerms)
ensures outPerms > 0
ensures outPerms <= inPerms
ensures err == nil ==> res != nil
ensures rootChain != nil ==> acc_policyCertificateChain(rootChain, outPerms)
ensures cache_ImmutableHash(immutableHash/*, depth*/, outPerms)
ensures (rootChain != nil || immutableHash != base64.StdEncoding.EncodeToString(nil)) && res != rootChain && err == nil ==>  acc_policyCertificateChain(res, outPerms)
ensures rootChain == nil && err == nil && immutableHash == base64.StdEncoding.EncodeToString(nil) ==> acc(res) && len(res.PolicyCertificates) == 0
func getPolicyCertificateChainWithLatestTimestamp(immutableHash string, rootChain *PolicyCertificateChain/*, ghost depth int*/, ghost inPerms perm) (res *PolicyCertificateChain, err error, ghost outPerms perm) { // added names to reference return variables in postcondition 
	ghost outPerms = inPerms
	if rootChain != nil {
		if immutableHash == unfolding acc_policyCertificateChain(rootChain, outPerms) in unfolding acc_inj_chainCertificate(rootChain.PolicyCertificates[0], len(rootChain.PolicyCertificates) - 0 - 1, outPerms, rootChain) in getImmutablePolicyHash(rootChain.PolicyCertificates[0]) {
			return rootChain, nil, outPerms
		}
	} else {
		if immutableHash == base64.StdEncoding.EncodeToString(nil) {
			return NewPolicyCertificateChain(), nil, outPerms
		}
	}

	unfold cache_ImmutableHash(immutableHash/*, depth*/, inPerms)
	issuerEntry, ok := immutablePolicyCache[immutableHash]
	if !ok {
		fold cache_ImmutableHash(immutableHash/*, depth*/, outPerms)
		return nil, fmt.Errorf("Inconsistent caches: policy with immutable hash %s does not exist", immutableHash), outPerms
	}
	parentChain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(issuerEntry.immutableIssuerHash, rootChain/*, depth + 1*/, inPerms)
	ghost outPerms = tmp

	ghost refoldPolicyHashesForWeakerPerms(issuerEntry.policyHashes, inPerms, outPerms)

	if err != nil {
		fold cache_ImmutableHash(immutableHash/*, depth*/, outPerms)
		return nil, err, outPerms
	}
	if parentChain == nil {
		assert false // Cannot get here since err == nil ==> res != nil in recursive postcondoition 
		fold cache_ImmutableHash(immutableHash/*, depth*/, outPerms)
		return nil, nil, outPerms
	}
	// find certificate with latest hash
	// select first certificate with the given immutable hash
	if len(issuerEntry.policyHashes) == 0 {
		fold cache_ImmutableHash(immutableHash/*, depth*/, outPerms)
		assert false // Cannot get here since issuerEntry.policyHashes > 0 according to predicate
		return nil, fmt.Errorf("Inconsistent caches: no policy certificate corresponding to immutable hash %s exists", immutableHash), outPerms
	}

	var minMaxTimestampPcEntry *common.PolicyCertificate
	var minMaxTimestamp time.Time
	
	invariant outPerms > 0
	invariant outPerms <= old(outPerms)
	invariant old(outPerms) <= inPerms
	invariant i > 0 ==> acc(minMaxTimestampPcEntry, outPerms)
	invariant i > 0 ==> cache_SPCTs(minMaxTimestampPcEntry.SPCTs, outPerms)
	invariant acc(immutablePolicyCache, _)
	invariant issuerEntry == immutablePolicyCache[immutableHash]
	invariant acc(issuerEntry)
	invariant len(issuerEntry.policyHashes) > 0
	invariant cache_policyHashes(issuerEntry.policyHashes, outPerms)
	invariant cache_ImmutableHash(issuerEntry.immutableIssuerHash/*, depth + 1*/, outPerms)
	invariant parentChain != nil
	invariant (rootChain != nil || issuerEntry.immutableIssuerHash != base64.StdEncoding.EncodeToString(nil)) && rootChain != parentChain ==> acc_policyCertificateChain(parentChain, outPerms)
	invariant rootChain == nil && issuerEntry.immutableIssuerHash == base64.StdEncoding.EncodeToString(nil) ==> acc(parentChain) && len(parentChain.PolicyCertificates) == 0
	invariant rootChain != nil ==> acc_policyCertificateChain(rootChain, outPerms)
	invariant 0 <= i && i <= len(issuerEntry.policyHashes)
	for i := 0; i < len(issuerEntry.policyHashes); i += 1 {
		unfold cache_policyHashes(issuerEntry.policyHashes, outPerms)
		ghost origOutPerms := outPerms
		hash := issuerEntry.policyHashes[i]
	//for i, hash := range issuerEntry.policyHashes {
		pcEntry, ok := policyCache[hash]
		if !ok {
			fold cache_policyHashes(issuerEntry.policyHashes, outPerms)
			fold cache_ImmutableHash(immutableHash/*, depth*/, outPerms)
			assert false // cannot get here predicate says it must be present in policyCache
			return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", hash), outPerms
		}
		unfold cache_policyHashes_policy(pcEntry.policy, hash, outPerms)
		tLatest := pcEntry.policy.TimeStamp
		unfold cache_SPCTs(pcEntry.policy.SPCTs, outPerms)
		invariant outPerms > 0
		invariant outPerms == old(outPerms)
		invariant acc(policyCache, _)
		invariant pcEntry == policyCache[hash]
		invariant pcEntry == old(pcEntry)
		invariant acc(pcEntry)
		invariant acc(pcEntry.policy, outPerms)
		invariant forall l int :: {&pcEntry.policy.SPCTs[l]} 0 <= l && l < len(pcEntry.policy.SPCTs) ==> cache_SPCT(&pcEntry.policy.SPCTs[l], l, outPerms) //acc(&pcEntry.policy.SPCTs[l], outPerms)
		invariant 0 <= j && j <= len(pcEntry.policy.SPCTs)
		//for _, spct := range pcEntry.policy.SPCTs {
		for j := 0; j < len(pcEntry.policy.SPCTs); j++ {
			unfold cache_SPCT(&pcEntry.policy.SPCTs[j], j, outPerms)
			spct := pcEntry.policy.SPCTs[j]
			tLatest = maxTime(tLatest, spct.AddedTS)
			fold cache_SPCT(&pcEntry.policy.SPCTs[j], j, outPerms)
		}
		if i == 0 || tLatest.Before(minMaxTimestamp) {
			minMaxTimestamp = tLatest
			ghost outPerms = outPerms / 2
			minMaxTimestampPcEntry = pcEntry.policy

			ghost if (rootChain != nil) {
				refoldChain(rootChain, origOutPerms, outPerms)
			}
			ghost if ((rootChain != nil || issuerEntry.immutableIssuerHash != base64.StdEncoding.EncodeToString(nil)) && rootChain != parentChain) {
				refoldChain(parentChain, origOutPerms, outPerms)
			}
			ghost refoldForAllSPCTs(minMaxTimestampPcEntry.SPCTs, origOutPerms, outPerms)
			fold cache_SPCTs(minMaxTimestampPcEntry.SPCTs, outPerms)
			ghost refoldPolicyHashesPolicyExceptForOneForWeakerPerms(issuerEntry.policyHashes, i, origOutPerms, outPerms)
			ghost refoldImmutableHash(issuerEntry.immutableIssuerHash/*, depth + 1*/, origOutPerms, outPerms)

			/*ghost refoldImmutableHash(issuerEntry.immutableIssuerHash, depth + 1, origOutPerms, outPerms)
			fold cache_policyHashes_policy(pcEntry.policy, hash, outPerms)
			assert (forall k int :: {&issuerEntry.policyHashes[k]} 0 <= k && k < len(issuerEntry.policyHashes) ==> cache_policyHashes_policy(policyCache[issuerEntry.policyHashes[k]].policy, issuerEntry.policyHashes[k], outPerms))	
			assert (forall k int :: {&issuerEntry.policyHashes[k]} 0 <= k && k < len(issuerEntry.policyHashes) ==> acc(&issuerEntry.policyHashes[k]) && acc(policyCache[issuerEntry.policyHashes[k]]))
			assert acc(policyCache, _)
			fold cache_policyHashes(issuerEntry.policyHashes, outPerms)
			assert false*/
		} 
		fold cache_SPCTs(pcEntry.policy.SPCTs, outPerms)
		fold cache_policyHashes_policy(pcEntry.policy, hash, outPerms)
		fold cache_policyHashes(issuerEntry.policyHashes, outPerms)
	}
	ghost if (rootChain != nil || issuerEntry.immutableIssuerHash != base64.StdEncoding.EncodeToString(nil)) {
		unfold acc_policyCertificateChain(parentChain, outPerms)
	}
	isDomainRootCertificate := minMaxTimestampPcEntry.Domain() != "" && (len(parentChain.PolicyCertificates) == 0 || (unfolding acc_inj_chainCertificate(parentChain.PolicyCertificates[0], len(parentChain.PolicyCertificates) - 1, outPerms, parentChain) in parentChain.PolicyCertificates[0].Domain()) == "")
	isDomainRootCertificateParent := minMaxTimestampPcEntry.Domain() == ""

	domainRootIssuanceTimestamp := parentChain.DomainRootIssuanceTimestamp
	if isDomainRootCertificate {
		domainRootIssuanceTimestamp = minMaxTimestampPcEntry.TimeStamp
	}
	domainRootMinMaxTimestamp := parentChain.DomainRootMinMaxTimestamp
	if isDomainRootCertificate {
		domainRootMinMaxTimestamp = minMaxTimestamp
	}

	rootAndIntermediateLatestMinMaxTimestamp := parentChain.RootAndIntermediateLatestMinMaxTimestamp
	if isDomainRootCertificateParent {
		rootAndIntermediateLatestMinMaxTimestamp = maxTime(rootAndIntermediateLatestMinMaxTimestamp, minMaxTimestamp)
	}
	domainLatestMinMaxTimestamp := parentChain.DomainLatestMinMaxTimestamp
	if !isDomainRootCertificate && !isDomainRootCertificateParent {
		domainLatestMinMaxTimestamp = maxTime(domainLatestMinMaxTimestamp, minMaxTimestamp)
	}

	resChain := &PolicyCertificateChain{
		PolicyCertificates:                       append(perm(1/2), []*common.PolicyCertificate{minMaxTimestampPcEntry}, parentChain.PolicyCertificates...),
		DomainRootIssuanceTimestamp:              domainRootIssuanceTimestamp,
		DomainRootMinMaxTimestamp:                domainRootMinMaxTimestamp,
		RootAndIntermediateLatestMinMaxTimestamp: rootAndIntermediateLatestMinMaxTimestamp,
		DomainLatestMinMaxTimestamp:              domainLatestMinMaxTimestamp,
		// todo: find trust level
		TrustLevel: max(parentChain.TrustLevel, 0),
	}
	fold acc_inj_chainCertificate(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 1, outPerms / 2, resChain) // / 2 because in the next loop we might fold certificateChain for two chains (if rootChain == parentChain) -> improves simplicity if we just / 2 in any case.
/*
	assert false

	ghost
	invariant acc(certificatePermission)
	invariant acc(resChain)
	invariant acc(parentChain)
	invariant rootIsParent ==> rootChain == parentChain && len(rootChain.PolicyCertificates) > 0
	invariant parentChain != resChain
	invariant 1 <= i && i <= len(resChain.PolicyCertificates)
	invariant len(resChain.PolicyCertificates) == len(parentChain.PolicyCertificates) + 1
	invariant forall k int :: {&resChain.PolicyCertificates[k]} 0 <= k && k < len(resChain.PolicyCertificates) ==> acc(&resChain.PolicyCertificates[k])
	invariant forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < len(parentChain.PolicyCertificates) ==> acc(&parentChain.PolicyCertificates[k])
	invariant forall k int :: {&resChain.PolicyCertificates[k]} 1 <= k && k < len(resChain.PolicyCertificates) ==> resChain.PolicyCertificates[k] == parentChain.PolicyCertificates[k-1]
	invariant forall k int :: {acc_inj_chainCertificate(resChain.PolicyCertificates[k], k, getCertificatePerm(certificatePermission, resChain.PolicyCertificates[k]), resChain)} 0 <= k && k < i ==> resChain.PolicyCertificates[k] in certificatePermission && acc_inj_chainCertificate(resChain.PolicyCertificates[k], k, getCertificatePerm(certificatePermission, resChain.PolicyCertificates[k]), resChain)
	invariant forall k int :: {acc_inj_chainCertificate(parentChain.PolicyCertificates[k], k, getCertificatePerm(certificatePermission, parentChain.PolicyCertificates[k]), parentChain)} 0 <= k && k < len(parentChain.PolicyCertificates) && (i - 1 <= k || parentChain == rootChain) ==> parentChain.PolicyCertificates[k] in certificatePermission && acc_inj_chainCertificate(parentChain.PolicyCertificates[k], k, getCertificatePerm(certificatePermission, parentChain.PolicyCertificates[k]), parentChain)
	decreases len(resChain.PolicyCertificates) - i
	for i := 1; i < len(resChain.PolicyCertificates); i++ {
		unfold acc_inj_chainCertificate(parentChain.PolicyCertificates[i-1], i-1, getCertificatePerm(certificatePermission, parentChain.PolicyCertificates[i-1]), parentChain)
		if rootChain == parentChain {
			halveCertPermission(certificatePermission, resChain.PolicyCertificates[i])
			fold acc_inj_chainCertificate(resChain.PolicyCertificates[i], i-1, getCertificatePerm(certificatePermission, resChain.PolicyCertificates[i]), rootChain)
		}
		fold acc_inj_chainCertificate(resChain.PolicyCertificates[i], i, getCertificatePerm(certificatePermission, resChain.PolicyCertificates[i]), resChain)
	}*/
	//ghost if rootChain == parentChain {


	ghost 
	invariant acc(resChain)
	invariant acc(parentChain)
	invariant rootChain == parentChain ==> len(rootChain.PolicyCertificates) > 0
	invariant parentChain != resChain
	invariant 1 <= i && i <= len(resChain.PolicyCertificates)
	invariant len(resChain.PolicyCertificates) == len(parentChain.PolicyCertificates) + 1
	invariant forall k int :: {&resChain.PolicyCertificates[k]} 0 <= k && k < len(resChain.PolicyCertificates) ==> acc(&resChain.PolicyCertificates[k])
	invariant forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < len(parentChain.PolicyCertificates) ==> acc(&parentChain.PolicyCertificates[k])
	invariant forall k int :: {&resChain.PolicyCertificates[k]} 1 <= k && k < len(resChain.PolicyCertificates) ==> resChain.PolicyCertificates[k] == parentChain.PolicyCertificates[k-1]
	invariant forall k int :: {&resChain.PolicyCertificates[k]} /*{acc_inj_chainCertificate(resChain.PolicyCertificates[k], len(resChain.PolicyCertificates) - k - 1, outPerms / 2, resChain)}*/ 0 <= k && k < i ==> acc_inj_chainCertificate(resChain.PolicyCertificates[k], len(resChain.PolicyCertificates) - k - 1, outPerms / 2, resChain)
	invariant forall k int :: {&parentChain.PolicyCertificates[k]} /*{acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, outPerms, parentChain)}*/ i - 1 <= k && k < len(parentChain.PolicyCertificates) ==> acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, outPerms, parentChain)
	invariant rootChain == parentChain ==> forall k int :: {&parentChain.PolicyCertificates[k]} /*{acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, outPerms / 2, parentChain)}*/ 0 <= k && k < i - 1 ==> acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, outPerms / 2, parentChain)
	invariant rootChain != parentChain && rootChain != nil ==> acc_policyCertificateChain(rootChain, outPerms)
	invariant outPerms == old(outPerms)
	invariant inPerms == old(inPerms)
	decreases len(resChain.PolicyCertificates) - i
	for i := 1; i < len(resChain.PolicyCertificates); i++ {
		//assert forall k int :: {&parentChain.PolicyCertificates[k]} i - 1 <= k && k < len(parentChain.PolicyCertificates) ==> acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, outPerms, parentChain)
		//assert rootChain == parentChain ==> forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < i - 1 ==> acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, outPerms / 2, parentChain)
		k := i - 1
		unfold acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, outPerms, parentChain)
		if rootChain == parentChain {
			//assert forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k < i - 1 ==> acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, outPerms / 2, parentChain)
			fold acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, outPerms / 2, parentChain)
			//assert forall k int :: {&parentChain.PolicyCertificates[k]} 0 <= k && k <= i - 1 ==> acc_inj_chainCertificate(parentChain.PolicyCertificates[k], len(parentChain.PolicyCertificates) - k - 1, outPerms / 2, parentChain)
		}
		fold acc_inj_chainCertificate(resChain.PolicyCertificates[i], len(resChain.PolicyCertificates) - i - 1, outPerms / 2, resChain)
	}


	ghost if rootChain == parentChain {
		fold acc_policyCertificateChain(parentChain, outPerms / 2)
	} else if rootChain != nil {
		refoldChain(rootChain, outPerms, outPerms / 2)
	}
	//}
	fold acc_policyCertificateChain(resChain, outPerms / 2)
	ghost refoldPolicyHashesForWeakerPerms(issuerEntry.policyHashes, outPerms, outPerms / 2)
	ghost refoldImmutableHash(issuerEntry.immutableIssuerHash/*, depth + 1*/, outPerms, outPerms / 2)
	fold cache_ImmutableHash(immutableHash/*, depth*/, outPerms / 2)
	return resChain, nil, outPerms / 2
}

// TODO Go's builtin max is not available, so here is a declaration just for this use case
ensures x < y ==> res == y && x >= y ==> res == x
func max(x, y int) (res int)

/*
pred cert_ptr_eq_policyCache(policy *common.PolicyCertificate) {
	acc(policyCache, _) && (forall str string :: {str in policyCache} {policyCache[str]} str in policyCache ==> acc(policyCache[str], _)) && (exists str string :: str in policyCache && policyCache[str].policy == policy) // remember that all the policies in the chains come from the cache, s.t. we have full access to those if we know that we have full access to all policies in the cache
}*/

pred acc_inj_chainCertificate(cert *common.PolicyCertificate, i int, policyPerm perm, chain *PolicyCertificateChain) { // chain s.t. we do not have issues to folding the cert twice for two chains
	policyPerm > 0 && acc(cert, policyPerm)
}

pred acc_policyCertificateChain(chain *PolicyCertificateChain, perms perm) {
	acc(chain) &&
	len(chain.PolicyCertificates) >= 1 &&
	(forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc(&chain.PolicyCertificates[l])) &&
	(forall l int :: {&chain.PolicyCertificates[l]} /*{acc_inj_chainCertificate(chain.PolicyCertificates[l], len(chain.PolicyCertificates) - l - 1, perms, chain)}*/ 0 <= l && l < len(chain.PolicyCertificates) ==> acc_inj_chainCertificate(chain.PolicyCertificates[l], len(chain.PolicyCertificates) - l - 1, perms, chain))
	//acc(chain.PolicyCertificates[l], _))//acc(chain.PolicyCertificates[l], _/*getCertificatePerm(chain.PolicyCertificates[l])*/))
} 

pred acc_inj_policyCertificateChain(chain *PolicyCertificateChain, i int, perms perm) {
	acc_policyCertificateChain(chain, perms)
}

requires inPerms > 0
requires acc_policyCache(inPerms)
preserves acc(policyDnsNameCache, _) 
preserves domainVar in domain(policyDnsNameCache) ==> (let leafHashes, _ := policyDnsNameCache[domainVar] in acc_leafHashes(leafHashes))
ensures outPerms > 0
ensures acc_policyCache(outPerms)
ensures (domainVar in domain(policyDnsNameCache) && res != nil && err == nil) ==> (forall k int :: {res[k]} 0 <= k && k < len(res) ==> (acc(&res[k]) && res[k] != nil && acc_inj_policyCertificateChain(res[k], k, outPerms)))
func findPolicyCertificateChainsForE2LD(domainVar string, ghost inPerms perm) (res []*PolicyCertificateChain, err error, ghost outPerms perm) {
	leafHashes, ok := policyDnsNameCache[domainVar]
	ghost outPerms = inPerms
	if !ok {
		return nil, nil, outPerms
	}
	unfold acc_leafHashes(leafHashes)
	chains := []*PolicyCertificateChain{}
	invariant outPerms <= old(outPerms)
	invariant outPerms > 0
	invariant forall k int :: 0 <= k && k < len(leafHashes) ==> acc(&leafHashes[k], _)
	invariant acc_policyCache(outPerms)
	invariant forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> (acc(&chains[k]) && chains[k] != nil && acc_inj_policyCertificateChain(chains[k], k, outPerms))
	invariant 0 <= i && i <= len(leafHashes)
	for i := 0; i < len(leafHashes); i++ {
		leafHash := leafHashes[i]
	//for _, leafHash := range leafHashes {
		unfold acc_policyCache(outPerms)
		leafCacheEntry, ok := policyCache[leafHash]
		if !ok {
			fold acc_policyCache(outPerms)
			fold acc_leafHashes(leafHashes)
			return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", leafHash), outPerms
		}
		chain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(leafCacheEntry.immutableHash, nil/*, 0*/, outPerms)
		ghost refoldPolicyCacheExceptFor(leafHash, outPerms, tmp)
		fold acc_policyCache(tmp)
		ghost refoldChains(chains, outPerms, tmp)
		ghost outPerms = tmp
		//assume forall k int :: 0 <= k && k < len(chains) ==> chains[k] != chain // TODO REMOVE!!
		if err != nil {
			fold acc_leafHashes(leafHashes)
			return chains, fmt.Errorf("Failed to get policy cert chain with latest timestamp: %s", err), outPerms
		}
		fold acc_inj_policyCertificateChain(chain, len(chains), outPerms)
		chains = append(perm(1/2), chains, chain) // TODO Why do we need 1/2 here 
	}
	fold acc_leafHashes(leafHashes)
	return chains, nil, outPerms
}


requires inPerms > 0
requires domainRootPolicyCertificateChain != nil
requires acc_policyCertificateChain(domainRootPolicyCertificateChain, inPerms)
requires acc_policyCache(inPerms)
//preserves acc(certificatePermission, _)
preserves acc_policyDnsNameCache()
ensures outPerms > 0
ensures acc_policyCache(outPerms)
ensures err == nil ==> acc_policyCertificateChain(res, outPerms)
func findPolicyCertificateChainForDomain(domainVar string, domainRootPolicyCertificateChain *PolicyCertificateChain, ghost inPerms perm) (res *PolicyCertificateChain, err error, ghost outPerms perm) {
	ghost outPerms = inPerms
	unfold acc_policyCertificateChain(domainRootPolicyCertificateChain, outPerms)
	e2ld := unfolding acc_inj_chainCertificate(domainRootPolicyCertificateChain.PolicyCertificates[0], len(domainRootPolicyCertificateChain.PolicyCertificates) - 0 - 1, outPerms, domainRootPolicyCertificateChain) in domainRootPolicyCertificateChain.PolicyCertificates[0].Domain()
	fold acc_policyCertificateChain(domainRootPolicyCertificateChain, outPerms)
	subdomainsString, found := strings.CutSuffix(domainVar, e2ld)
	if !found {
		return nil, fmt.Errorf("Domain is not a subdomain of e2ld"), outPerms
	}
	subdomains := strings.Split(subdomainsString, ".")
	currentDomain := e2ld
	var finalChain *PolicyCertificateChain
	invariant outPerms == old(outPerms)
	invariant outPerms > 0
	invariant domainRootPolicyCertificateChain != nil
	invariant acc_policyCertificateChain(domainRootPolicyCertificateChain, outPerms)
	invariant acc_policyCache(outPerms)
	invariant acc(subdomains)
	invariant acc_policyDnsNameCache()
	invariant finalChain != nil && finalChain != domainRootPolicyCertificateChain ==> acc_policyCertificateChain(finalChain, outPerms)
	invariant 0 <= i && i <= len(subdomains)
	for i := 0; i < len(subdomains); i++ {
		// skip last item since it is an empty string
		if i > 0 {
			currentDomain = subdomains[len(subdomains)-1-i] + "." + currentDomain
		}
		unfold acc_policyDnsNameCache()
		leafHashes, ok := policyDnsNameCache[currentDomain]
		if ok {
			invariant outPerms == old(outPerms)
			invariant outPerms > 0
			invariant domainRootPolicyCertificateChain != nil
			invariant acc_policyCertificateChain(domainRootPolicyCertificateChain, outPerms)
			invariant acc_policyCache(outPerms)
			invariant acc(subdomains)
			invariant acc(policyDnsNameCache, _)
			invariant currentDomain in policyDnsNameCache
			invariant let lH, ok := policyDnsNameCache[currentDomain] in lH === leafHashes
			invariant forall str string :: {str in domain(policyDnsNameCache)} {policyDnsNameCache[str]} str in domain(policyDnsNameCache) ==> (let leafHashes, _ := policyDnsNameCache[str] in acc_leafHashes(leafHashes))
			invariant finalChain != nil && finalChain != domainRootPolicyCertificateChain ==> acc_policyCertificateChain(finalChain, outPerms)
			invariant 0 <= j && j <= len(leafHashes)
			for j := 0; j < len(leafHashes); j++ {
				unfold acc_leafHashes(leafHashes)
				leafHash := leafHashes[j]
				fold acc_leafHashes(leafHashes)
				unfold acc_policyCache(outPerms)
				leafCacheEntry, ok := policyCache[leafHash]
				if !ok {
					fold acc_policyDnsNameCache()
					fold acc_policyCache(outPerms)
					return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", leafHash), outPerms
				}
				chain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(leafCacheEntry.immutableHash, domainRootPolicyCertificateChain/*, 0*/, outPerms)
				ghost refoldPolicyCacheExceptFor(leafHash, outPerms, tmp)
				ghost if finalChain != nil && finalChain != domainRootPolicyCertificateChain {
					refoldChain(finalChain, outPerms, tmp)
				}
				ghost outPerms = tmp
				fold acc_policyCache(outPerms)
				if err != nil {
					fold acc_policyDnsNameCache()
					return nil, fmt.Errorf("Failed to get policy cert chain with latest timestamp: %s", err), outPerms
				}
				if chain != nil {
					if finalChain == nil {
						finalChain = chain
					} else {
						chainTimestamp := unfolding acc_policyCertificateChain(chain, outPerms) in chain.DomainLatestMinMaxTimestamp
						finalChainTimestamp := unfolding acc_policyCertificateChain(finalChain, outPerms) in finalChain.DomainLatestMinMaxTimestamp
						
						//if finalChain == nil || chain.DomainLatestMinMaxTimestamp.After(finalChain.DomainLatestMinMaxTimestamp) { TODO Was like this before but doesn't work because doesn't terminate with unfold/fold or unfolding here
						if chainTimestamp.After(finalChainTimestamp) {
							finalChain = chain
						}
					}
				}
			}
		}
		fold acc_policyDnsNameCache()
	}
	if finalChain == nil {
		return finalChain, fmt.Errorf("TODO: CHANGE THAT"), outPerms
	}
	return finalChain, nil, outPerms
}


//preserves acc(certificatePermission, _)
preserves len(chains) > 0
requires forall k int :: {chains[k]} 0 <= k && k < len(chains) ==> (acc(&chains[k]) && chains[k] != nil && acc_inj_policyCertificateChain(chains[k], k, perms))
ensures err == nil  ==> res != nil && acc_policyCertificateChain(res, perms)
func getNewestChain(chains []*PolicyCertificateChain, ghost perms perm) (res *PolicyCertificateChain, err error) {
	// TODO: handle cool-off period

	var newestChain *PolicyCertificateChain

	invariant 0 <= i && i <= len(chains)
	invariant forall k int :: k >= i && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil && acc_inj_policyCertificateChain(chains[k], k, perms)
	invariant i > 0 ==> newestChain != nil && acc_policyCertificateChain(newestChain, perms)
	//for i, chain := range chains {
	for i := 0; i < len(chains); i++ {
		chain := chains[i]
		unfold acc_inj_policyCertificateChain(chain, i, perms)
		if i == 0 {
			newestChain = chain
		} else {
			chainTime := unfolding acc_policyCertificateChain(chain, perms) in chain.DomainRootIssuanceTimestamp
			newestChainTime := unfolding acc_policyCertificateChain(newestChain, perms) in newestChain.DomainRootIssuanceTimestamp
			if chainTime.After(newestChainTime) {
		//if i == 0 || chain.DomainRootIssuanceTimestamp.After(newestChain.DomainRootIssuanceTimestamp) {
				newestChain = chain
			}
		}
	}
	return newestChain, nil
}

// remove trailing dots from domain names
func normalizeDomain(d string) string {
	dNormalized := d
	if strings.HasSuffix(dNormalized, ".") {
		dNormalized = dNormalized[:len(dNormalized)-1]
	}
	return dNormalized
}

// checks whether d1 is a subdomain of d2
// assumes that both inputs are valid domains without any wildcards
func isSameOrSubdomain(d1, d2 string) bool {
	d2Suffix := normalizeDomain(d2)
	if len(d2Suffix) > 0 {
		d2Suffix = "." + d2Suffix
	}
	return d1 == d2 || strings.HasSuffix(d1, d2Suffix)
}

pred acc_leafHashes(hashes []string) {
	forall k int :: {hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k], _)
}

/*
pred acc_trustInfo_policyChain(arr []*common.PolicyCertificate) {
	forall k int :: {arr[k]} 0 <= k && k < len(arr) ==> acc(&arr[k]) && acc(arr[k], _)
}
*/

ghost
requires forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> acc(&policies[k]) && acc_inj_trustInfo_policy(policies[k], k , inPerms)
ensures forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> acc(&policies[k]) && acc_inj_trustInfo_policy(policies[k], k , outPerms)
decreases
func refoldTrustInfoPolicy(policies []*common.PolicyCertificate, inPerms perm, outPerms perm)

pred acc_inj_trustInfo_policy(policy *common.PolicyCertificate, i int, perms perm) {
	perms > 0 && acc(policy, perms)
}

pred acc_inj_trustInfo_conflictingPolicyAttributes_attr(attr *ConflictingPolicyAttribute, i int) {
	acc(attr/*, _*/) && acc(attr.Attribute/*, _*/)
}

/*
pred acc_trustInfo_conflictingPolicyAttributes(arr []*ConflictingPolicyAttribute) {
	forall k int :: {&arr[k]} 0 <= k && k < len(arr) ==> acc(&arr[k]) &&
	forall k int :: {&arr[k]} /*{acc_inj_trustInfo_conflictingPolicyAttributes_attr(arr[k], k)}*//* 0 <= k && k < len(arr) ==> acc_inj_trustInfo_conflictingPolicyAttributes_attr(arr[k], k)
}*/

pred acc_policyDnsNameCache() {
	acc(policyDnsNameCache, _) && forall str string :: {str in domain(policyDnsNameCache)} {policyDnsNameCache[str]} str in domain(policyDnsNameCache) ==> (let leafHashes, _ := policyDnsNameCache[str] in acc_leafHashes(leafHashes))
}

pred acc_policyCache(perms perm) {
	acc(policyCache, _) && acc(immutablePolicyCache, _) && forall str string :: {str in domain(policyCache)} {policyCache[str]} str in domain(policyCache) ==> (acc(policyCache[str], _) && policyCache[str].immutableHash != base64.StdEncoding.EncodeToString(nil) /* This condition is needed so we know that we have at least one certificate in resulting chain */ && policyCache[str].immutableHash in domain(immutablePolicyCache) && cache_ImmutableHash(policyCache[str].immutableHash/*, 0*/, perms))
}

pred acc_trustInfo(trustInfo *PolicyTrustInfo, perms perm) {
	acc(trustInfo) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(&trustInfo.ConflictingPolicyAttributes[k])) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} /*{acc_inj_trustInfo_conflictingPolicyAttributes_attr(arr[k], k)}*/ 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc_inj_trustInfo_conflictingPolicyAttributes_attr(trustInfo.ConflictingPolicyAttributes[k], k)) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(&trustInfo.PolicyChain[k])) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc_inj_trustInfo_policy(trustInfo.PolicyChain[k], k, perms)) &&
	len(trustInfo.CertificateChain) > 0 && acc(&trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) && acc(trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) &&
	acc(policyDnsNameCache, _) && 
	let e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName) in (e2ld in domain(policyDnsNameCache))
}

// Evaluate whether connection should be allowed according to
// policy mode based on current state of the cache.
//preserves acc(certificatePermission, _)
requires inPerms > 0
requires acc_policyCache(inPerms)
requires acc_trustInfo(trustInfo, inPerms)
preserves acc(policyDnsNameCache, _) 
preserves acc_policyDnsNameCache()
ensures outPerms > 0
ensures acc_trustInfo(trustInfo, outPerms)
ensures acc_policyCache(outPerms)
//preserves (forall s string :: s in policyCache ==> acc(policyCache[s].policy, _)) // TODO can't we remove this since implicit by predicate
func VerifyPolicy(trustInfo *PolicyTrustInfo, ghost inPerms perm) (err error, ghost outPerms perm) {

	unfold acc_trustInfo(trustInfo, inPerms)

	// Gobra can only have one return element for pure functions
	/*e2ld, err := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName)
	if err != nil {
		return fmt.Errorf("Failed to get E2LD of %s: %s", trustInfo.DNSName, err)
	}*/

	e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName)

	// TODO (cyrill): ensure that enough map servers are queried and that enough full responses were returned

	// debug
	// fmt.Printf("root cert subject: %s\n", trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1].Subject.ToRDNSequence().String())
	// get all certificate chains for the E2LD
	unfold acc_policyDnsNameCache()
	e2ldChains, err, tmp := findPolicyCertificateChainsForE2LD(e2ld, inPerms)
	ghost outPerms = tmp
	fold acc_policyDnsNameCache()
	ghost refoldTrustInfoPolicy(trustInfo.PolicyChain, inPerms, outPerms)
	if err != nil {
		fold acc_trustInfo(trustInfo, outPerms)
		return err, outPerms
	}
	fmt.Printf("domain root chains: %+v\n", e2ldChains)
	if e2ldChains == nil || len(e2ldChains) == 0 { // TODO Why did this originally not include e2ldChains == nil? findPolicyCertificateChainsForE2LD might give back no error but no chain in first conditional -> checking for error doesn't suffice
	//if len(e2ldChains) == 0 {
		// no applicable policy certificates exist
		trustInfo.EvaluationResult = 1
		fold acc_trustInfo(trustInfo, outPerms)
		return nil, outPerms
	}
	// find newest chain for e2ld	
	newestE2ldChain, err := getNewestChain(e2ldChains, outPerms)
	if err != nil {
		fold acc_trustInfo(trustInfo, outPerms)
		return err, outPerms
	}
	//assert forall str string :: str in policyDnsNameCache ==> let leafHashes, _ := policyDnsNameCache[str] in (forall k int :: 0 <= k && k < len(leafHashes) ==> acc(policyCache[leafHashes[k]], _))
	// find newest chain containing e2ld
	//assert forall k int :: 0 <= k && k < len(newestE2ldChain.PolicyCertificates) ==> acc(newestE2ldChain) && acc(newestE2ldChain.PolicyCertificates[k], _)
	applicableChain, err, tmp := findPolicyCertificateChainForDomain(trustInfo.DNSName, newestE2ldChain, outPerms)
	ghost refoldTrustInfoPolicy(trustInfo.PolicyChain, outPerms, tmp)
	ghost outPerms = tmp
	if err != nil {
		fold acc_trustInfo(trustInfo, outPerms)
		return err, outPerms
	}
	fmt.Printf("applicable chain: %+v\n", applicableChain)
	unfold acc_policyCertificateChain(applicableChain, outPerms)
	//defer fold acc_policyCertificateChain(applicableChain, outPerms)

	certs := applicableChain.PolicyCertificates

	// extract policies and validate certificate based on extracted policies
	rootCertificate := trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1].Subject.ToRDNSequence().String()

	fold acc_trustInfo(trustInfo, outPerms)
	invariant acc(policyDnsNameCache, _) // ok
	invariant outPerms == old(outPerms)
	invariant outPerms > 0
	invariant acc_trustInfo(trustInfo, outPerms)
	invariant acc_policyDnsNameCache() // ok
	invariant acc_policyCache(outPerms) // ok

	//invariant applicableChain.PolicyCertificates !== trustInfo.PolicyChai


	invariant acc(applicableChain)

	invariant certs === applicableChain.PolicyCertificates
	invariant len(certs) >= 1
	invariant (forall l int :: {&certs[l]} 0 <= l && l < len(certs) ==> acc(&certs[l]))
	//invariant (forall l int :: {&applicableChain.PolicyCertificates[l]} {acc_inj_chainCertificate(applicableChain.PolicyCertificates[l], l)} 0 <= l && l < len(applicableChain.PolicyCertificates) ==> acc_inj_chainCertificate(applicableChain.PolicyCertificates[l], l)) 
	//invariant acc(certs)
	invariant (forall l int :: {&certs[l]} /*{acc_inj_chainCertificate(certs[l], len(certs) - l - 1, outPerms, applicableChain)}*/ 0 <= l && l < len(certs) ==> acc_inj_chainCertificate(certs[l], len(certs) - l - 1, outPerms, applicableChain))
	invariant 0 <= idx && idx <= len(certs) //ok
	decreases len(certs) - i0
	for idx, policyCert := range certs with i0 {
	//for idx := 0; idx < len(applicableChain.PolicyCertificates); idx++ {
		unfold acc_inj_chainCertificate(certs[i0], len(certs) - i0 - 1, outPerms, applicableChain)

		policyCert := applicableChain.PolicyCertificates[idx]

		err := policyCert.PolicyAttributes.ValidateAttributes()
		if err != nil {
			dom := policyCert.Domain()
			fold acc_inj_chainCertificate(certs[i0], len(certs) - i0 - 1, outPerms, applicableChain)
			return fmt.Errorf("Failed to validate attributes for domain %s: %s", dom, err), outPerms
			//return fmt.Errorf("Failed to validate attributes for domain %s: %s", policyCert.Domain(), err), outPerms
		}
		// check for the status of the subdomains
		policyCertDomain := normalizeDomain(policyCert.Domain())
		unfold acc_trustInfo(trustInfo, outPerms)
		domainValidity := policyCert.PolicyAttributes.CheckDomainValidity(policyCertDomain, trustInfo.DNSName)
		// check if the domain should not consider policies
		if idx == 0 && domainValidity == common.PolicyAttributeDomainExcluded {
			trustInfo.DomainExcluded = true
		}

		// check if the domain is allowed or not
		if domainValidity == common.PolicyAttributeDomainAllowed {
			// no conflicting domain attribute
		} else if domainValidity == common.PolicyAttributeDomainDisallowed {
			attr := &common.PolicyAttributes{AllowedSubdomains: policyCert.PolicyAttributes.AllowedSubdomains, DisallowedSubdomains: policyCert.PolicyAttributes.DisallowedSubdomains}
			confAttr := &ConflictingPolicyAttribute{Domain: policyCert.Domain(), Attribute: attr}
			trustInfo.ConflictingPolicyAttributes = append(perm(1/2), trustInfo.ConflictingPolicyAttributes, confAttr)
			fold acc_inj_trustInfo_conflictingPolicyAttributes_attr(confAttr, len(trustInfo.ConflictingPolicyAttributes) - 1)
		}
		// check for allowed CAs
		if len(policyCert.PolicyAttributes.AllowedCAs) > 0 {
			fmt.Printf("Checking if %s is contained in %+v\n", rootCertificate, policyCert.PolicyAttributes.AllowedCAs)
			if !Contains(policyCert.PolicyAttributes.AllowedCAs, rootCertificate) { // changed from !slices.Contains
				attr := &common.PolicyAttributes{AllowedCAs: policyCert.PolicyAttributes.AllowedCAs}
				confAttr := &ConflictingPolicyAttribute{Domain: policyCert.Domain(), Attribute: attr}
				trustInfo.ConflictingPolicyAttributes = append(perm(1/2), trustInfo.ConflictingPolicyAttributes, confAttr) // TODO why do we need 1/2 here?
				fold acc_inj_trustInfo_conflictingPolicyAttributes_attr(confAttr, len(trustInfo.ConflictingPolicyAttributes) - 1)
			}
		}
		fold acc_trustInfo(trustInfo, outPerms)
		fold acc_inj_chainCertificate(certs[i0], len(certs) - i0 - 1, outPerms, applicableChain)
	}
	unfold acc_trustInfo(trustInfo, outPerms)
	// TODO THIS WAS BEFORE LOOP BUT THEN WE HAVE PROBLEMS BECAUSE LOOP ALSO USES APPLICABLECHAIN -> FIX LATER!
	ghost oldLen := len(trustInfo.PolicyChain)
	trustInfo.PolicyChain = append(perm(1/2), trustInfo.PolicyChain, applicableChain.PolicyCertificates...) // TODO why do we need 1/2 here?
	ghost
	invariant oldLen >= 0
	invariant oldLen == old(oldLen)
	invariant acc(trustInfo)
	invariant oldLen <= i && i <= len(trustInfo.PolicyChain)
	invariant acc(applicableChain)
	invariant oldLen + len(applicableChain.PolicyCertificates) == len(trustInfo.PolicyChain)
	invariant forall k int :: {&applicableChain.PolicyCertificates[k]} 0 <= k && k < len(applicableChain.PolicyCertificates) ==> acc(&applicableChain.PolicyCertificates[k])
	invariant forall k int :: {&applicableChain.PolicyCertificates[k]} i - oldLen <= k && k < len(applicableChain.PolicyCertificates) ==> acc_inj_chainCertificate(applicableChain.PolicyCertificates[k], len(applicableChain.PolicyCertificates) - k - 1, outPerms, applicableChain)
	invariant forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(&trustInfo.PolicyChain[k])
	invariant forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < i ==> acc_inj_trustInfo_policy(trustInfo.PolicyChain[k], k, outPerms)
	invariant forall k int :: {&trustInfo.PolicyChain[k]} oldLen <= k && k < len(trustInfo.PolicyChain) ==> trustInfo.PolicyChain[k] == applicableChain.PolicyCertificates[k - oldLen]
	invariant outPerms == old(outPerms)
	invariant forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(&trustInfo.ConflictingPolicyAttributes[k])
	invariant forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} /*{acc_inj_trustInfo_conflictingPolicyAttributes_attr(arr[k], k)}*/ 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc_inj_trustInfo_conflictingPolicyAttributes_attr(trustInfo.ConflictingPolicyAttributes[k], k)
	invariant len(trustInfo.CertificateChain) > 0 && acc(&trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) && acc(trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1])
	invariant acc(policyDnsNameCache, _) && let e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName) in (e2ld in domain(policyDnsNameCache))
	decreases len(trustInfo.PolicyChain) - i
	for i := oldLen; i < len(trustInfo.PolicyChain); i++ {
		unfold acc_inj_chainCertificate(applicableChain.PolicyCertificates[i - oldLen], len(applicableChain.PolicyCertificates) - (i - oldLen) - 1, outPerms, applicableChain)
		fold acc_inj_trustInfo_policy(trustInfo.PolicyChain[i], i, outPerms)
	}
	if len(trustInfo.ConflictingPolicyAttributes) > 0 {
		trustInfo.EvaluationResult = 0
	} else {
		trustInfo.EvaluationResult = 1
	}
	fold acc_trustInfo(trustInfo, outPerms)
	return nil, outPerms
}

// Gobra does not support Generics. Thus, we can not use the Contains function from slices. 
// The import from slices was also removed for this reason!
func Contains(s []string, e string) bool