package cache_v2

import (
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
	"time"
	
	"fpki/pkg/common"
	"net/publicsuffix"
)

// create new PolicyTrustInfo
requires len(certificateChain) > 0
requires forall k int :: {&certificateChain[k]} 0 <= k && k < len(certificateChain) ==> acc(&certificateChain[k]) 
requires acc(certificateChain[len(certificateChain)-1])
requires let e2ld := publicsuffix.EffectiveTLDPlusOne(dnsName) in (e2ld in domain(policyDnsNameCache))
ensures acc_trustInfo(res, policyDnsNameCache)
func NewPolicyTrustInfo(dnsName string, certificateChain []*x509.Certificate, ghost policyDnsNameCache dict[string][]string) (res *PolicyTrustInfo) { // Added return param name
	policyTrustInfo := &PolicyTrustInfo{
		DNSName:                     dnsName,
		CertificateChain:            certificateChain,
		PolicyChain:                 nil,
		ConflictingPolicyAttributes: nil,
		PolicyChainTrustLevel:       0,
		EvaluationResult:            0,
		MaxValidity:                 time.Unix(0, 0),
		DomainExcluded:              false,
	}
	fold acc_trustInfo(policyTrustInfo, policyDnsNameCache)
	return policyTrustInfo
}

type PolicyTrustPreference struct {
	// PCA public keys
	PCAPublicKey string

	// TODO (cyrill): also implement setting the trust preferences for specific policy certificate
	// // Immutable hash of PCA certificate
	// PCAImmutableHash string

	// map CA set to TrustLevel
	TrustLevel int
}

type ConflictingPolicyAttribute struct {
	Domain    string
	Attribute *common.PolicyAttributes
}

type PolicyTrustInfo struct {
	// domain name used in the connection
	DNSName string

	// certificate chain received during the connection establishment
	CertificateChain []*x509.Certificate

	// CA set ID's and example subjects, and trust level of the
	// cached certificate chains that led to a failed
	// validation
	// (might be useful to construct error messages)

	// json encoded policy certifcates
	PolicyChain                 []*common.PolicyCertificate
	ConflictingPolicyAttributes []*ConflictingPolicyAttribute
	PolicyChainTrustLevel       int `default:"0"`

	// result of legacy validation
	// a value of 1 indicates that validation
	// was passed.
	// a value != 1 indicates failed validation
	EvaluationResult int `default:"0"`

	// timestamp indicating how long this
	// legacy validation outcome can be cached
	MaxValidity time.Time

	// true if the most specific policy (i.e., highest number of subdomains) added DNSName (or a
	// parent of DNSName) as an excluded subdomain where no policy attributes are applied
	DomainExcluded bool
}

// maps a domain name to a set of legacy trust preferences
// to be used to compute certificate chain trust levels
// TODO Unused? Only breaks verification because of assigning to global variables, but we never read from it
// var policyTrustPreferences = map[string][]*PolicyTrustPreference{}

type PolicyCertificateChain struct {
	PolicyCertificates                       []*common.PolicyCertificate
	DomainRootIssuanceTimestamp              time.Time
	DomainRootMinMaxTimestamp                time.Time
	RootAndIntermediateLatestMinMaxTimestamp time.Time
	DomainLatestMinMaxTimestamp              time.Time
	TrustLevel                               int

	// DisseminationTime  time.Time
}

requires policyPerms > 0
preserves forall k int :: {&pcChain.PolicyCertificates[k]} 0 <= k && k < len(pcChain.PolicyCertificates) ==> (acc(&pcChain.PolicyCertificates[k]) && (forall l int :: {&pcChain.PolicyCertificates[l]} 0 <= l && l < len(pcChain.PolicyCertificates) && k != l ==> &pcChain.PolicyCertificates[k] != &pcChain.PolicyCertificates[l]) && acc(pcChain.PolicyCertificates[k]/*getCertificatePerm(pcChain.PolicyCertificates[k])*/, policyPerms))// && acc(&pcChain.PolicyCertificates[k].PolicyAttributes))
func (pcChain PolicyCertificateChain) String(ghost policyPerms perm) string {
	str := fmt.Sprintf("<PolicyCertificateChain len=%d", len(pcChain.PolicyCertificates))
	str += fmt.Sprintf(", DomainRootIssuanceTimestamp=%v", pcChain.DomainRootIssuanceTimestamp)
	str += fmt.Sprintf(", DomainRootMinMaxTimestamp=%v", pcChain.DomainRootMinMaxTimestamp)
	str += fmt.Sprintf(", RootAndIntermediateLatestMinMaxTimestamp=%v", pcChain.RootAndIntermediateLatestMinMaxTimestamp)
	str += ", certs="
	invariant forall k int :: 0 <= k && k < len(pcChain.PolicyCertificates) ==> (acc(&pcChain.PolicyCertificates[k]) && (forall l int :: {&pcChain.PolicyCertificates[l]} 0 <= l && l < len(pcChain.PolicyCertificates) && k != l ==> &pcChain.PolicyCertificates[k] != &pcChain.PolicyCertificates[l]) && acc(pcChain.PolicyCertificates[k], policyPerms))
	invariant 0 <= i && i <= len(pcChain.PolicyCertificates)
	//for _, pc := range pcChain.PolicyCertificates {
	for i := 0; i < len(pcChain.PolicyCertificates); i++ {
		pc := pcChain.PolicyCertificates[i]
		if pc == nil {
			str += "nil, "
			continue
		}
		attributes, err := json.Marshal(pc.PolicyAttributes)
		if err != nil {
			break
		}
		pcStr := fmt.Sprintf("<Policy domain=%s, attributes=%s, #SPCTs=%d, hash=%s, immHash=%s >", pc.Domain(), attributes, len(pc.SPCTs), getPolicyHash(pc, policyPerms / 2), getImmutablePolicyHash(pc, policyPerms / 2))
		// pcStr, err := common.ToJSON(pc)
		// if err != nil {
		// break
		// }
		str += fmt.Sprintf("%s, ", pcStr)
	}
	return str + ">"
}

ensures acc(res) && len(res.PolicyCertificates) == 0
func NewPolicyCertificateChain() (res *PolicyCertificateChain) { // Named return variable for postcondition
	return &PolicyCertificateChain{
		PolicyCertificates:                       []*common.PolicyCertificate{},
		DomainRootIssuanceTimestamp:              time.Unix(0, 0),
		DomainRootMinMaxTimestamp:                time.Unix(0, 0),
		RootAndIntermediateLatestMinMaxTimestamp: time.Unix(0, 0),
		DomainLatestMinMaxTimestamp:              time.Unix(0, 0),
		TrustLevel:                               0,
	}
}

// initialize legacyTrustPreferences with a config
// TODO Unused? Only breaks verification because of assigning to global variables, but we never read from it
/* func InitializePolicyTrustPreferences(configMap map[string]interface{}) {
	policyTrustPreferences = map[string][]*PolicyTrustPreference{}

	// parse policy CA sets
	pcaSetsMap := map[string][]string{}
	pcaSets := configMap["policy-ca-sets"].(map[string]interface{})
	for pcaSetID, values := range pcaSets {
		pcaSetsMap[pcaSetID] = []string{}
		v := values.(map[string]interface{})
		for _, value := range v["pcas"].([]interface{}) {
			pcaSetsMap[pcaSetID] = append(pcaSetsMap[pcaSetID], value.(string))
		}
	}

	// parse policy CAs
	pcasPublicKeyMap := map[string]string{}
	pcas := configMap["policy-cas"].(map[string]interface{})
	for pcaID, values := range pcas {
		v := values.(map[string]interface{})
		pcasPublicKeyMap[pcaID] = v["publickey"].(string)
	}

	// get trust level map
	trustLevelMap := configMap["trust-levels"].(map[string]interface{})

	// parse policy trust preferences
	policyTrustPreferencesJSON := configMap["policy-trust-preference"].(map[string]interface{})
	for domainVar, entry := range policyTrustPreferencesJSON {
		domainTrustPreferences := []*PolicyTrustPreference{}
		objects := entry.([]interface{})
		for _, object := range objects {
			objectMap := object.(map[string]interface{})
			trustLevel := int(trustLevelMap[objectMap["level"].(string)].(float64))
			pcaSetID := objectMap["policy-ca-set"].(string)
			for _, pca := range pcaSetsMap[pcaSetID] {
				policyTrustPreference := &PolicyTrustPreference{
					PCAPublicKey: pcasPublicKeyMap[pca],
					TrustLevel:   trustLevel,
				}
				domainTrustPreferences = append(domainTrustPreferences, policyTrustPreference)
			}
		}
		policyTrustPreferences[domainVar] = domainTrustPreferences
	}
} */

// find the policy certificate chain which has the latest max timestamp in the set [issuance, SPCT time 1, SPCT time 2, ...].
// The second parameter is an optional root chain (e.g., domain root cert to root cert) that must be used. If nil is passed as an argument, any chain is accepted. If no acceptable chain can be generated, nil is returned.
requires cachePerms > 0
requires cachePerms <= 1
requires acc(&policyCache, cachePerms)
requires acc(&immutablePolicyCache, cachePerms)
requires acc(&policyDnsNameCache, cachePerms)
requires acc(immutablePolicyCache, cachePerms)
requires acc(policyCache, cachePerms)
requires acc(policyDnsNameCache, cachePerms)
requires inPerms > 0
requires inPerms <= 1
requires rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), inPerms)
requires acc(ImmutablePolicyCachePermissions_issuer(dict(immutablePolicyCache)), cachePerms)
requires (forall str string :: {&dict(immutablePolicyCache)[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes, cachePerms) && acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, dict(policyCache)), cachePerms)) &&  // dict needed in trigger to make sure that gobra generates a valid trigger!
    (forall str string :: {&dict(immutablePolicyCache)[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains, cachePerms))
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
ensures acc(&policyCache, cachePerms)
ensures acc(&immutablePolicyCache, cachePerms)
ensures acc(&policyDnsNameCache, cachePerms)
ensures acc(immutablePolicyCache, cachePerms)
ensures acc(policyCache, cachePerms)
ensures acc(policyDnsNameCache, cachePerms)
ensures outPerms > 0
ensures outPerms <= 1
ensures outPerms <= inPerms
ensures cachePerms == old(cachePerms)
ensures rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms)
ensures acc(ImmutablePolicyCachePermissions_issuer(dict(immutablePolicyCache)), cachePerms)
ensures (forall str string :: {&dict(immutablePolicyCache)[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes, cachePerms) && acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, dict(policyCache)), cachePerms)) &&  // dict needed in trigger to make sure that gobra generates a valid trigger!
    (forall str string :: {&dict(immutablePolicyCache)[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains, cachePerms)) &&
	(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains, cachePerms))
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures err == nil ==> res != nil
ensures (rootChain != nil || immutableHash != base64.StdEncoding.EncodeToString(nil)) && res != rootChain && err == nil ==> acc(acc_policyCertificateChain(res, dict(policyDnsNameCache)), outPerms)
ensures rootChain == nil && err == nil && immutableHash == base64.StdEncoding.EncodeToString(nil) ==> acc(res) && len(res.PolicyCertificates) == 0
ensures err == nil ==> (rootChain == nil && immutableHash == base64.StdEncoding.EncodeToString(nil) ==> toAbstractChainFromChain(res.PolicyCertificates, dict(policyDnsNameCache)) == old(abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, seq[AbstractPolicy]{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))))
ensures err == nil ==> ((rootChain != nil || immutableHash != base64.StdEncoding.EncodeToString(nil)) ==> unfoldAndToAbstractChainFromChain2(res, dict(policyDnsNameCache)) == old(abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache)) : seq[AbstractPolicy]{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))))
func getPolicyCertificateChainWithLatestTimestamp(immutableHash string, rootChain *PolicyCertificateChain, ghost inPerms perm, ghost cachePerms perm) (res *PolicyCertificateChain, err error, ghost outPerms perm) { // added names to reference return variables in postcondition 
	ghost outPerms = inPerms
	if rootChain != nil {
		unfold acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms / 2)
		unfold acc(acc_inj_chainCertificate(rootChain.PolicyCertificates[0], len(rootChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache)/*, rootChain*/), outPerms / 4)
		if immutableHash == getImmutablePolicyHash(rootChain.PolicyCertificates[0], outPerms / 8) {
			fold acc(acc_inj_chainCertificate(rootChain.PolicyCertificates[0], len(rootChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache)/*, rootChain*/), outPerms / 4)
			assume rootChain.DomainRootIssuanceTimestamp == abstractGetDomainRootIssuanceTimestamp(toAbstractChainFromChain(rootChain.PolicyCertificates, dict(policyDnsNameCache)))
			assume rootChain.DomainLatestMinMaxTimestamp == abstractGetDomainLatestMinMaxTimestamp(toAbstractChainFromChain(rootChain.PolicyCertificates, dict(policyDnsNameCache)))
			fold acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms / 2)
			reveal abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache)), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
			unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache))
			assert unfolding acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms / 2) in len(rootChain.PolicyCertificates) != 0
			lemmaAbstractChainZero(rootChain, dict(policyDnsNameCache), immutableHash, outPerms / 4)
			assert len(unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache))) != 0 && unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache))[0].immutableHash == immutableHash
			return rootChain, nil, outPerms
		}
		fold acc(acc_inj_chainCertificate(rootChain.PolicyCertificates[0], len(rootChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache)/*, rootChain*/), outPerms / 4)
		assume rootChain.DomainRootIssuanceTimestamp == abstractGetDomainRootIssuanceTimestamp(toAbstractChainFromChain(rootChain.PolicyCertificates, dict(policyDnsNameCache)))
		assume rootChain.DomainLatestMinMaxTimestamp == abstractGetDomainLatestMinMaxTimestamp(toAbstractChainFromChain(rootChain.PolicyCertificates, dict(policyDnsNameCache)))
		fold acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms / 2)
	} else {
		if immutableHash == base64.StdEncoding.EncodeToString(nil) {
			reveal abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, seq[AbstractPolicy]{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
			return NewPolicyCertificateChain(), nil, outPerms
		}
	}
	issuerEntry, ok := immutablePolicyCache[immutableHash]
	
	if !ok {
		return nil, fmt.Errorf("Inconsistent caches: policy with immutable hash %s does not exist", immutableHash), outPerms
	}

	assume immutableHash != base64.StdEncoding.EncodeToString(nil)

	parentChain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(unfolding acc(ImmutablePolicyCachePermissions_issuer(dict(immutablePolicyCache)), cachePerms) in issuerEntry.immutableIssuerHash, rootChain, inPerms / 2, cachePerms / 2) // inPerms / 2 will decrease the permissions of policies but that's okay, we then know that nothing changes 

	ghost outPerms = tmp

	if err != nil {
		return nil, err, outPerms
	}
	if parentChain == nil {
		assert false // Cannot get here since err == nil ==> res != nil in recursive postcondoition 
		return nil, nil, outPerms
	}
	unfold acc(ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache)), cachePerms / 2)
	
	if len(issuerEntry.policyHashes) == 0 {
		assert false // Cannot get here since issuerEntry.policyHashes > 0 according to invariant
		return nil, fmt.Errorf("Inconsistent caches: no policy certificate corresponding to immutable hash %s exists", immutableHash), outPerms
	}
	var minMaxTimestampPcEntry *common.PolicyCertificate
	var minMaxTimestamp time.Time

	ghost oldImmutablePolicyCache := dict(immutablePolicyCache)
	ghost oldPolicyCache := dict(policyCache)
	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)

	reveal getIssuer(immutableHash, dict(immutablePolicyCache))
	reveal isIssuerNil(immutableHash, dict(immutablePolicyCache))
	ghost if rootChain != nil {
		lemmaAbstractChainZero2(rootChain, dict(policyDnsNameCache), immutableHash, outPerms / 4)
	}
	assert !(immutableHash == base64.StdEncoding.EncodeToString(nil) || !(immutableHash in domain(immutablePolicyCache)))
	assert let rc := rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache)) : seq[AbstractPolicy]{} in !(len(rc) != 0 && immutableHash == rc[0].immutableHash) 
	
	invariant cachePerms > 0
	invariant cachePerms == old(cachePerms)
	invariant acc(&policyCache, cachePerms)
	invariant acc(&policyDnsNameCache, cachePerms)
	invariant acc(&immutablePolicyCache, cachePerms)
	invariant outPerms > 0
	invariant outPerms <= 1
	invariant outPerms <= old(outPerms)
	invariant old(outPerms) <= inPerms
	invariant acc(policyDnsNameCache, cachePerms)
	invariant acc(immutablePolicyCache, cachePerms)
	invariant acc(policyCache, cachePerms)
	invariant dict(policyCache) == oldPolicyCache
	invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
	invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
	invariant i > 0 ==> acc(minMaxTimestampPcEntry, outPerms)
	invariant i > 0 ==> minMaxTimestampPcEntry.Domain() in policyDnsNameCache
	invariant i > 0 ==> acc(cache_SPCTs(minMaxTimestampPcEntry.SPCTs), outPerms)
	invariant i > 0 ==> acc(policy_IssuerHash(minMaxTimestampPcEntry.IssuerHash), outPerms)
	invariant i > 0 ==> acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.AllowedCAs), outPerms) 
	invariant i > 0 ==> acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.AllowedSubdomains), outPerms) 
	invariant i > 0 ==> acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.DisallowedSubdomains), outPerms)
	invariant i > 0 ==> acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.ExcludedSubdomains), outPerms)
	invariant i > 0 ==> minMaxTimestamp == unfoldAndFindMaxSPCT(minMaxTimestampPcEntry.SPCTs, minMaxTimestampPcEntry.TimeStamp)
	invariant immutableHash in domain(dict(immutablePolicyCache))
	invariant issuerEntry == dict(immutablePolicyCache)[immutableHash]
	invariant acc(ImmutablePolicyCachePermissions_issuer(dict(immutablePolicyCache)), cachePerms)
    invariant (forall str string :: {&dict(immutablePolicyCache)[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes, cachePerms)) &&  // dict needed in trigger to make sure that gobra generates a valid trigger!
		(forall str string :: {&dict(immutablePolicyCache)[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp, cachePerms)) &&
		(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs, cachePerms)) &&
		(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains, cachePerms)) &&
		(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains, cachePerms)) &&
		(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains, cachePerms))
	invariant forall str string :: {&dict(immutablePolicyCache)[str].policyHashes} str in domain(immutablePolicyCache) && str != immutableHash ==> acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, dict(policyCache)), cachePerms)
	invariant let hashes := issuerEntry.policyHashes in (len(hashes) > 0 && forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k], cachePerms / 2) && hashes[k] in domain(policyCache))
	invariant acc(ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache)), cachePerms / 2) // remaining permissions for specification functions
	invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
	invariant parentChain != nil
	invariant (rootChain != nil || !isIssuerNil(immutableHash, dict(immutablePolicyCache))) && rootChain != parentChain ==> acc(acc_policyCertificateChain(parentChain, dict(policyDnsNameCache)), outPerms)
	invariant rootChain == nil && isIssuerNil(immutableHash, dict(immutablePolicyCache)) ==> acc(parentChain, outPerms) && len(parentChain.PolicyCertificates) == 0
	invariant rootChain == old(rootChain)
	invariant rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms)
	invariant 0 <= i && i <= len(issuerEntry.policyHashes)
	invariant i > 0 ==> toAbstractPolicyFromBlank(minMaxTimestampPcEntry) == getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i, i)
	invariant !(immutableHash == base64.StdEncoding.EncodeToString(nil) || !(immutableHash in domain(immutablePolicyCache)))
	invariant let rc := rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache)) : seq[AbstractPolicy]{} in !(len(rc) != 0 && immutableHash == rc[0].immutableHash) 
	for i := 0; i < len(issuerEntry.policyHashes); i += 1 {
		unfold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 2)
		hash := issuerEntry.policyHashes[i]
	//for i, hash := range issuerEntry.policyHashes {

		pcEntry, ok := policyCache[hash]
		if !ok {
			fold acc(ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache)), cachePerms / 2)
			fold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 2)
			assert false // cannot get here invariant says it must be present in policyCache
			return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", hash), outPerms
		}

		
		unfold acc(cache_policyHashes_policy(pcEntry.policy, hash, dict(policyDnsNameCache)), outPerms / 2)

		tLatest := pcEntry.policy.TimeStamp
		unfold acc(cache_SPCTs(pcEntry.policy.SPCTs), outPerms / 2)

		ghost oldMinMaxPolicy := i > 0 ? getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i, i) : AbstractPolicy{}

		lemmaFindMaxSPCTEmpty(pcEntry.policy.SPCTs, tLatest, outPerms / 4)

		invariant cachePerms == old(cachePerms)
		invariant acc(&policyCache, cachePerms)
		invariant acc(&policyDnsNameCache, cachePerms)
		invariant acc(&immutablePolicyCache, cachePerms)
		invariant cachePerms > 0
		invariant outPerms > 0
		invariant outPerms <= 1
		invariant outPerms == old(outPerms)
		invariant acc(policyDnsNameCache, cachePerms)
		invariant acc(immutablePolicyCache, cachePerms)
		invariant acc(policyCache, cachePerms)
		invariant dict(policyCache) == oldPolicyCache
		invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
		invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
		invariant pcEntry == dict(policyCache)[hash]
		invariant acc(ImmutablePolicyCachePermissions_issuer(dict(immutablePolicyCache)), cachePerms)
		invariant (forall str string :: {&dict(immutablePolicyCache)[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes, cachePerms)) &&  // dict needed in trigger to make sure that gobra generates a valid trigger!
			(forall str string :: {&dict(immutablePolicyCache)[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp, cachePerms)) &&
			(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs, cachePerms)) &&
			(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains, cachePerms)) &&
			(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains, cachePerms)) &&
			(forall str string :: {&dict(immutablePolicyCache)[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains, cachePerms))
		invariant immutableHash in domain(immutablePolicyCache)
		invariant immutableHash == old(immutableHash)
		invariant issuerEntry == dict(immutablePolicyCache)[immutableHash]
		invariant forall str string :: {&dict(immutablePolicyCache)[str].policyHashes} str in domain(immutablePolicyCache) && str != immutableHash ==> acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, dict(policyCache)), cachePerms)
		invariant forall str string :: {dict(policyCache)[str]} str in domain(dict(policyCache)) ==> 
			acc(dict(policyCache)[str], outPerms / 2) && 
			acc(PolicyCachePermissions_ImmutableHash(dict(policyCache)[str].immutableHash, str, dict(immutablePolicyCache)), outPerms / 2)
		invariant forall str string :: {dict(policyCache)[str]} str in domain(dict(policyCache)) && str != hash ==> acc(cache_policyHashes_policy(dict(policyCache)[str].policy, str, dict(policyDnsNameCache)), outPerms / 2)
		invariant acc(pcEntry.policy, outPerms / 2)
		invariant acc(policy_IssuerHash(pcEntry.policy.IssuerHash), outPerms / 2)
		invariant acc(acc_strs(pcEntry.policy.PolicyAttributes.AllowedCAs), outPerms / 2)
		invariant acc(acc_strs(pcEntry.policy.PolicyAttributes.AllowedSubdomains), outPerms / 2)
		invariant acc(acc_strs(pcEntry.policy.PolicyAttributes.DisallowedSubdomains), outPerms / 2)
		invariant acc(acc_strs(pcEntry.policy.PolicyAttributes.ExcludedSubdomains), outPerms / 2)
		invariant pcEntry.policy.Domain() in policyDnsNameCache
		invariant forall l int :: {&pcEntry.policy.SPCTs[l]} 0 <= l && l < len(pcEntry.policy.SPCTs) ==> acc(cache_SPCT(&pcEntry.policy.SPCTs[l], l), outPerms / 2)
		invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 2) // remaining permissions of PolicyCache
		invariant 0 <= j && j <= len(pcEntry.policy.SPCTs)
		invariant j == 0 ==> tLatest == pcEntry.policy.TimeStamp
		invariant tLatest == findMaxSPCT(pcEntry.policy.SPCTs, pcEntry.policy.TimeStamp, j, j)
		invariant acc(ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache)), cachePerms / 2) // remaining permissions for specification functions
		invariant let hashes := issuerEntry.policyHashes in (len(hashes) > 0 && forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k], cachePerms / 2) && hashes[k] in domain(policyCache))
		invariant 0 <= i && i < len(issuerEntry.policyHashes)
		invariant hash == issuerEntry.policyHashes[i]
		invariant pcEntry.policy == policyCache[hash].policy
		invariant i > 0 ==> getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i, i) == oldMinMaxPolicy
		invariant rootChain == old(rootChain)
		invariant rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, dict(policyDnsNameCache)), outPerms)
		invariant parentChain != nil
		invariant (rootChain != nil || !isIssuerNil(immutableHash, dict(immutablePolicyCache))) && rootChain != parentChain ==> acc(acc_policyCertificateChain(parentChain, dict(policyDnsNameCache)), outPerms)
		invariant rootChain == nil && isIssuerNil(immutableHash, dict(immutablePolicyCache)) ==> acc(parentChain, outPerms) && len(parentChain.PolicyCertificates) == 0
		invariant !(immutableHash == base64.StdEncoding.EncodeToString(nil) || !(immutableHash in domain(immutablePolicyCache)))
		invariant let rc := rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache)) : seq[AbstractPolicy]{} in !(len(rc) != 0 && immutableHash == rc[0].immutableHash) 
		for j := 0; j < len(pcEntry.policy.SPCTs); j++ {
			lemmaFindMaxSPCTInduction(pcEntry.policy.SPCTs, pcEntry.policy.TimeStamp, tLatest, j, outPerms / 4)
			reveal unfoldAndMaxTime(tLatest, &pcEntry.policy.SPCTs[j], j)
			unfold acc(cache_SPCT(&pcEntry.policy.SPCTs[j], j), outPerms / 4)
			spct := pcEntry.policy.SPCTs[j]
			tLatest = maxTime(tLatest, spct.AddedTS)
			fold acc(cache_SPCT(&pcEntry.policy.SPCTs[j], j), outPerms / 4)
		}
		fold acc(cache_SPCTs(pcEntry.policy.SPCTs), outPerms / 2)
		if i == 0 || tLatest.Before(minMaxTimestamp) {
			ghost if i == 0 {
				assert immutableHash in domain(immutablePolicyCache)
				assert acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4)
				assert len(immutablePolicyCache[immutableHash].policyHashes) > 0
				reveal unfoldAndToAbstractPolicyFromCache(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), 0)
				lemmaGetMinMaxPolicyEmpty(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), outPerms / 4, cachePerms / 4)
				assert unfoldAndToAbstractPolicyFromCache(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i) == getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i+1, i+1)
				assert (unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy, immutablePolicyCache[immutableHash].policyHashes[0], dict(policyDnsNameCache))) == getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), 1, 1)
				assert (unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4) in unfolding acc(cache_policyHashes_policy(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy, immutablePolicyCache[immutableHash].policyHashes[0], dict(policyDnsNameCache)), outPerms / 4) in toAbstractPolicyFromBlank(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy)) == getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), 1, 1)
				assert (unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy, immutablePolicyCache[immutableHash].policyHashes[0], dict(policyDnsNameCache))) == toAbstractPolicyFromBlank(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy)
				assert toAbstractPolicyFromBlank(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy) == getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), 1, 1)
			} else {
				reveal unfoldAndFindMaxSPCT(pcEntry.policy.SPCTs, pcEntry.policy.TimeStamp)
				assert pcEntry == policyCache[immutablePolicyCache[immutableHash].policyHashes[i]]
				assert unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4) in (toAbstractPolicyFromCache(pcEntry.policy, hash, dict(policyDnsNameCache)).minMaxTimestamp == unfolding acc(cache_policyHashes_policy(pcEntry.policy, hash, dict(policyDnsNameCache)), outPerms / 4) in unfoldAndFindMaxSPCT(pcEntry.policy.SPCTs, pcEntry.policy.TimeStamp))
				assert tLatest == unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4) in unfolding acc(cache_policyHashes_policy(pcEntry.policy, hash, dict(policyDnsNameCache)), outPerms / 4) in unfoldAndFindMaxSPCT(pcEntry.policy.SPCTs, pcEntry.policy.TimeStamp)
				assert tLatest == unfoldAndFindMaxSPCT(pcEntry.policy.SPCTs, pcEntry.policy.TimeStamp)
				assert unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4) in toAbstractPolicyFromCache(pcEntry.policy, hash, dict(policyDnsNameCache)).minMaxTimestamp == tLatest
				assert toAbstractPolicyFromBlank(minMaxTimestampPcEntry).minMaxTimestamp == minMaxTimestamp
				assert let curr := unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[i]].policy, immutablePolicyCache[immutableHash].policyHashes[i], dict(policyDnsNameCache))  in
					curr.minMaxTimestamp.Before(toAbstractPolicyFromBlank(minMaxTimestampPcEntry).minMaxTimestamp)
				reveal unfoldAndToAbstractPolicyFromCache(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i)
				lemmaGetMinMaxPolicyInduction1(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), toAbstractPolicyFromBlank(minMaxTimestampPcEntry), i, outPerms / 4, cachePerms / 4)
				assert unfoldAndToAbstractPolicyFromCache(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i) == getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i+1, i+1)
			}
			minMaxTimestamp = tLatest
			ghost outPerms = outPerms / 2
			minMaxTimestampPcEntry = pcEntry.policy
			
			reveal unfoldAndToAbstractPolicyFromCache(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i)
			assert unfoldAndToAbstractPolicyFromCache(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i) == toAbstractPolicyFromBlank(minMaxTimestampPcEntry)
			
			// do not fold PolicyCachePermissions back, we still have outPerms / 2
			
		} /*added */ else {
			reveal unfoldAndFindMaxSPCT(pcEntry.policy.SPCTs, pcEntry.policy.TimeStamp)

			assert pcEntry == policyCache[immutablePolicyCache[immutableHash].policyHashes[i]]
			assert unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4) in (toAbstractPolicyFromCache(pcEntry.policy, hash, dict(policyDnsNameCache)).minMaxTimestamp == unfolding acc(cache_policyHashes_policy(pcEntry.policy, hash, dict(policyDnsNameCache)), outPerms / 4) in unfoldAndFindMaxSPCT(pcEntry.policy.SPCTs, pcEntry.policy.TimeStamp))
			assert tLatest == unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4) in unfolding acc(cache_policyHashes_policy(pcEntry.policy, hash, dict(policyDnsNameCache)), outPerms / 4) in unfoldAndFindMaxSPCT(pcEntry.policy.SPCTs, pcEntry.policy.TimeStamp)
			assert tLatest == unfoldAndFindMaxSPCT(pcEntry.policy.SPCTs, pcEntry.policy.TimeStamp)
			assert unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4) in toAbstractPolicyFromCache(pcEntry.policy, hash, dict(policyDnsNameCache)).minMaxTimestamp == tLatest
			assert toAbstractPolicyFromBlank(minMaxTimestampPcEntry).minMaxTimestamp == minMaxTimestamp
			assert let curr := unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[i]].policy, immutablePolicyCache[immutableHash].policyHashes[i], dict(policyDnsNameCache))  in
				!curr.minMaxTimestamp.Before(toAbstractPolicyFromBlank(minMaxTimestampPcEntry).minMaxTimestamp)
					
			reveal unfoldAndToAbstractPolicyFromCache(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i)
			
			lemmaGetMinMaxPolicyInduction2(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), toAbstractPolicyFromBlank(minMaxTimestampPcEntry), i, outPerms / 4, cachePerms / 4)
			// we retain the permissions
			fold acc(cache_policyHashes_policy(pcEntry.policy, hash, dict(policyDnsNameCache)), outPerms / 2)
			fold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 2)
		}

		reveal unfoldAndFindMaxSPCT(minMaxTimestampPcEntry.SPCTs, minMaxTimestampPcEntry.TimeStamp)
	}
	
	assume abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache)) : seq[AbstractPolicy]{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache)) == old(abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache)) : seq[AbstractPolicy]{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache)))
	assume (rootChain != nil || !isIssuerNil(immutableHash, dict(immutablePolicyCache))) ==> (abstractGetPolicyCertificateChainWithLatestTimestamp(getIssuer(immutableHash, dict(immutablePolicyCache)), rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache)) : seq[AbstractPolicy]{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache)) == old(abstractGetPolicyCertificateChainWithLatestTimestamp(getIssuer(immutableHash, dict(immutablePolicyCache)), rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache)) : seq[AbstractPolicy]{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))))
	assume (rootChain != nil || !isIssuerNil(immutableHash, dict(immutablePolicyCache))) ==> (unfoldAndToAbstractChainFromChain2(parentChain, dict(policyDnsNameCache)) == abstractGetPolicyCertificateChainWithLatestTimestamp(getIssuer(immutableHash, dict(immutablePolicyCache))/*unfolding acc(ImmutablePolicyCachePermissions_issuer(dict(immutablePolicyCache)), cachePerms / 4) in issuerEntry.immutableIssuerHash*/, rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache)) : seq[AbstractPolicy]{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache)))
	assume (rootChain == nil && isIssuerNil(immutableHash, dict(immutablePolicyCache))) ==> (toAbstractChainFromChain(parentChain.PolicyCertificates, dict(policyDnsNameCache)) == abstractGetPolicyCertificateChainWithLatestTimestamp(getIssuer(immutableHash, dict(immutablePolicyCache))/*unfolding acc(ImmutablePolicyCachePermissions_issuer(dict(immutablePolicyCache)), cachePerms / 4) in issuerEntry.immutableIssuerHash*/, seq[AbstractPolicy]{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache)))
	assume getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), len(issuerEntry.policyHashes), len(issuerEntry.policyHashes)) == old(unfolding acc(ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache)), cachePerms / 4) in getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), len(issuerEntry.policyHashes), len(issuerEntry.policyHashes)))
	assume isIssuerNil(immutableHash, dict(immutablePolicyCache)) == old(isIssuerNil(immutableHash, dict(immutablePolicyCache)))
	
	fold acc(ImmutablePolicyCachePermissions_policyHashes(issuerEntry.policyHashes, immutableHash, dict(policyCache)), cachePerms / 2)

	ghost if (rootChain != nil || !isIssuerNil(immutableHash, dict(immutablePolicyCache))) {
		reveal unfoldAndToAbstractChainFromChain2(parentChain, dict(policyDnsNameCache))
		unfold acc(acc_policyCertificateChain(parentChain, dict(policyDnsNameCache)), outPerms)
	}
	requires outPerms > 0
	requires cachePerms > 0
	requires acc(&immutablePolicyCache, cachePerms / 2)
	requires acc(immutablePolicyCache, cachePerms / 2)
	requires acc(&policyDnsNameCache, cachePerms / 2)
	requires acc(policyDnsNameCache, cachePerms / 2)
	requires acc(ImmutablePolicyCachePermissions_issuer(dict(immutablePolicyCache)), cachePerms / 2)
	requires immutableHash in domain(immutablePolicyCache)
	requires (rootChain != nil || !isIssuerNil(immutableHash, dict(immutablePolicyCache))) ==> (
		acc(parentChain, outPerms / 2) &&
		len(parentChain.PolicyCertificates) >= 1 &&
		(forall l int :: {&parentChain.PolicyCertificates[l]} 0 <= l && l < len(parentChain.PolicyCertificates) ==> acc(&parentChain.PolicyCertificates[l], outPerms / 2)) &&
		(forall l int :: {&parentChain.PolicyCertificates[l]} 0 <= l && l < len(parentChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(parentChain.PolicyCertificates[l], len(parentChain.PolicyCertificates) - l - 1, dict(policyDnsNameCache)), outPerms / 2)))
	requires (rootChain == nil && isIssuerNil(immutableHash, dict(immutablePolicyCache))) ==> acc(parentChain, outPerms / 2) && len(parentChain.PolicyCertificates) == 0
	requires acc(minMaxTimestampPcEntry, outPerms /4)
	requires acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.AllowedCAs), outPerms /4) 
	requires acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.AllowedSubdomains), outPerms /4) 
	requires acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.DisallowedSubdomains), outPerms /4)
	requires acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.ExcludedSubdomains), outPerms /4)
	requires acc(cache_SPCTs(minMaxTimestampPcEntry.SPCTs), outPerms / 4)
	requires acc(policy_IssuerHash(minMaxTimestampPcEntry.IssuerHash), outPerms / 4)
	requires minMaxTimestampPcEntry.Domain() in domain(dict(policyDnsNameCache))
	ensures outPerms == before(outPerms)
	ensures cachePerms == before(cachePerms)
	ensures acc(&immutablePolicyCache, cachePerms / 2)
	ensures acc(immutablePolicyCache, cachePerms / 2)
	ensures acc(&policyDnsNameCache, cachePerms / 2)
	ensures acc(policyDnsNameCache, cachePerms / 2)
	ensures acc(ImmutablePolicyCachePermissions_issuer(dict(immutablePolicyCache)), cachePerms / 2)
	ensures immutableHash in domain(immutablePolicyCache)
	ensures (rootChain != nil || !isIssuerNil(immutableHash, dict(immutablePolicyCache))) ==> (
		acc(parentChain, outPerms / 2) &&
		len(parentChain.PolicyCertificates) >= 1 &&
		(forall l int :: {&parentChain.PolicyCertificates[l]} 0 <= l && l < len(parentChain.PolicyCertificates) ==> acc(&parentChain.PolicyCertificates[l], outPerms / 2)) &&
		(forall l int :: {&parentChain.PolicyCertificates[l]} 0 <= l && l < len(parentChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(parentChain.PolicyCertificates[l], len(parentChain.PolicyCertificates) - l - 1, dict(policyDnsNameCache)), outPerms / 4)))
	ensures (rootChain == nil && isIssuerNil(immutableHash, dict(immutablePolicyCache))) ==> acc(parentChain, outPerms / 2) && len(parentChain.PolicyCertificates) == 0
	ensures (acc(resChain, outPerms / 2) &&
		len(resChain.PolicyCertificates) >= 1 &&
		(forall l int :: {&resChain.PolicyCertificates[l]} 0 <= l && l < len(resChain.PolicyCertificates) ==> acc(&resChain.PolicyCertificates[l], outPerms / 2)) &&
		(forall l int :: {&resChain.PolicyCertificates[l]} 0 <= l && l < len(resChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(resChain.PolicyCertificates[l], len(resChain.PolicyCertificates) - l - 1, dict(policyDnsNameCache)), outPerms / 4)))
/*	ensures acc(minMaxTimestampPcEntry, outPerms /4)
	ensures acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.AllowedCAs), outPerms /8)
	ensures acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.AllowedSubdomains), outPerms /8)
	ensures acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.DisallowedSubdomains), outPerms /8)
	ensures acc(acc_strs(minMaxTimestampPcEntry.PolicyAttributes.ExcludedSubdomains), outPerms /8)
	ensures acc(cache_SPCTs(minMaxTimestampPcEntry.SPCTs), outPerms / 8)
	ensures acc(policy_IssuerHash(minMaxTimestampPcEntry.IssuerHash), outPerms / 8)
	ensures minMaxTimestampPcEntry.Domain() in domain(dict(policyDnsNameCache))*/
	ensures len(resChain.PolicyCertificates) == len(parentChain.PolicyCertificates) + 1 && resChain.PolicyCertificates[0] == minMaxTimestampPcEntry && (forall k int :: {&resChain.PolicyCertificates[k]} 1 <= k && k < len(resChain.PolicyCertificates) ==> resChain.PolicyCertificates[k] == parentChain.PolicyCertificates[k-1])
	ensures toAbstractPolicyFromChain(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache)) == before(toAbstractPolicyFromBlank(minMaxTimestampPcEntry))
	outline(
		isDomainRootCertificate := minMaxTimestampPcEntry.Domain() != "" && (len(parentChain.PolicyCertificates) == 0 || (unfolding acc(acc_inj_chainCertificate(parentChain.PolicyCertificates[0], len(parentChain.PolicyCertificates) - 1, dict(policyDnsNameCache)/*, parentChain*/), outPerms / 2) in parentChain.PolicyCertificates[0].Domain()) == "")
		isDomainRootCertificateParent := minMaxTimestampPcEntry.Domain() == ""
		domainRootIssuanceTimestamp := parentChain.DomainRootIssuanceTimestamp
		if isDomainRootCertificate {
			domainRootIssuanceTimestamp = minMaxTimestampPcEntry.TimeStamp
		}
		domainRootMinMaxTimestamp := parentChain.DomainRootMinMaxTimestamp
		if isDomainRootCertificate {
			domainRootMinMaxTimestamp = minMaxTimestamp
		}

		rootAndIntermediateLatestMinMaxTimestamp := parentChain.RootAndIntermediateLatestMinMaxTimestamp
		if isDomainRootCertificateParent {
			rootAndIntermediateLatestMinMaxTimestamp = maxTime(rootAndIntermediateLatestMinMaxTimestamp, minMaxTimestamp)
		}
		domainLatestMinMaxTimestamp := parentChain.DomainLatestMinMaxTimestamp
		if !isDomainRootCertificate && !isDomainRootCertificateParent {
			domainLatestMinMaxTimestamp = maxTime(domainLatestMinMaxTimestamp, minMaxTimestamp)
		}


		resChain := &PolicyCertificateChain{
			PolicyCertificates:                       append(perm(outPerms/8), []*common.PolicyCertificate{minMaxTimestampPcEntry}, parentChain.PolicyCertificates...),
			DomainRootIssuanceTimestamp:              domainRootIssuanceTimestamp,
			DomainRootMinMaxTimestamp:                domainRootMinMaxTimestamp,
			RootAndIntermediateLatestMinMaxTimestamp: rootAndIntermediateLatestMinMaxTimestamp,
			DomainLatestMinMaxTimestamp:              domainLatestMinMaxTimestamp,
			// todo: find trust level
			TrustLevel: max(parentChain.TrustLevel, 0),
		}
		fold acc(acc_inj_chainCertificate(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 1, dict(policyDnsNameCache)/*, resChain*/), outPerms / 4)
	)
	ghost outPerms = outPerms / 2

	assert minMaxTimestampPcEntry == resChain.PolicyCertificates[0]
	assert toAbstractPolicyFromChain(minMaxTimestampPcEntry, len(resChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache)) == toAbstractPolicyFromChain(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache))
	assert toAbstractPolicyFromChain(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache)) == unfolding acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, dict(policyCache)), cachePerms / 2) in getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), len(immutablePolicyCache[immutableHash].policyHashes), len(immutablePolicyCache[immutableHash].policyHashes))

	ghost if rootChain != nil || !isIssuerNil(immutableHash, dict(immutablePolicyCache)) {
		lemmaAddToChainAndFold(resChain, parentChain, unfolding acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, dict(policyCache)), cachePerms / 2) in getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), len(immutablePolicyCache[immutableHash].policyHashes), len(immutablePolicyCache[immutableHash].policyHashes)), abstractGetPolicyCertificateChainWithLatestTimestamp(getIssuer(immutableHash, dict(immutablePolicyCache)), rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, dict(policyDnsNameCache)) : seq[AbstractPolicy]{}, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache)), dict(policyDnsNameCache), outPerms / 4)
	} else {
		lemmaAddToChainAndFold2(resChain, unfolding acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, dict(policyCache)), cachePerms / 2) in getMinMaxPolicy(immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), len(immutablePolicyCache[immutableHash].policyHashes), len(immutablePolicyCache[immutableHash].policyHashes)), dict(policyDnsNameCache), outPerms / 4)
	}

	ghost lemmaChainGenerationSpec(resChain, rootChain, immutableHash, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), outPerms / 8, cachePerms / 8)
	
	return resChain, nil, outPerms / 4
}

// TODO Go's builtin max is not available, so here is a declaration just for this use case
ensures x < y ==> res == y && x >= y ==> res == x
func max(x, y int) (res int)


requires acc(&policyCache, 1/4)
requires acc(&immutablePolicyCache, 1/4)
requires acc(&policyDnsNameCache, 1/4)
requires inPerms > 0
requires inPerms <= 1
requires acc(policyCache, 1/4)
requires acc(policyDnsNameCache, 1/4)
requires acc(immutablePolicyCache, 1/4)
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
requires acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
requires acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/4)
requires domainVar in domain(policyDnsNameCache)
ensures acc(&policyCache, 1/4)
ensures acc(&immutablePolicyCache, 1/4)
ensures acc(&policyDnsNameCache, 1/4)
ensures outPerms > 0
ensures outPerms <= 1
ensures outPerms <= inPerms
ensures acc(policyCache, 1/4)
ensures acc(policyDnsNameCache, 1/4)
ensures acc(immutablePolicyCache, 1/4)
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
ensures acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/4)
ensures domainVar in domain(policyDnsNameCache)
ensures err == nil ==> res != nil
ensures err == nil ==> (forall k int :: {&res[k]} 0 <= k && k < len(res) ==> (acc(&res[k]) && res[k] != nil && acc(acc_inj_policyCertificateChain(res[k], k, dict(policyDnsNameCache)), outPerms)))
ensures err == nil ==> len(res) == len(let c, _ := dict(policyDnsNameCache)[domainVar] in c)
ensures err == nil ==> old(let c, _ :=  dict(policyDnsNameCache)[domainVar] in len(c)) == (let c, _ := dict(policyDnsNameCache)[domainVar] in len(c))
ensures err == nil ==> toAbstractChains(res, dict(policyDnsNameCache)) == abstractFindChains(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), len(let c, _ := dict(policyDnsNameCache)[domainVar] in c))
ensures err == nil ==> abstractFindChains(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), len(let c, _ := dict(policyDnsNameCache)[domainVar] in c)) == old(abstractFindChains(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), len(let c, _ := dict(policyDnsNameCache)[domainVar] in c)))
func findPolicyCertificateChainsForE2LD(domainVar string, ghost inPerms perm) (res []*PolicyCertificateChain, err error, ghost outPerms perm) {
	leafHashes, ok := policyDnsNameCache[domainVar]
	ghost outPerms = inPerms
	if !ok {
		return nil, nil, outPerms
	}
	chains := []*PolicyCertificateChain{}

	ghost oldPolicyCache := dict(policyCache)
	ghost oldImmutablePolicyCache := dict(immutablePolicyCache)
	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)

	lemmaFindAbstractChainsEmpty(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), outPerms / 2)

	invariant acc(&policyCache, 1/4)
	invariant acc(&policyDnsNameCache, 1/4)
	invariant acc(&immutablePolicyCache, 1/4)
	invariant acc(policyCache, 1/4)
	invariant acc(policyDnsNameCache, 1/4)
	invariant acc(immutablePolicyCache, 1/4)
	invariant dict(policyCache) == oldPolicyCache
	invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
	invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
	invariant chains != nil
	invariant outPerms <= old(outPerms)
	invariant outPerms > 0
	invariant outPerms <= 1
	invariant outPerms <= inPerms
	invariant acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
	invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
	invariant acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/4)
	invariant forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> (acc(&chains[k]) && chains[k] != nil && acc(acc_inj_policyCertificateChain(chains[k], k, dict(policyDnsNameCache)), outPerms))
	invariant 0 <= i && i <= len(leafHashes)
    invariant toAbstractChains(chains, dict(policyDnsNameCache)) == abstractFindChains(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i)
	invariant abstractFindChains(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), len(leafHashes)) == old(abstractFindChains(domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), len(leafHashes)))
	for i := 0; i < len(leafHashes); i++ {
		unfold acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/8)
		unfold acc(acc_leafHashes(leafHashes, domainVar, dict(policyCache)), 1/8)

		leafHash := leafHashes[i]
	//for _, leafHash := range leafHashes {
		leafCacheEntry, ok := policyCache[leafHash]
		if !ok {
			assert false
			fold acc(acc_leafHashes(leafHashes, domainVar, dict(policyCache)), 1/8)
			fold acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/8)
			return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", leafHash), outPerms
		}

		unfold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 2) // needs to be / 2 otherwise we cannot prove that abstractFindChains is still the same 
		unfold acc(PolicyCachePermissions_ImmutableHash(leafCacheEntry.immutableHash, leafHash, dict(immutablePolicyCache)), outPerms / 2)
		fold acc(PolicyCachePermissions_ImmutableHash(leafCacheEntry.immutableHash, leafHash, dict(immutablePolicyCache)), outPerms / 2) // invariant that leafCacheEntry.immutableHash is not nil lies in here -> needed so we get back chain predicate
		fold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 2)

		unfold acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/8)
		chain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 2) in unfolding acc(PolicyCachePermissions_ImmutableHash(leafCacheEntry.immutableHash, leafHash, dict(immutablePolicyCache)), outPerms / 2) in leafCacheEntry.immutableHash, nil, outPerms / 2, 1/16) // outPerms / 2 so we know that the policies haven't changed and findAbstractChains is still true. this will lower the permissions for all policies though.
		fold acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/8)

		ghost outPerms = tmp
		if err != nil {
			fold acc(acc_leafHashes(leafHashes, domainVar, dict(policyCache)), 1/8)
			fold acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/8)
			return chains, fmt.Errorf("Failed to get policy cert chain with latest timestamp: %s", err), outPerms
		}

		chains = append(perm(outPerms/2), chains, chain)
		
		fold acc(acc_inj_policyCertificateChain(chain, len(chains) - 1, dict(policyDnsNameCache)), outPerms)
		fold acc(acc_leafHashes(leafHashes, domainVar, dict(policyCache)), 1/8)
		fold acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/8)

		reveal unfoldAndToAbstractChainFromChain(chain, len(chains)-1, dict(policyDnsNameCache))
		reveal unfoldAndGetChain(unfolding acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/8) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, dict(policyCache)), 1/8) in (let hashes, _ := dict(policyDnsNameCache)[domainVar] in hashes[i]), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))

		lemmaFindAbstractChainsInduction(toAbstractChains(chains, dict(policyDnsNameCache)), domainVar, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), i, outPerms / 2)
	}
	return chains, nil, outPerms
}

requires acc(&policyCache, 1/4)
requires acc(&immutablePolicyCache, 1/4)
requires acc(&policyDnsNameCache, 1/4)
requires inPerms > 0
requires inPerms <= 1
requires domainRootPolicyCertificateChain != nil
requires acc(immutablePolicyCache, 1/4)
requires acc(policyCache, 1/4)
requires acc(policyDnsNameCache, 1/4)
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
requires acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
requires acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/4)
requires acc(acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), inPerms)
ensures acc(&policyCache, 1/4)
ensures acc(&immutablePolicyCache, 1/4)
ensures acc(&policyDnsNameCache, 1/4)
ensures outPerms > 0
ensures outPerms <= 1
ensures outPerms <= inPerms
ensures acc(immutablePolicyCache, 1/4)
ensures acc(policyCache, 1/4)
ensures acc(policyDnsNameCache, 1/4)
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
ensures acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/4)
ensures err == nil ==> acc(acc_policyCertificateChain(res, dict(policyDnsNameCache)), outPerms)
ensures err == nil ==> unfoldAndToAbstractChainFromChain2(res, dict(policyDnsNameCache)) == old(abstractFindPolicyCertificateChainForDomain(domainVar, unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache)))
func findPolicyCertificateChainForDomain(domainVar string, domainRootPolicyCertificateChain *PolicyCertificateChain, ghost inPerms perm) (res *PolicyCertificateChain, err error, ghost outPerms perm) {
	ghost specification := abstractFindPolicyCertificateChainForDomain(domainVar, unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
	
	ghost outPerms = inPerms
	unfold acc(acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), outPerms / 2)
	e2ld := unfolding acc(acc_inj_chainCertificate(domainRootPolicyCertificateChain.PolicyCertificates[0], len(domainRootPolicyCertificateChain.PolicyCertificates) - 0 - 1, dict(policyDnsNameCache)/*, domainRootPolicyCertificateChain*/), outPerms / 2) in domainRootPolicyCertificateChain.PolicyCertificates[0].Domain()
	fold acc(acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), outPerms / 2)
	subdomainsString, found := strings.CutSuffix(domainVar, e2ld)
	if !found {
		return nil, fmt.Errorf("Domain is not a subdomain of e2ld"), outPerms
	}
	subdomains := strings.Split(subdomainsString, ".")
	currentDomain := e2ld

	ghost oldPolicyCache := dict(policyCache)
	ghost oldImmutablePolicyCache := dict(immutablePolicyCache)
	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)

	var finalChain *PolicyCertificateChain

	reveal unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache))

	invariant outPerms > 0
	invariant acc(&policyCache, 1/4)
	invariant acc(&policyDnsNameCache, 1/4)
	invariant acc(&immutablePolicyCache, 1/4)
	invariant acc(policyCache, 1/4)
	invariant acc(policyDnsNameCache, 1/4)
	invariant acc(immutablePolicyCache, 1/4)
	invariant dict(policyCache) == oldPolicyCache
	invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
	invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
	invariant acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
	invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
	invariant acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/4)
	invariant outPerms == old(outPerms)
	invariant outPerms <= inPerms
	invariant domainRootPolicyCertificateChain != nil
	invariant acc(acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), outPerms)
	invariant acc(subdomains)
	invariant i <= 1 ==> currentDomain == e2ld
	invariant i == 0 ==> currentDomain in policyDnsNameCache
	invariant i == 0 ==> finalChain == nil
	invariant i > 0 ==> finalChain != nil
	invariant i > 1 ==> len(currentDomain) > len(e2ld)
	invariant finalChain != nil && finalChain != domainRootPolicyCertificateChain ==> acc(acc_policyCertificateChain(finalChain, dict(policyDnsNameCache)), outPerms)
	invariant 0 <= i && i <= len(subdomains)
	invariant forall k int :: {&subdomains[k]} 0 <= k && k < len(subdomains) ==> !strings.GhostContains(subdomains[k], ".")
	invariant e2ld == old(e2ld)
	invariant domainRootPolicyCertificateChain == old(domainRootPolicyCertificateChain)
	invariant i > 0 ==> abstractGetNewestChainWithRootChain(currentDomain, len(e2ld), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), abstractGetLeafHashesLen(currentDomain, dict(policyDnsNameCache), dict(policyCache))) == unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache))
	invariant i > 0 ==> currentDomain == abstractGetSubdomainString(e2ld, strings.toSeq(subdomains), i)
	invariant domainVar == old(domainVar)
	invariant unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)) == old(unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)))
	invariant abstractFindPolicyCertificateChainForDomain(domainVar, unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache)) == specification
	invariant specification == old(specification)
	invariant len(unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache))) > 0
	invariant e2ld == unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache))[0].Domain
	invariant strings.toSeq(subdomains) == strings.GhostSplit(strings.GhostCutSuffix(domainVar, e2ld), ".")
	for i := 0; i < len(subdomains); i++ {
		// skip last item since it is an empty string
		if i > 0 {
			ghost lemmaGetSubdomainStringInductionStep(e2ld, strings.toSeq(subdomains), i, currentDomain)
			lemmaParentDomain(subdomains[len(subdomains)-1-i], currentDomain)
			currentDomain = subdomains[len(subdomains)-1-i] + "." + currentDomain
			reveal unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache))
			reveal unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache))
			ghost abstractGetNewestChainWithRootChainInductionNextSubdomain(abstractParentDomain(currentDomain), currentDomain, len(e2ld), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache)), outPerms / 4)
		} /* added */ else {
			reveal unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache))
			ghost abstractGetNewestChainWithRootChainBaseCase(currentDomain, len(e2ld), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), outPerms / 4)
			ghost lemmaGetSubdomainStringBaseCase(e2ld, strings.toSeq(subdomains))
		}
		leafHashes, ok := policyDnsNameCache[currentDomain]
		//assert i == 0 ==> ok
		if ok {
			unfold acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/8)
			invariant outPerms == old(outPerms)
			invariant outPerms > 0
			invariant outPerms <= inPerms
			invariant acc(&policyCache, 1/4)
			invariant acc(&policyDnsNameCache, 1/4)
			invariant acc(&immutablePolicyCache, 1/4)
			invariant acc(policyCache, 1/4)
			invariant acc(policyDnsNameCache, 1/4)
			invariant acc(immutablePolicyCache, 1/4)
			invariant dict(policyCache) == oldPolicyCache
			invariant dict(immutablePolicyCache) == oldImmutablePolicyCache
			invariant dict(policyDnsNameCache) == oldPolicyDnsNameCache
			invariant acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/4)
			invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
			invariant acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/8)
			invariant forall str string :: {policyDnsNameCache[str]} str in domain(policyDnsNameCache) ==> let leafHashes, ok := policyDnsNameCache[str] in len(leafHashes) > 0 && acc(acc_leafHashes(leafHashes, str, dict(policyCache)), 1/8) 
			invariant domainRootPolicyCertificateChain != nil
			invariant acc(acc_policyCertificateChain(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), outPerms)
			invariant acc(subdomains)
			invariant currentDomain in policyDnsNameCache
			invariant let lH, ok := policyDnsNameCache[currentDomain] in lH === leafHashes
			invariant i > 0 ==> finalChain != nil
			invariant j > 0 ==> finalChain != nil
			invariant finalChain != nil && finalChain != domainRootPolicyCertificateChain ==> acc(acc_policyCertificateChain(finalChain, dict(policyDnsNameCache)), outPerms)
			invariant 0 <= j && j <= len(leafHashes)
			invariant i == 0 && j == 0 ==> finalChain == nil
			invariant finalChain == nil ==> abstractGetNewestChainWithRootChain(currentDomain, len(e2ld), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), j) == seq[AbstractPolicy]{}
			invariant finalChain != nil ==> abstractGetNewestChainWithRootChain(currentDomain, len(e2ld), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), j) == unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache))
			invariant forall k int :: {&subdomains[k]} 0 <= k && k < len(subdomains) ==> !strings.GhostContains(subdomains[k], ".")
			invariant abstractGetSubdomainString(e2ld, strings.toSeq(subdomains), i+1) == currentDomain
			invariant e2ld == old(e2ld)
			invariant domainRootPolicyCertificateChain == old(domainRootPolicyCertificateChain)
			invariant domainVar == old(domainVar)
			invariant unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)) == old(unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)))
			invariant abstractFindPolicyCertificateChainForDomain(domainVar, unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache)) == specification
			invariant specification == old(specification)
			invariant i > 0 ==> len(currentDomain) > len(e2ld)
			invariant i == 0 ==> currentDomain == e2ld
			invariant len(unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache))) > 0
			invariant e2ld == unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache))[0].Domain
			invariant strings.toSeq(subdomains) == strings.GhostSplit(strings.GhostCutSuffix(domainVar, e2ld), ".")
			for j := 0; j < len(leafHashes); j++ {
				unfold acc(acc_leafHashes(leafHashes, currentDomain, dict(policyCache)), 1/8)
				leafHash := leafHashes[j]
				fold acc(acc_leafHashes(leafHashes, currentDomain, dict(policyCache)), 1/8)
				leafCacheEntry, ok := policyCache[leafHash]
				if !ok {
					fold acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/8)
					return nil, fmt.Errorf("Inconsistent caches: policy with hash %s does not exist", leafHash), outPerms
				}

					unfold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4)
					unfold acc(PolicyCachePermissions_ImmutableHash(leafCacheEntry.immutableHash, leafHash, dict(immutablePolicyCache)), outPerms / 4)
					fold acc(PolicyCachePermissions_ImmutableHash(leafCacheEntry.immutableHash, leafHash, dict(immutablePolicyCache)), outPerms / 4)
					fold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 4)
					unfold acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/16)
					chain, err, tmp := getPolicyCertificateChainWithLatestTimestamp(unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms / 2) in leafCacheEntry.immutableHash, domainRootPolicyCertificateChain, outPerms / 4, 1/32)
					fold acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/16)
					ghost outPerms = tmp

				if err != nil {
					fold acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/8)
					return nil, fmt.Errorf("Failed to get policy cert chain with latest timestamp: %s", err), outPerms
				}

				if chain != nil {
					reveal abstractGetLeafHash(currentDomain, j, dict(policyDnsNameCache), dict(policyCache))
					reveal getImmutableHashFromLeafHash(abstractGetLeafHash(currentDomain, j, dict(policyDnsNameCache), dict(policyCache)), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
					ghost if finalChain != nil {
						reveal unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache))
					}
					reveal unfoldAndToAbstractChainFromChain2(chain, dict(policyDnsNameCache))
					assert leafHash == unfolding acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/8) in (let lH := policyDnsNameCache[currentDomain] in (unfolding acc(acc_leafHashes(lH, currentDomain, dict(policyCache)), 1/8) in lH[j]))

					if finalChain == nil || (unfolding acc(acc_policyCertificateChain(chain, dict(policyDnsNameCache)), outPerms / 2) in (chain.DomainLatestMinMaxTimestamp)).After(unfolding acc(acc_policyCertificateChain(finalChain, dict(policyDnsNameCache)), outPerms / 2) in finalChain.DomainLatestMinMaxTimestamp) {
						ghost abstractChain := unfoldAndToAbstractChainFromChain2(chain, dict(policyDnsNameCache))
						
						unfold acc(acc_policyCertificateChain(chain, dict(policyDnsNameCache)), outPerms / 2) 
						assume chain.DomainLatestMinMaxTimestamp == abstractGetDomainLatestMinMaxTimestamp(abstractChain)
						fold acc(acc_policyCertificateChain(chain, dict(policyDnsNameCache)), outPerms / 2) 
						reveal abstractGetLeafHash(currentDomain, j, dict(policyDnsNameCache), dict(policyCache))
						reveal getImmutableHashFromLeafHash(abstractGetLeafHash(currentDomain, j, dict(policyDnsNameCache), dict(policyCache)), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
						ghost if finalChain != nil {
							reveal unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache))
						}
						
						assume finalChain != nil ==> unfolding acc(acc_policyCertificateChain(finalChain, dict(policyDnsNameCache)), outPerms / 2) in finalChain.DomainLatestMinMaxTimestamp == abstractGetDomainLatestMinMaxTimestamp(unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache)))
						
						ghost abstractGetNewestChainWithRootChainInduction1SameSubdomain(currentDomain, len(e2ld), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), j, finalChain == nil ? seq[AbstractPolicy]{} : unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache)), outPerms / 4)
						//assume false
						finalChain = chain
					} /* added */ else {
						ghost abstractChain := unfoldAndToAbstractChainFromChain2(chain, dict(policyDnsNameCache))
						reveal abstractGetLeafHash(currentDomain, j, dict(policyDnsNameCache), dict(policyCache))
						reveal getImmutableHashFromLeafHash(abstractGetLeafHash(currentDomain, j, dict(policyDnsNameCache), dict(policyCache)), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
						ghost if finalChain != nil {
							reveal unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache))
						}
						
						unfold acc(acc_policyCertificateChain(chain, dict(policyDnsNameCache)), outPerms / 2) 
						assume chain.DomainLatestMinMaxTimestamp == abstractGetDomainLatestMinMaxTimestamp(abstractChain)
						fold acc(acc_policyCertificateChain(chain, dict(policyDnsNameCache)), outPerms / 2) 
						assume finalChain != nil ==> unfolding acc(acc_policyCertificateChain(finalChain, dict(policyDnsNameCache)), outPerms / 2) in finalChain.DomainLatestMinMaxTimestamp == abstractGetDomainLatestMinMaxTimestamp(unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache)))
						
						ghost abstractGetNewestChainWithRootChainInduction2SameSubdomain(currentDomain, len(e2ld), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), j, unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache)), outPerms / 4)
					}
				}
			}
			fold acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/8)
		} /* added */ else if i > 0 {
			ghost abstractGetNewestChainWithRootChainSkip(abstractParentDomain(currentDomain), currentDomain, len(e2ld), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache), unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), finalChain == nil ? seq[AbstractPolicy]{} : unfoldAndToAbstractChainFromChain2(finalChain, dict(policyDnsNameCache)), outPerms / 4) 
		}
	}
	reveal unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache))
	reveal abstractFindPolicyCertificateChainForDomain(domainVar, unfoldAndToAbstractChainFromChain2(domainRootPolicyCertificateChain, dict(policyDnsNameCache)), dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
	return finalChain, nil, outPerms
}

requires perms > 0
requires perms <= 1
requires acc(&policyDnsNameCache, 1/4)
preserves len(chains) > 0
requires acc(policyDnsNameCache, 1/4)
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> (acc(&chains[k]) && chains[k] != nil && acc(acc_inj_policyCertificateChain(chains[k], k, dict(policyDnsNameCache)), perms))
ensures acc(&policyDnsNameCache, 1/4)
ensures acc(policyDnsNameCache, 1/4)
ensures err == nil ==> res != nil && acc(acc_policyCertificateChain(res, dict(policyDnsNameCache)), perms)
ensures err == nil ==> unfoldAndToAbstractChainFromChain2(res, dict(policyDnsNameCache)) == old(abstractGetNewestChain(toAbstractChains(chains, dict(policyDnsNameCache)), len(chains)))
func getNewestChain(chains []*PolicyCertificateChain, ghost perms perm) (res *PolicyCertificateChain, err error) {
	// TODO: handle cool-off period

	var newestChain *PolicyCertificateChain

	ghost abstractChains := toAbstractChains(chains, dict(policyDnsNameCache))

	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)
	invariant acc(&policyDnsNameCache, 1/4)
	invariant acc(policyDnsNameCache, 1/4)
	invariant oldPolicyDnsNameCache === dict(policyDnsNameCache)
	invariant 0 <= i && i <= len(chains)
	invariant forall k int :: k >= i && k < len(chains) ==> acc(&chains[k]) && chains[k] != nil && acc(acc_inj_policyCertificateChain(chains[k], k, dict(policyDnsNameCache)), perms)
	invariant i > 0 ==> newestChain != nil && acc(acc_policyCertificateChain(newestChain, dict(policyDnsNameCache)), perms)
	invariant i > 0 ==> unfoldAndToAbstractChainFromChain2(newestChain, dict(policyDnsNameCache)) == abstractGetNewestChain(abstractChains, i)
	invariant abstractChains == old(abstractChains)
	invariant i < len(chains) ==> abstractChains[i:] == toAbstractChainsFrom(chains, dict(policyDnsNameCache), i)[i:]
	//for i, chain := range chains {
	for i := 0; i < len(chains); i++ {
		chain := chains[i]
		reveal unfoldAndToAbstractChainFromChain(chain, i, dict(policyDnsNameCache))
		unfold acc(acc_inj_policyCertificateChain(chain, i, dict(policyDnsNameCache)), perms)
		if i == 0 {
			newestChain = chain
			ghost lemmaGetNewestChainBaseCase(abstractChains)
		} else {
			chainTime := unfolding acc(acc_policyCertificateChain(chain, dict(policyDnsNameCache)), perms) in chain.DomainRootIssuanceTimestamp
			assume chainTime == abstractGetDomainRootIssuanceTimestamp(unfoldAndToAbstractChainFromChain2(chain, dict(policyDnsNameCache)))
			newestChainTime := unfolding acc(acc_policyCertificateChain(newestChain, dict(policyDnsNameCache)), perms) in newestChain.DomainRootIssuanceTimestamp
			assume newestChainTime == abstractGetDomainRootIssuanceTimestamp(unfoldAndToAbstractChainFromChain2(newestChain, dict(policyDnsNameCache)))
			reveal unfoldAndToAbstractChainFromChain2(newestChain, dict(policyDnsNameCache))
			reveal unfoldAndToAbstractChainFromChain2(chain, dict(policyDnsNameCache))
			if chainTime.After(newestChainTime) {
		//if i == 0 || chain.DomainRootIssuanceTimestamp.After(newestChain.DomainRootIssuanceTimestamp) {
				ghost lemmaGetNewestChainInduction1(abstractChains, i, unfoldAndToAbstractChainFromChain2(newestChain, dict(policyDnsNameCache)))
				newestChain = chain
			} /* added */ else {
				ghost lemmaGetNewestChainInduction2(abstractChains, i, unfoldAndToAbstractChainFromChain2(newestChain, dict(policyDnsNameCache)))	
			}
		}
	}
	return newestChain, nil
}

ghost
decreases
opaque
pure func normalizeDomainSpec(d string) string {
	return strings.HasSuffix(d, ".") ? d[:len(d) - 1] : d
}

// remove trailing dots from domain names
ensures res == normalizeDomainSpec(d)
func normalizeDomain(d string) (res string) { // added return param name
	dNormalized := d
	if strings.HasSuffix(dNormalized, ".") {
		dNormalized = dNormalized[:len(dNormalized)-1]
	}
	reveal normalizeDomainSpec(d)
	return dNormalized
}

// checks whether d1 is a subdomain of d2
// assumes that both inputs are valid domains without any wildcards
func isSameOrSubdomain(d1, d2 string) bool {
	d2Suffix := normalizeDomain(d2)
	if len(d2Suffix) > 0 {
		d2Suffix = "." + d2Suffix
	}
	return d1 == d2 || strings.HasSuffix(d1, d2Suffix)
}

// Evaluate whether connection should be allowed according to
// policy mode based on current state of the cache.
requires acc(&policyCache, 1/2)
requires acc(&immutablePolicyCache, 1/2)
requires acc(&policyDnsNameCache, 1/2)
requires inPerms > 0
requires inPerms <= 1
requires acc(immutablePolicyCache, 1/2)
requires acc(policyCache, 1/2)
requires acc(policyDnsNameCache, 1/2)
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
requires acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/2)
requires acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)) , 1/2)
requires acc_trustInfo(trustInfo, dict(policyDnsNameCache))
requires unfolding acc_trustInfo(trustInfo, dict(policyDnsNameCache)) in (trustInfo.EvaluationResult == 0 && len(trustInfo.ConflictingPolicyAttributes) == 0)
requires unfolding acc_trustInfo(trustInfo, dict(policyDnsNameCache)) in len(trustInfo.PolicyChain) == 0
ensures acc(&policyCache, 1/2)
ensures acc(&immutablePolicyCache, 1/2)
ensures acc(&policyDnsNameCache, 1/2)
ensures outPerms > 0
ensures outPerms <= 1
ensures outPerms <= inPerms
ensures acc(immutablePolicyCache, 1/2)
ensures acc(policyCache, 1/2)
ensures acc(policyDnsNameCache, 1/2)
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures acc(ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache)), 1/2)
ensures acc(PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache)), 1/2)
ensures acc(acc_trustInfo(trustInfo, dict(policyDnsNameCache)), outPerms)
ensures err == nil ==> (unfolding acc(acc_trustInfo(trustInfo, dict(policyDnsNameCache)), outPerms) in (toAbstractChainFromChain(trustInfo.PolicyChain, dict(policyDnsNameCache)))) == old(genAbstractChain(unfolding acc(acc_trustInfo(trustInfo, dict(policyDnsNameCache)), inPerms) in trustInfo.DNSName, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache)))
ensures err == nil ==> (unfolding acc(acc_trustInfo(trustInfo, dict(policyDnsNameCache)), outPerms) in (trustInfo.EvaluationResult == 0 ==> len(trustInfo.ConflictingPolicyAttributes) > 0 && !(validAgainstAllPolicies(toAbstractChainFromChain(trustInfo.PolicyChain, dict(policyDnsNameCache)), toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), len(trustInfo.PolicyChain)))))
ensures err == nil ==> (unfolding acc(acc_trustInfo(trustInfo, dict(policyDnsNameCache)), outPerms) in (trustInfo.EvaluationResult == 1 ==> len(trustInfo.ConflictingPolicyAttributes) == 0 && (validAgainstAllPolicies(toAbstractChainFromChain(trustInfo.PolicyChain, dict(policyDnsNameCache)), toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), len(trustInfo.PolicyChain)))))
func VerifyPolicy(trustInfo *PolicyTrustInfo, ghost inPerms perm) (err error, ghost outPerms perm) {
	ghost policyCacheView := dict(policyCache)
	ghost immutablePolicyCacheView := dict(immutablePolicyCache)
	ghost policyDnsNameCacheView := dict(policyDnsNameCache)

	unfold acc_trustInfo(trustInfo, policyDnsNameCacheView)

	ghost abstractChain := genAbstractChain(trustInfo.DNSName, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))

	// Gobra can only have one return element for pure functions
	/*e2ld, err := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName)
	if err != nil {
		return fmt.Errorf("Failed to get E2LD of %s: %s", trustInfo.DNSName, err)
	}*/

	e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName)

	// TODO (cyrill): ensure that enough map servers are queried and that enough full responses were returned

	// debug
	// fmt.Printf("root cert subject: %s\n", trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1].Subject.ToRDNSequence().String())
	// get all certificate chains for the E2LD
	
	e2ldChains, err, tmp := findPolicyCertificateChainsForE2LD(e2ld, inPerms / 2) // the policies will have lower permissions but we use / 2 so we can prove that the specifications still hold
	ghost outPerms = tmp

	if err != nil {
		fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms)
		return err, outPerms
	}
	
	fmt.Printf("domain root chains: %+v\n", e2ldChains)
	if len(e2ldChains) == 0 {
		reveal genAbstractChain(trustInfo.DNSName, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
		// no applicable policy certificates exist
		trustInfo.EvaluationResult = 1
		lemmaCheckNoPolicy(toAbstractChainFromChain(trustInfo.PolicyChain, dict(policyDnsNameCache)), toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
		fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms)
		return nil, outPerms
	}
	// find newest chain for e2ld	
	newestE2ldChain, err := getNewestChain(e2ldChains, outPerms)
	if err != nil {
		fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms)
		return err, outPerms
	}

	reveal unfoldAndToAbstractChainFromChain2(newestE2ldChain, dict(policyDnsNameCache))
	applicableChain, err, tmp := findPolicyCertificateChainForDomain(trustInfo.DNSName, newestE2ldChain, outPerms)
	ghost outPerms = tmp
	if err != nil {
		fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms)
		return err, outPerms
	}
	fmt.Printf("applicable chain: %+v\n", applicableChain)
	
	reveal unfoldAndToAbstractChainFromChain2(applicableChain, dict(policyDnsNameCache))

	unfold acc(acc_policyCertificateChain(applicableChain, policyDnsNameCacheView), outPerms)
	trustInfo.PolicyChain = append(outPerms / 2, trustInfo.PolicyChain, applicableChain.PolicyCertificates...)
	ghost outPerms = outPerms / 2
	rootCertificate := trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1].Subject.ToRDNSequence().String()

	reveal genAbstractChain(trustInfo.DNSName, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))

	lemmaCheckNoPolicy(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))

	invariant outPerms <= inPerms
	invariant outPerms == old(outPerms)
	invariant outPerms > 0
	invariant outPerms <= 1
	invariant acc(&policyCache, 1/2)
	invariant acc(&policyDnsNameCache, 1/2)
	invariant acc(&immutablePolicyCache, 1/2)
	invariant acc(policyCache, 1/2)
	invariant acc(policyDnsNameCache, 1/2)
	invariant acc(immutablePolicyCache, 1/2)
	invariant policyCacheView == dict(policyCache)
	invariant immutablePolicyCacheView == dict(immutablePolicyCache)
	invariant policyDnsNameCacheView == dict(policyDnsNameCache)
	invariant acc(PolicyCachePermissions(policyCacheView, immutablePolicyCacheView, policyDnsNameCacheView), outPerms / 2)
	invariant acc(ImmutablePolicyCachePermissions(immutablePolicyCacheView, policyCacheView), 1/2)
	invariant acc(PolicyDnsNameCachePermissions(policyDnsNameCacheView, policyCacheView), 1/2)
	invariant acc(trustInfo)
	invariant forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(&trustInfo.ConflictingPolicyAttributes[k])
	invariant forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(acc_inj_trustInfo_conflictingPolicyAttributes_attr(trustInfo.ConflictingPolicyAttributes[k], k), outPerms / 2)
	invariant forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(&trustInfo.PolicyChain[k], outPerms / 2)
	invariant len(trustInfo.CertificateChain) > 0 && acc(&trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1], outPerms / 2) && acc(trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1], outPerms / 2)
	invariant let e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName) in (e2ld in domain(policyDnsNameCacheView))
	invariant acc(applicableChain, outPerms / 2)
	invariant len(applicableChain.PolicyCertificates) >= 1
	invariant (forall l int :: {&applicableChain.PolicyCertificates[l]} 0 <= l && l < len(applicableChain.PolicyCertificates) ==> acc(&applicableChain.PolicyCertificates[l], outPerms / 2))
	invariant 0 <= idx && idx <= len(applicableChain.PolicyCertificates)
	invariant (forall l int :: {&applicableChain.PolicyCertificates[l]} idx <= l && l < len(applicableChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(applicableChain.PolicyCertificates[l], len(applicableChain.PolicyCertificates) - l - 1, policyDnsNameCacheView/*, applicableChain*/), outPerms / 2)) // do not fold back in case we add attributes arrays to trustInfo. Use permissions for that!
	invariant len(applicableChain.PolicyCertificates) == len(trustInfo.PolicyChain)
	invariant forall k int :: {&trustInfo.PolicyChain[k]} {&applicableChain.PolicyCertificates[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> trustInfo.PolicyChain[k] == applicableChain.PolicyCertificates[k]
	invariant forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(acc_inj_chainCertificate(trustInfo.PolicyChain[k], len(trustInfo.PolicyChain) - k - 1, dict(policyDnsNameCache)), outPerms / 2)
	invariant len(trustInfo.PolicyChain) == len(abstractChain)
	invariant abstractChain == old(abstractChain)
	invariant abstractChain == genAbstractChain(trustInfo.DNSName, dict(immutablePolicyCache), dict(policyCache), dict(policyDnsNameCache))
	invariant abstractChain == toAbstractChainFromChain(trustInfo.PolicyChain, dict(policyDnsNameCache))
	invariant len(trustInfo.ConflictingPolicyAttributes) > 0 ==> !(validAgainstAllPolicies(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), idx))
	invariant len(trustInfo.ConflictingPolicyAttributes) == 0 ==> (validAgainstAllPolicies(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), idx))
	invariant rootCertificate == trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1].Subject.ToRDNSequence().String()
	decreases len(applicableChain.PolicyCertificates) - idx
	//for idx, policyCert := range applicableChain.PolicyCertificates with i0 {
	for idx := 0; idx < len(applicableChain.PolicyCertificates); idx++ {
		policyCert := applicableChain.PolicyCertificates[idx]

		unfold acc(acc_inj_chainCertificate(applicableChain.PolicyCertificates[idx], len(applicableChain.PolicyCertificates) - idx - 1, policyDnsNameCacheView), outPerms / 2)

		err := policyCert.PolicyAttributes.ValidateAttributes()

		if err != nil {
			dom := policyCert.Domain()
			fold acc(acc_inj_chainCertificate(applicableChain.PolicyCertificates[idx], len(applicableChain.PolicyCertificates) - idx - 1, policyDnsNameCacheView), outPerms / 2)
			fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms / 2)
			return fmt.Errorf("Failed to validate attributes for domain %s: %s", dom, err), outPerms / 2
		}

		// check for the status of the subdomains
		policyCertDomain := normalizeDomain(policyCert.Domain()) 
		unfold acc(acc_strs(policyCert.PolicyAttributes.AllowedCAs), outPerms / 4)
		unfold acc(acc_strs(policyCert.PolicyAttributes.AllowedSubdomains), outPerms / 4)
		unfold acc(acc_strs(policyCert.PolicyAttributes.DisallowedSubdomains), outPerms / 4)
		unfold acc(acc_strs(policyCert.PolicyAttributes.ExcludedSubdomains), outPerms / 4)
		domainValidity := policyCert.PolicyAttributes.CheckDomainValidity(policyCertDomain, trustInfo.DNSName, outPerms / 8)
		fold acc(acc_strs(policyCert.PolicyAttributes.AllowedCAs), outPerms / 4)
		fold acc(acc_strs(policyCert.PolicyAttributes.AllowedSubdomains), outPerms / 4)
		fold acc(acc_strs(policyCert.PolicyAttributes.DisallowedSubdomains), outPerms / 4)
		fold acc(acc_strs(policyCert.PolicyAttributes.ExcludedSubdomains), outPerms / 4)

		// check if the domain should not consider policies
		if idx == 0 && domainValidity == common.PolicyAttributeDomainExcluded {
			trustInfo.DomainExcluded = true
		}

		// check if the domain is allowed or not
		if domainValidity == common.PolicyAttributeDomainAllowed {
			lemmaDomainAllowedValid(trustInfo.PolicyChain[idx], len(trustInfo.PolicyChain) - idx - 1, dict(policyDnsNameCache), abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), outPerms / 4)
			// no conflicting domain attribute
		} else if domainValidity == common.PolicyAttributeDomainDisallowed {
			lemmaDomainDisallowedInvalid(trustInfo.PolicyChain[idx], len(trustInfo.PolicyChain) - idx - 1, dict(policyDnsNameCache), abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), outPerms / 4)
			attr := &common.PolicyAttributes{AllowedSubdomains: policyCert.PolicyAttributes.AllowedSubdomains, DisallowedSubdomains: policyCert.PolicyAttributes.DisallowedSubdomains}
			fold acc(acc_strs(attr.AllowedCAs), outPerms / 2)
			fold acc(acc_strs(attr.ExcludedSubdomains), outPerms / 2)
			fold acc(acc_policyAttributes(attr), outPerms / 2)
			confAttr := &ConflictingPolicyAttribute{Domain: policyCert.Domain(), Attribute: attr}
			trustInfo.ConflictingPolicyAttributes = append(perm(1/2), trustInfo.ConflictingPolicyAttributes, confAttr)
			fold acc(acc_inj_trustInfo_conflictingPolicyAttributes_attr(confAttr, len(trustInfo.ConflictingPolicyAttributes) - 1), outPerms / 2)
		} /*added*/ else {
			lemmaDomainExcludedValid(trustInfo.PolicyChain[idx], len(trustInfo.PolicyChain) - idx - 1, dict(policyDnsNameCache), abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), outPerms / 4)
		}

		// check for allowed CAs
		if len(policyCert.PolicyAttributes.AllowedCAs) > 0 {
			fmt.Printf("Checking if %s is contained in %+v\n", rootCertificate, policyCert.PolicyAttributes.AllowedCAs)
			if !Contains(policyCert.PolicyAttributes.AllowedCAs, rootCertificate, outPerms / 4) { // changed from !slices.Contains
				
				attr := &common.PolicyAttributes{AllowedCAs: policyCert.PolicyAttributes.AllowedCAs}
				fold acc(acc_strs(attr.AllowedSubdomains), outPerms / 2)
				fold acc(acc_strs(attr.DisallowedSubdomains), outPerms / 2)
				fold acc(acc_strs(attr.ExcludedSubdomains), outPerms / 2)
				reveal strsToSeq(policyCert.PolicyAttributes.AllowedCAs)

				lemmaNotValidAgainstCA(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
				fold acc(acc_policyAttributes(attr), outPerms / 2)
				confAttr := &ConflictingPolicyAttribute{Domain: policyCert.Domain(), Attribute: attr}
				trustInfo.ConflictingPolicyAttributes = append(perm(1/2), trustInfo.ConflictingPolicyAttributes, confAttr)
				fold acc(acc_inj_trustInfo_conflictingPolicyAttributes_attr(confAttr, len(trustInfo.ConflictingPolicyAttributes) - 1), outPerms / 2)
			} /* added */ else {
				reveal strsToSeq(policyCert.PolicyAttributes.AllowedCAs)
				lemmaValidAgainstCA(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
				
			}
		}/* added */ else {
			reveal strsToSeq(policyCert.PolicyAttributes.AllowedCAs)	
			lemmaValidAgainstCA(abstractChain[idx], toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName))
		}
		lemmaValidAgainstAllPoliciesPlus1(abstractChain, toAbstractCertificateChainInfo(trustInfo.CertificateChain, trustInfo.DNSName), idx)
	}
	if len(trustInfo.ConflictingPolicyAttributes) > 0 {
		trustInfo.EvaluationResult = 0
	} else {
		trustInfo.EvaluationResult = 1
	}
	fold acc(acc_trustInfo(trustInfo, policyDnsNameCacheView), outPerms / 2)
	return nil, outPerms / 2
}

// Gobra does not support Generics. Thus, we can not use the Contains function from slices. 
// The import from slices was also removed for this reason!
requires perms > 0
requires acc(acc_strs(s), perms)
ensures acc(acc_strs(s), perms)
ensures res == unfolding acc(acc_strs(s), perms) in (exists k int :: {&s[k]} 0 <= k && k < len(s) && s[k] == e)
//ensures res == unfolding acc_strs(s, perms) in (e in toSeq(s))
func Contains(s []string, e string, ghost perms perm) (res bool)

// added
ghost
requires acc_strs(s)
ensures res == unfolding acc_strs(s) in (exists k int :: {&s[k]} 0 <= k && k < len(s) && s[k] == e)
//ensures res == unfolding acc_strs(s, perms) in (e in toSeq(s))
decreases
pure func AContains(s []string, e string) (res bool)
