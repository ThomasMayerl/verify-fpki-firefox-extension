package cache_v2

import (
	"crypto/x509"
    "fpki/pkg/common"
    "encoding/base64"
    "net/publicsuffix"
	"strings"
	"time"
	"fpki/pkg/common/crypto"
)

pred acc_leafHashes(hashes []string, str string, ghost policyCache dict[string]*PolicyCacheEntry) {
	//forall k int :: {hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k], _)
	forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k]) && hashes[k] in domain(policyCache)
}

pred cache_SPCT(spct *common.SignedPolicyCertificateTimestamp, l int) {
	acc(spct)
}

pred cache_SPCTs(arr []common.SignedPolicyCertificateTimestamp) {
	forall l int :: {&arr[l]} 0 <= l && l < len(arr) ==> cache_SPCT(&arr[l], l)
}

pred policy_IssuerHash(issuerHash []byte) {
	forall k int :: {&issuerHash[k]} 0 <= k && k < len(issuerHash) ==> acc(&issuerHash[k])
}

// If we include this directly in PolicyCachePermissions instead of putting it like this into a separate predicate it will not terminate upon a verification error after unfold
pred cache_policyHashes_policy(policy *common.PolicyCertificate, hash string, ghost policyDnsNameCache dict[string][]string) {
	acc(policy) && 
	policy.Domain() in domain(policyDnsNameCache) && cache_SPCTs(policy.SPCTs) && policy_IssuerHash(policy.IssuerHash) && acc_strs(policy.PolicyAttributes.AllowedCAs) && acc_strs(policy.PolicyAttributes.AllowedSubdomains) && acc_strs(policy.PolicyAttributes.DisallowedSubdomains) && acc_strs(policy.PolicyAttributes.ExcludedSubdomains)
}

pred ImmutablePolicyCachePermissions_policyHashes(hashes []string, immutableHash string, ghost policyCache dict[string]*PolicyCacheEntry) {
    len(hashes) > 0 && forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k]) && hashes[k] in domain(policyCache)
}

pred ImmutablePolicyCachePermissions(ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, ghost policyCache dict[string]*PolicyCacheEntry) { 
    (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) && 
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	(forall str string :: {&immutablePolicyCache[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash) && ((immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) && immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache)) ==> immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
}

pred PolicyCachePermissions_ImmutableHash(immutableHash string, policyHash string, ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry) {
	immutableHash != base64.StdEncoding.EncodeToString(nil) && 
    immutableHash in domain(immutablePolicyCache) 
}

// Note: This pred used to have policy perms only for the cache_policyHashes_policy predicate. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred PolicyCachePermissions(ghost policyCache dict[string]*PolicyCacheEntry, ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, ghost policyDnsNameCache dict[string][]string) {
    forall str string :: {policyCache[str]} str in domain(policyCache) ==> 
    acc(policyCache[str]) && 
    PolicyCachePermissions_ImmutableHash(policyCache[str].immutableHash, str, immutablePolicyCache) && // We don't need these invariants in a lot of places -> put into separate predicate to not carry quantifier around
    cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache) //acc(policyCache[str].policy, perms) && cache_SPCTs(policyCache[str].policy.SPCTs, perms)
}

pred PolicyDnsNameCachePermissions(ghost policyDnsNameCache dict[string][]string, ghost policyCache dict[string]*PolicyCacheEntry) {
    forall str string :: {policyDnsNameCache[str]} str in domain(policyDnsNameCache) ==> let leafHashes, ok := policyDnsNameCache[str] in len(leafHashes) > 0 && acc_leafHashes(leafHashes, str, policyCache)
}

pred acc_strs(arr []string) {
	forall k int :: {&arr[k]} 0 <= k && k < len(arr) ==> acc(&arr[k])
}

pred acc_inj_chainCertificate(cert *common.PolicyCertificate, i int, ghost policyDnsNameCache dict[string][]string, chain *PolicyCertificateChain) { // chain s.t. we do not have issues to folding the cert twice for two chains
	acc(cert) && cert.Domain() in domain(policyDnsNameCache) && cache_SPCTs(cert.SPCTs) && policy_IssuerHash(cert.IssuerHash) && acc_strs(cert.PolicyAttributes.AllowedCAs) && acc_strs(cert.PolicyAttributes.AllowedSubdomains) && acc_strs(cert.PolicyAttributes.DisallowedSubdomains) && acc_strs(cert.PolicyAttributes.ExcludedSubdomains)
}

// Note: This pred used to have policy perms only for the acc_inj_chainCertificate predicate. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred acc_policyCertificateChain(chain *PolicyCertificateChain, ghost policyDnsNameCache dict[string][]string) {
	acc(chain) &&
	len(chain.PolicyCertificates) >= 1 &&
	(forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc(&chain.PolicyCertificates[l])) &&
	(forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc_inj_chainCertificate(chain.PolicyCertificates[l], len(chain.PolicyCertificates) - l - 1, policyDnsNameCache, chain)) 
	//unfolding acc_inj_chainCertificate(chain.PolicyCertificates[0], len(chain.PolicyCertificates) - 0 - 1, perms, chain) in chain.PolicyCertificates[0].Domain() in domain(policyDnsNameCache) // needed s.t. inner loop in findPolicyCertificateChainForDomain executes at least once and res is set
} 

pred acc_inj_policyCertificateChain(chain *PolicyCertificateChain, i int, ghost policyDnsNameCache dict[string][]string) {
	acc_policyCertificateChain(chain, policyDnsNameCache)
}

pred acc_inj_trustInfo_policy(policy *common.PolicyCertificate, i int) {
	acc(policy) && cache_SPCTs(policy.SPCTs) && policy_IssuerHash(policy.IssuerHash) && acc_strs(policy.PolicyAttributes.AllowedCAs) && acc_strs(policy.PolicyAttributes.AllowedSubdomains) && acc_strs(policy.PolicyAttributes.DisallowedSubdomains) && acc_strs(policy.PolicyAttributes.ExcludedSubdomains)
}

pred acc_policyAttributes(attr *common.PolicyAttributes) {
	acc(&attr.AllowedCAs) && acc(&attr.AllowedSubdomains) && acc(&attr.DisallowedSubdomains) && acc(&attr.ExcludedSubdomains) &&
	acc_strs(attr.AllowedCAs) &&
	acc_strs(attr.AllowedSubdomains) && 
	acc_strs(attr.DisallowedSubdomains) &&
	acc_strs(attr.ExcludedSubdomains)
}

pred acc_inj_trustInfo_conflictingPolicyAttributes_attr(attr *ConflictingPolicyAttribute, i int) {
	acc(attr) && acc_policyAttributes(attr.Attribute)
}

// Note: This pred used to have policy perms only for the acc_inj_trustInfo_policy and acc_inj_trustInfo_conflictingPolicyAttributes_attr predicates. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred acc_trustInfo(trustInfo *PolicyTrustInfo, ghost policyDnsNameCache dict[string][]string) {
	acc(trustInfo) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(&trustInfo.ConflictingPolicyAttributes[k])) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc_inj_trustInfo_conflictingPolicyAttributes_attr(trustInfo.ConflictingPolicyAttributes[k], k)) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(&trustInfo.PolicyChain[k])) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc_inj_trustInfo_policy(trustInfo.PolicyChain[k], k)) &&
	len(trustInfo.CertificateChain) > 0 && acc(&trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) && acc(trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) &&
	let e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName) in (e2ld in domain(policyDnsNameCache)) &&
	len(trustInfo.PolicyChain) >= 0
}

// --- | CORRECTNESS | ---

ghost type AbstractPolicy ghost struct {
	AllowedCAs seq[string]
	AllowedSubdomains seq[string]
	DisallowedSubdomains seq[string]
	ExcludedSubdomains seq[string]
	Domain string
}

ghost type AbstractCertificateChainInfo ghost struct {
	CA string
	DNSName string
}


ghost type AbstractChain seq[AbstractPolicy]

// from Gobra tutorial at https://github.com/viperproject/gobra/blob/master/docs/tutorial.md
ghost
requires forall j int :: 0 <= j && j < len(s) ==> acc(&s[j])
ensures  len(res) == len(s)
ensures  forall j int :: {s[j]} {res[j]} 0 <= j && j < len(s) ==> s[j] == res[j]
decreases len(s)
opaque
pure func toSeq(s []string) (res seq[string]) {
	return (len(s) == 0 ? seq[string]{} :
		toSeq(s[:len(s)-1]) ++ seq[string]{s[len(s) - 1]})
}

ghost
requires acc_strs(s)
decreases
opaque
pure func strsToSeq(s []string) (res seq[string]) {
	return unfolding acc_strs(s) in toSeq(s)
}

ghost 
requires acc_inj_trustInfo_policy(policyCertificate, l)
decreases
//opaque
pure func toAbstractPolicy(policyCertificate *common.PolicyCertificate, l int) AbstractPolicy {
	return unfolding acc_inj_trustInfo_policy(policyCertificate, l) in (
		AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		})
}

ghost
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc(&policyCertificates[l])
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc_inj_trustInfo_policy(policyCertificates[l], l)
ensures len(policyCertificates) == len(res)
ensures forall k int :: {res[k]} 0 <= k && k < len(policyCertificates) ==> res[k] == toAbstractPolicy(policyCertificates[k], k)
decreases
pure func toAbstractChain(policyCertificates []*common.PolicyCertificate) (res AbstractChain)

ghost 
requires cache_policyHashes_policy(policyCertificate, hash, policyDnsNameCache)
decreases
pure func toAbstractPolicyFromCache(policyCertificate *common.PolicyCertificate, hash string, policyDnsNameCache dict[string][]string) AbstractPolicy {
	return unfolding cache_policyHashes_policy(policyCertificate, hash, policyDnsNameCache) in (
		AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		})
}

ghost 
requires acc_inj_chainCertificate(policyCertificate, l, policyDnsNameCache, chain)
decreases
pure func toAbstractPolicyFromChain(policyCertificate *common.PolicyCertificate, l int, policyDnsNameCache dict[string][]string, chain *PolicyCertificateChain) AbstractPolicy {
	return unfolding acc_inj_chainCertificate(policyCertificate, l, policyDnsNameCache, chain) in (
		AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		})
}

ghost 
requires acc(policyCertificate)
requires acc_strs(policyCertificate.PolicyAttributes.AllowedCAs) 
requires acc_strs(policyCertificate.PolicyAttributes.AllowedSubdomains) 
requires acc_strs(policyCertificate.PolicyAttributes.DisallowedSubdomains)
requires acc_strs(policyCertificate.PolicyAttributes.ExcludedSubdomains)
decreases
pure func toAbstractPolicyFromBlank(policyCertificate *common.PolicyCertificate) AbstractPolicy {
	return AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		}
}

ghost
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc(&policyCertificates[l])
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc_inj_chainCertificate(policyCertificates[l], len(policyCertificates) - l - 1, policyDnsNameCache, chain)
ensures len(policyCertificates) == len(res)
ensures forall k int :: {res[k]} 0 <= k && k < len(policyCertificates) ==> res[k] == toAbstractPolicyFromChain(policyCertificates[k], len(policyCertificates) - k - 1, policyDnsNameCache, chain)
decreases
pure func toAbstractChainFromChain(policyCertificates []*common.PolicyCertificate, policyDnsNameCache dict[string][]string, chain *PolicyCertificateChain) (res AbstractChain)

/*
ghost
requires perms > 0
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc(&policyCertificates[l])
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc_inj_trustInfo_policy(policyCertificates[l], l, perms)
ensures len(policyCertificates) == len(res)
ensures forall k int :: {res[k].Domain} 0 <= k && k < len(policyCertificates) ==> res[k].Domain == unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in policyCertificates[k].Domain()
ensures (forall k int :: {res[k].AllowedCAs} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.AllowedCAs, perms) in toSeq(policyCertificates[k].PolicyAttributes.AllowedCAs) == res[k].AllowedCAs)))
ensures (forall k int :: {res[k].AllowedSubdomains} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.AllowedSubdomains, perms) in toSeq(policyCertificates[k].PolicyAttributes.AllowedSubdomains) == res[k].AllowedSubdomains)))
ensures (forall k int :: {res[k].DisallowedSubdomains} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.DisallowedSubdomains, perms) in toSeq(policyCertificates[k].PolicyAttributes.DisallowedSubdomains) == res[k].DisallowedSubdomains)))
ensures (forall k int :: {res[k].ExcludedSubdomains} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.ExcludedSubdomains, perms) in toSeq(policyCertificates[k].PolicyAttributes.ExcludedSubdomains) == res[k].ExcludedSubdomains)))
decreases
pure func toAbstractChain(policyCertificates []*common.PolicyCertificate, perms perm) (res AbstractChain)*/



ghost 
decreases
pure func genAbstractChain(immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain)

ghost
requires len(certificateChain) > 0 && acc(&certificateChain[len(certificateChain)-1]) && acc(certificateChain[len(certificateChain)-1])
ensures certificateChain[len(certificateChain)-1].Subject.ToRDNSequence().String() == res.CA
ensures trustInfoDNSName == res.DNSName
decreases
pure func toAbstractCertificateChainInfo(certificateChain []*x509.Certificate, trustInfoDNSName string) (res AbstractCertificateChainInfo)

ghost
decreases
opaque
pure func validityOfCA(policy AbstractPolicy, info AbstractCertificateChainInfo) bool {
	return len(policy.AllowedCAs) == 0 || (exists k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) && info.CA == policy.AllowedCAs[k]) //info.CA in policy.AllowedCAs
}

ghost
requires idx <= len(policies)
decreases
opaque
pure func validAgainstAllPolicies(policies AbstractChain, info AbstractCertificateChainInfo, idx int) (res bool) {
	return forall k int :: {policies[k]} 0 <= k && k < idx ==> validityOfCA(policies[k], info) && validityOfDomain(policies[k], info)
}

ghost
requires acc(policy)
decreases
pure func abstractGetImmutablePolicyHash(policy *common.PolicyCertificate) (res string) {
	return let h := crypto.abstractComputeHashAsSigner(policy) in base64.StdEncoding.AbstractEncodeToString(h)
}

ghost
requires acc_policyCertificateChain(chain, policyDnsNameCache)
decreases
opaque
pure func getImmutableHashOfFirstCert(chain *PolicyCertificateChain, policyDnsNameCache dict[string][]string) (res string) {
	return unfolding acc_policyCertificateChain(chain, policyDnsNameCache) in unfolding acc_inj_chainCertificate(chain.PolicyCertificates[0], len(chain.PolicyCertificates) - 0 - 1, policyDnsNameCache, chain) in abstractGetImmutablePolicyHash(chain.PolicyCertificates[0]) 
}

ghost
requires acc_policyCertificateChain(chain, policyDnsNameCache)
decreases
opaque
pure func getAbstractChainFromChain(chain *PolicyCertificateChain, policyDnsNameCache dict[string][]string) AbstractChain {
	return unfolding acc_policyCertificateChain(chain, policyDnsNameCache) in toAbstractChainFromChain(chain.PolicyCertificates, policyDnsNameCache, chain)
}

ghost 
requires (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) && 
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	(forall str string :: {&immutablePolicyCache[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash) && ((immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) && immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache)) ==> immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires rootChain != nil ==> acc_policyCertificateChain(rootChain, policyDnsNameCache)
ensures (immutableHash == base64.StdEncoding.EncodeToString(nil) || !(immutableHash in domain(immutablePolicyCache))) ==> res == seq[AbstractPolicy]{}
ensures immutableHash != base64.StdEncoding.EncodeToString(nil) && (immutableHash in domain(immutablePolicyCache)) && rootChain != nil && immutableHash == getImmutableHashOfFirstCert(rootChain, policyDnsNameCache) ==> res == getAbstractChainFromChain(rootChain, policyDnsNameCache)
ensures immutableHash != base64.StdEncoding.EncodeToString(nil) && (immutableHash in domain(immutablePolicyCache)) && !(rootChain != nil && immutableHash == getImmutableHashOfFirstCert(rootChain, policyDnsNameCache)) ==> res == seq[AbstractPolicy]{getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache)} ++ abstractGetPolicyCertificateChainWithLatestTimestampInner(immutablePolicyCache[immutableHash].immutableIssuerHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)
decreases (immutableHash != base64.StdEncoding.EncodeToString(nil) && immutableHash in domain(immutablePolicyCache)) ? immutablePolicyCache[immutableHash].depth : 0
opaque
pure func abstractGetPolicyCertificateChainWithLatestTimestampInner(immutableHash string, rootChain *PolicyCertificateChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain) {
	return (immutableHash == base64.StdEncoding.EncodeToString(nil) || !(immutableHash in domain(immutablePolicyCache))) ? seq[AbstractPolicy]{} : (
		(rootChain != nil && immutableHash == getImmutableHashOfFirstCert(rootChain, policyDnsNameCache)) ? getAbstractChainFromChain(rootChain, policyDnsNameCache) : (
			seq[AbstractPolicy]{getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache)} ++ abstractGetPolicyCertificateChainWithLatestTimestampInner(immutablePolicyCache[immutableHash].immutableIssuerHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)))
}

ghost
requires (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) &&
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	(forall str string :: {&immutablePolicyCache[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash) && ((immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) && immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache)) ==> immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires rootChain != nil ==> acc_policyCertificateChain(rootChain, policyDnsNameCache)
opaque
decreases
pure func abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash string, rootChain *PolicyCertificateChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain){
	return abstractGetPolicyCertificateChainWithLatestTimestampInner(immutableHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)
}

/*
ghost
requires perms1 > 0
requires perms2 > 0
requires immutableHash != base64.StdEncoding.EncodeToString(nil) ==> immutableHash in domain(immutablePolicyCache)
preserves (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) &&
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	(forall str string :: {&immutablePolicyCache[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash) && (immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) ==> immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache) && immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
preserves PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache, perms2)
preserves rootChain != nil ==> acc_policyCertificateChain(rootChain, policyDnsNameCache, perms2)
ensures abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache, perms1) == abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache, perms2)
decreases 
func lemmaChainGenerationIndependentFromPerm(immutableHash string, rootChain *PolicyCertificateChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, perms1 perm, perms2 perm)*/

// time.Time{} is ZeroTime. Thus, to find the maximum we can just initially set maxTimestamp to time.Time{}
ghost
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k)
requires idx >= 0
ensures idx >= len(spcts) ==> res == maxTimestamp
ensures idx < len(spcts) ==> res == ((unfolding cache_SPCT(&spcts[idx], idx) in (spcts[idx].AddedTS.After(maxTimestamp))) ? findMaxSPCT(spcts, idx + 1, unfolding cache_SPCT(&spcts[idx], idx) in spcts[idx].AddedTS) : findMaxSPCT(spcts, idx + 1, maxTimestamp))
decreases len(spcts) - idx
opaque
pure func findMaxSPCT(spcts []common.SignedPolicyCertificateTimestamp, idx int, maxTimestamp time.Time) (res time.Time) {
	return idx >= len(spcts) ? maxTimestamp : ((unfolding cache_SPCT(&spcts[idx], idx) in (spcts[idx].AddedTS.After(maxTimestamp))) ? findMaxSPCT(spcts, idx + 1, unfolding cache_SPCT(&spcts[idx], idx) in spcts[idx].AddedTS) : findMaxSPCT(spcts, idx + 1, maxTimestamp))
}

ghost
requires forall k int :: {hashes[k]} 0 <= k && k < len(hashes) ==> hashes[k] in domain(policyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
ensures len(hashes) == 0 ==> res == minMaxPolicy
ensures len(hashes) != 0 ==> res == (let maxSPCT := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in (unfolding cache_policyHashes_policy(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache) in (unfolding cache_SPCTs(policyCache[hashes[0]].policy.SPCTs) in (findMaxSPCT(policyCache[hashes[0]].policy.SPCTs, 0, time.Time{})))) in (
		(isFirst || minMaxTimestamp.After(maxSPCT)) ? getMinMaxPolicyInner(hashes[1:], false, maxSPCT, unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache), immutablePolicyCache, policyCache, policyDnsNameCache) : getMinMaxPolicyInner(hashes[1:], false, minMaxTimestamp, minMaxPolicy, immutablePolicyCache, policyCache, policyDnsNameCache)))
decreases len(hashes)
opaque
pure func getMinMaxPolicyInner(hashes seq[string], isFirst bool, minMaxTimestamp time.Time, minMaxPolicy AbstractPolicy, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractPolicy) {
	return len(hashes) == 0 ? minMaxPolicy : (let maxSPCT := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in (unfolding cache_policyHashes_policy(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache) in (unfolding cache_SPCTs(policyCache[hashes[0]].policy.SPCTs) in (findMaxSPCT(policyCache[hashes[0]].policy.SPCTs, 0, time.Time{})))) in (
		(isFirst || minMaxTimestamp.After(maxSPCT)) ? getMinMaxPolicyInner(hashes[1:], false, maxSPCT, unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache), immutablePolicyCache, policyCache, policyDnsNameCache) : getMinMaxPolicyInner(hashes[1:], false, minMaxTimestamp, minMaxPolicy, immutablePolicyCache, policyCache, policyDnsNameCache)))
}	

ghost
requires immutableHash in domain(immutablePolicyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires acc(&immutablePolicyCache[immutableHash].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache)
decreases
opaque
pure func getMinMaxPolicy(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractPolicy) {
	return getMinMaxPolicyInner(unfolding ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache) in toSeq(immutablePolicyCache[immutableHash].policyHashes), true, time.Time{}, AbstractPolicy{}, immutablePolicyCache, policyCache, policyDnsNameCache)
}

ghost
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires domainVar in domain(policyDnsNameCache)
ensures len(res) == len(let c, _ := policyDnsNameCache[domainVar] in c)
ensures unfolding PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache) in (unfolding acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache) in (
	forall k int :: {res[k]} 0 <= k && k < len(res) ==> res[k] == unfolding ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache) in abstractGetPolicyCertificateChainWithLatestTimestamp(unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in (
		let hashes, _ := policyDnsNameCache[domainVar] in (
			unfolding PolicyCachePermissions_ImmutableHash(policyCache[hashes[k]].immutableHash, hashes[k], immutablePolicyCache) in policyCache[hashes[k]].immutableHash)), nil, immutablePolicyCache, policyCache, policyDnsNameCache)))
decreases
pure func abstractFindChain(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res seq[AbstractChain])

ghost
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache)
ensures len(chains) == len(res)
ensures forall k int :: {res[k]} 0 <= k && k < len(res) ==> unfolding acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache) in unfolding acc_policyCertificateChain(chains[k], policyDnsNameCache) in toAbstractChainFromChain(chains[k].PolicyCertificates, policyDnsNameCache, chains[k]) == res[k]
decreases
pure func toAbstractChains(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string) (res seq[AbstractChain])

ghost 
decreases
opaque
pure func validityOfDomain(policy AbstractPolicy, info AbstractCertificateChainInfo) bool {
	return let normDomain := normalizeDomainSpec(policy.Domain) in let polDomain := strings.GhostCutSuffix(normDomain, ".") in (let dns := strings.GhostCutSuffix(info.DNSName, ".") in (
		let subdomain := strings.GhostCutSuffix(dns, "."+polDomain) in (
			let subdomains := strings.GhostSplit(subdomain, ".") in (
				let target := subdomains[len(subdomains) - 1] in (
					(target in policy.AllowedSubdomains) || (
						!(target in policy.DisallowedSubdomains) && (target in policy.ExcludedSubdomains /* TODO IS THIS REALLY WHAT EXCLUDED IS FOR? */ || !("*" in policy.DisallowedSubdomains))))))))
}

ghost
requires idx >= 0
requires idx < len(policies)
ensures validAgainstAllPolicies(policies, info, idx) && validityOfCA(policies[idx], info) && validityOfDomain(policies[idx], info) ==> validAgainstAllPolicies(policies, info, idx + 1)
ensures !validAgainstAllPolicies(policies, info, idx) ==> !validAgainstAllPolicies(policies, info, idx + 1)
ensures validAgainstAllPolicies(policies, info, idx) && (!validityOfCA(policies[idx], info) || !validityOfDomain(policies[idx], info)) ==> !validAgainstAllPolicies(policies, info, idx + 1)
decreases
func lemmaValidAgainstAllPoliciesPlus1(policies AbstractChain, info AbstractCertificateChainInfo, idx int) {
	reveal validAgainstAllPolicies(policies, info, idx)
	reveal validAgainstAllPolicies(policies, info, idx + 1)
}

ghost
requires len(policy.AllowedCAs) > 0 && (forall k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) ==> policy.AllowedCAs[k] != info.CA)
ensures !validityOfCA(policy, info)
decreases
func lemmaNotValidAgainstCA(policy AbstractPolicy, info AbstractCertificateChainInfo) {
	reveal validityOfCA(policy, info)
}

ghost
requires len(policy.AllowedCAs) == 0 || (exists k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) && policy.AllowedCAs[k] == info.CA)
ensures validityOfCA(policy, info)
decreases
func lemmaValidAgainstCA(policy AbstractPolicy, info AbstractCertificateChainInfo) {
	reveal validityOfCA(policy, info)
}

ghost
requires len(policy.AllowedCAs) > 0 && (forall k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) ==> policy.AllowedCAs[k] != info.CA)
ensures !validityOfCA(policy, info)
decreases
func lemmaNotValidAgainstDomain(policy AbstractPolicy, info AbstractCertificateChainInfo) {
	reveal validityOfCA(policy, info)
}

/*ghost
requires len(abstractChain) == 0
ensures validAgainstAllPolicies(abstractChain, info, 0)
decreases
func lemmaEmptyConflictingPolicyAttributes(abstractChain AbstractChain, info common.AbstractCertificateChainInfo)
*/
ghost
ensures validAgainstAllPolicies(abstractChain, info, 0)
decreases
func lemmaCheckNoPolicy(abstractChain AbstractChain, info AbstractCertificateChainInfo) {
	reveal validAgainstAllPolicies(abstractChain, info, 0)
}

ghost 
requires perms > 0
requires acc(acc_inj_trustInfo_policy(policy, l), perms)
requires toAbstractPolicy(policy, l) == abstractPolicy
requires unfolding acc(acc_inj_trustInfo_policy(policy, l), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainAllowed)
ensures acc(acc_inj_trustInfo_policy(policy, l), perms)
ensures validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainAllowedValid(policy *common.PolicyCertificate, l int, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	reveal validityOfDomain(abstractPolicy, info)
}

ghost 
requires perms > 0
requires acc(acc_inj_trustInfo_policy(policy, l), perms)
requires toAbstractPolicy(policy, l) == abstractPolicy
requires unfolding acc(acc_inj_trustInfo_policy(policy, l), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainExcluded)
ensures acc(acc_inj_trustInfo_policy(policy, l), perms)
ensures validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainExcludedValid(policy *common.PolicyCertificate, l int, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	reveal validityOfDomain(abstractPolicy, info)
}

ghost 
requires perms > 0
requires acc(acc_inj_trustInfo_policy(policy, l), perms)
requires toAbstractPolicy(policy, l) == abstractPolicy
requires unfolding acc(acc_inj_trustInfo_policy(policy, l), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainDisallowed)
ensures acc(acc_inj_trustInfo_policy(policy, l), perms)
ensures !validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainDisallowedInvalid(policy *common.PolicyCertificate, l int, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	reveal validityOfDomain(abstractPolicy, info)
}
