package cache_v2

import (
	"crypto/x509"
    "fpki/pkg/common"
    "encoding/base64"
    "net/publicsuffix"
	"strings"
	"time"
	"fpki/pkg/common/crypto"
)

pred acc_leafHashes(hashes []string, str string, ghost policyCache dict[string]*PolicyCacheEntry) {
	//forall k int :: {hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k], _)
	forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k]) && hashes[k] in domain(policyCache)
}

pred cache_SPCT(spct *common.SignedPolicyCertificateTimestamp, l int) {
	acc(spct)
}

pred cache_SPCTs(arr []common.SignedPolicyCertificateTimestamp) {
	forall l int :: {&arr[l]} 0 <= l && l < len(arr) ==> cache_SPCT(&arr[l], l)
}

pred policy_IssuerHash(issuerHash []byte) {
	forall k int :: {&issuerHash[k]} 0 <= k && k < len(issuerHash) ==> acc(&issuerHash[k])
}

// If we include this directly in PolicyCachePermissions instead of putting it like this into a separate predicate it will not terminate upon a verification error after unfold
pred cache_policyHashes_policy(policy *common.PolicyCertificate, hash string, ghost policyDnsNameCache dict[string][]string) {
	acc(policy) && 
	policy.Domain() in domain(policyDnsNameCache) && cache_SPCTs(policy.SPCTs) && policy_IssuerHash(policy.IssuerHash) && acc_strs(policy.PolicyAttributes.AllowedCAs) && acc_strs(policy.PolicyAttributes.AllowedSubdomains) && acc_strs(policy.PolicyAttributes.DisallowedSubdomains) && acc_strs(policy.PolicyAttributes.ExcludedSubdomains)
}

pred ImmutablePolicyCachePermissions_policyHashes(hashes []string, immutableHash string, ghost policyCache dict[string]*PolicyCacheEntry) {
    len(hashes) > 0 && forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k]) && hashes[k] in domain(policyCache)
}

pred ImmutablePolicyCachePermissions_issuer(ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry) {
	(forall str string :: {&immutablePolicyCache[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash) && ((immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) && immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache)) ==> immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1))
}

pred ImmutablePolicyCachePermissions(ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, ghost policyCache dict[string]*PolicyCacheEntry) { 
    (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) && 
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
}

pred PolicyCachePermissions_ImmutableHash(immutableHash string, policyHash string, ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry) {
	immutableHash != base64.StdEncoding.EncodeToString(nil) && 
    immutableHash in domain(immutablePolicyCache) 
}

// Note: This pred used to have policy perms only for the cache_policyHashes_policy predicate. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred PolicyCachePermissions(ghost policyCache dict[string]*PolicyCacheEntry, ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, ghost policyDnsNameCache dict[string][]string) {
    forall str string :: {policyCache[str]} str in domain(policyCache) ==> 
    acc(policyCache[str]) && 
    PolicyCachePermissions_ImmutableHash(policyCache[str].immutableHash, str, immutablePolicyCache) && // We don't need these invariants in a lot of places -> put into separate predicate to not carry quantifier around
    cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache) //acc(policyCache[str].policy, perms) && cache_SPCTs(policyCache[str].policy.SPCTs, perms)
}

pred PolicyDnsNameCachePermissions(ghost policyDnsNameCache dict[string][]string, ghost policyCache dict[string]*PolicyCacheEntry) {
    forall str string :: {policyDnsNameCache[str]} str in domain(policyDnsNameCache) ==> let leafHashes, ok := policyDnsNameCache[str] in len(leafHashes) > 0 && acc_leafHashes(leafHashes, str, policyCache)
}

pred acc_strs(arr []string) {
	forall k int :: {&arr[k]} 0 <= k && k < len(arr) ==> acc(&arr[k])
}

pred acc_inj_chainCertificate(cert *common.PolicyCertificate, i int, ghost policyDnsNameCache dict[string][]string/*, chain *PolicyCertificateChain*/) {
	acc(cert) && cert.Domain() in domain(policyDnsNameCache) && cache_SPCTs(cert.SPCTs) && policy_IssuerHash(cert.IssuerHash) && acc_strs(cert.PolicyAttributes.AllowedCAs) && acc_strs(cert.PolicyAttributes.AllowedSubdomains) && acc_strs(cert.PolicyAttributes.DisallowedSubdomains) && acc_strs(cert.PolicyAttributes.ExcludedSubdomains)
}

// Note: This pred used to have policy perms only for the acc_inj_chainCertificate predicate. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred acc_policyCertificateChain(chain *PolicyCertificateChain, ghost policyDnsNameCache dict[string][]string) {
	acc(chain) &&
	len(chain.PolicyCertificates) >= 1 &&
	(forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc(&chain.PolicyCertificates[l])) &&
	(forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc_inj_chainCertificate(chain.PolicyCertificates[l], len(chain.PolicyCertificates) - l - 1, policyDnsNameCache/*, chain*/))// &&
	//chain.DomainRootIssuanceTimestamp == abstractGetDomainRootIssuanceTimestamp(toAbstractChainFromChain(chain.PolicyCertificates, policyDnsNameCache, chain)) && 
	//chain.DomainLatestMinMaxTimestamp == abstractGetDomainLatestMinMaxTimestamp(toAbstractChainFromChain(chain.PolicyCertificates, policyDnsNameCache, chain))
} 

pred acc_inj_policyCertificateChain(chain *PolicyCertificateChain, i int, ghost policyDnsNameCache dict[string][]string) {
	acc_policyCertificateChain(chain, policyDnsNameCache)
}

pred acc_inj_trustInfo_policy(policy *common.PolicyCertificate, i int) {
	acc(policy) && cache_SPCTs(policy.SPCTs) && policy_IssuerHash(policy.IssuerHash) && acc_strs(policy.PolicyAttributes.AllowedCAs) && acc_strs(policy.PolicyAttributes.AllowedSubdomains) && acc_strs(policy.PolicyAttributes.DisallowedSubdomains) && acc_strs(policy.PolicyAttributes.ExcludedSubdomains)
}

pred acc_policyAttributes(attr *common.PolicyAttributes) {
	acc(&attr.AllowedCAs) && acc(&attr.AllowedSubdomains) && acc(&attr.DisallowedSubdomains) && acc(&attr.ExcludedSubdomains) &&
	acc_strs(attr.AllowedCAs) &&
	acc_strs(attr.AllowedSubdomains) && 
	acc_strs(attr.DisallowedSubdomains) &&
	acc_strs(attr.ExcludedSubdomains)
}

pred acc_inj_trustInfo_conflictingPolicyAttributes_attr(attr *ConflictingPolicyAttribute, i int) {
	acc(attr) && acc_policyAttributes(attr.Attribute)
}

// Note: This pred used to have policy perms only for the acc_inj_trustInfo_policy and acc_inj_trustInfo_conflictingPolicyAttributes_attr predicates. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred acc_trustInfo(trustInfo *PolicyTrustInfo, ghost policyDnsNameCache dict[string][]string) {
	acc(trustInfo) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(&trustInfo.ConflictingPolicyAttributes[k])) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc_inj_trustInfo_conflictingPolicyAttributes_attr(trustInfo.ConflictingPolicyAttributes[k], k)) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(&trustInfo.PolicyChain[k])) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc_inj_trustInfo_policy(trustInfo.PolicyChain[k], k)) &&
	len(trustInfo.CertificateChain) > 0 && acc(&trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) && acc(trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) &&
	let e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName) in (e2ld in domain(policyDnsNameCache)) &&
	len(trustInfo.PolicyChain) >= 0
}

// --- | CORRECTNESS | ---

ghost type AbstractPolicy ghost struct {
	AllowedCAs seq[string]
	AllowedSubdomains seq[string]
	DisallowedSubdomains seq[string]
	ExcludedSubdomains seq[string]
	Domain string
	minMaxTimestamp time.Time
	immutableHash string
}

ghost type AbstractCertificateChainInfo ghost struct {
	CA string
	DNSName string
}


ghost type AbstractChain seq[AbstractPolicy]

// from Gobra tutorial at https://github.com/viperproject/gobra/blob/master/docs/tutorial.md
ghost
requires forall j int :: 0 <= j && j < len(s) ==> acc(&s[j])
ensures  len(res) == len(s)
ensures  forall j int :: {s[j]} {res[j]} 0 <= j && j < len(s) ==> s[j] == res[j]
decreases len(s)
opaque
pure func toSeq(s []string) (res seq[string]) {
	return (len(s) == 0 ? seq[string]{} :
		toSeq(s[:len(s)-1]) ++ seq[string]{s[len(s) - 1]})
}

ghost
requires acc_strs(s)
decreases
opaque
pure func strsToSeq(s []string) (res seq[string]) {
	return unfolding acc_strs(s) in toSeq(s)
}

ghost
requires cache_SPCTs(spcts)
decreases
opaque 
pure func unfoldAndFindMaxSPCT(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time) time.Time {
	return unfolding cache_SPCTs(spcts) in findMaxSPCT(spcts, policyTime, len(spcts), len(spcts))
}

ghost 
requires acc_inj_trustInfo_policy(policyCertificate, l)
decreases
//opaque
pure func toAbstractPolicy(policyCertificate *common.PolicyCertificate, l int) AbstractPolicy {
	return unfolding acc_inj_trustInfo_policy(policyCertificate, l) in toAbstractPolicyFromBlank(policyCertificate)/*(
		AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		minMaxTimestamp: unfoldAndFindMaxSPCT(policyCertificate.SPCTs, policyCertificate.TimeStamp),
		})*/
}

ghost
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc(&policyCertificates[l])
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc_inj_trustInfo_policy(policyCertificates[l], l)
ensures len(policyCertificates) == len(res)
ensures forall k int :: {res[k]} 0 <= k && k < len(policyCertificates) ==> res[k] == toAbstractPolicy(policyCertificates[k], k)
decreases
pure func toAbstractChain(policyCertificates []*common.PolicyCertificate) (res AbstractChain)

ghost 
requires cache_policyHashes_policy(policyCertificate, hash, policyDnsNameCache)
decreases
pure func toAbstractPolicyFromCache(policyCertificate *common.PolicyCertificate, hash string, policyDnsNameCache dict[string][]string) AbstractPolicy {
	return unfolding cache_policyHashes_policy(policyCertificate, hash, policyDnsNameCache) in toAbstractPolicyFromBlank(policyCertificate) /*(
		AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		minMaxTimestamp: unfoldAndFindMaxSPCT(policyCertificate.SPCTs, policyCertificate.TimeStamp),
		})*/
}

ghost 
requires acc_inj_chainCertificate(policyCertificate, l, policyDnsNameCache/*, chain*/)
decreases
pure func toAbstractPolicyFromChain(policyCertificate *common.PolicyCertificate, l int, policyDnsNameCache dict[string][]string, chain *PolicyCertificateChain) AbstractPolicy {
	return unfolding acc_inj_chainCertificate(policyCertificate, l, policyDnsNameCache/*, chain*/) in toAbstractPolicyFromBlank(policyCertificate)/*(
		AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		minMaxTimestamp: unfoldAndFindMaxSPCT(policyCertificate.SPCTs, policyCertificate.TimeStamp),
		})*/
}

ghost 
requires acc(policyCertificate)
requires acc_strs(policyCertificate.PolicyAttributes.AllowedCAs) 
requires acc_strs(policyCertificate.PolicyAttributes.AllowedSubdomains) 
requires acc_strs(policyCertificate.PolicyAttributes.DisallowedSubdomains)
requires acc_strs(policyCertificate.PolicyAttributes.ExcludedSubdomains)
requires cache_SPCTs(policyCertificate.SPCTs)
decreases
pure func toAbstractPolicyFromBlank(policyCertificate *common.PolicyCertificate) AbstractPolicy {
	return AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		minMaxTimestamp: unfoldAndFindMaxSPCT(policyCertificate.SPCTs, policyCertificate.TimeStamp),
		immutableHash: base64.StdEncoding.AbstractEncodeToString(crypto.abstractComputeHashAsSigner(policyCertificate)),
	}
}

ghost
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc(&policyCertificates[l])
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc_inj_chainCertificate(policyCertificates[l], len(policyCertificates) - l - 1, policyDnsNameCache/*, chain*/)
ensures len(policyCertificates) == len(res)
ensures forall k int :: {res[k]} 0 <= k && k < len(policyCertificates) ==> res[k] == toAbstractPolicyFromChain(policyCertificates[k], len(policyCertificates) - k - 1, policyDnsNameCache, chain)
decreases
pure func toAbstractChainFromChain(policyCertificates []*common.PolicyCertificate, policyDnsNameCache dict[string][]string, chain *PolicyCertificateChain) (res AbstractChain)

ghost
requires acc_inj_policyCertificateChain(chain, k, policyDnsNameCache)
decreases
opaque
pure func unfoldAndToAbstractChainFromChain(chain *PolicyCertificateChain, k int, policyDnsNameCache dict[string][]string) AbstractChain {
	return unfolding acc_inj_policyCertificateChain(chain, k, policyDnsNameCache) in unfoldAndToAbstractChainFromChain2(chain, policyDnsNameCache)
}

ghost 
requires acc_policyCertificateChain(chain, policyDnsNameCache)
decreases
opaque
pure func unfoldAndToAbstractChainFromChain2(chain *PolicyCertificateChain, policyDnsNameCache dict[string][]string) AbstractChain {
	return unfolding acc_policyCertificateChain(chain, policyDnsNameCache) in toAbstractChainFromChain(chain.PolicyCertificates, policyDnsNameCache, chain)
}

/*
ghost
requires perms > 0
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc(&policyCertificates[l])
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc_inj_trustInfo_policy(policyCertificates[l], l, perms)
ensures len(policyCertificates) == len(res)
ensures forall k int :: {res[k].Domain} 0 <= k && k < len(policyCertificates) ==> res[k].Domain == unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in policyCertificates[k].Domain()
ensures (forall k int :: {res[k].AllowedCAs} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.AllowedCAs, perms) in toSeq(policyCertificates[k].PolicyAttributes.AllowedCAs) == res[k].AllowedCAs)))
ensures (forall k int :: {res[k].AllowedSubdomains} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.AllowedSubdomains, perms) in toSeq(policyCertificates[k].PolicyAttributes.AllowedSubdomains) == res[k].AllowedSubdomains)))
ensures (forall k int :: {res[k].DisallowedSubdomains} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.DisallowedSubdomains, perms) in toSeq(policyCertificates[k].PolicyAttributes.DisallowedSubdomains) == res[k].DisallowedSubdomains)))
ensures (forall k int :: {res[k].ExcludedSubdomains} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.ExcludedSubdomains, perms) in toSeq(policyCertificates[k].PolicyAttributes.ExcludedSubdomains) == res[k].ExcludedSubdomains)))
decreases
pure func toAbstractChain(policyCertificates []*common.PolicyCertificate, perms perm) (res AbstractChain)*/

ghost
requires excl >= 1
requires excl <= len(subdomains)
decreases excl
opaque
pure func abstractGetSubdomainString(e2ld string, subdomains seq[string], excl int) string {
	return excl == 1 ? e2ld : (subdomains[len(subdomains) - 1 - (excl - 1)] + "." + abstractGetSubdomainString(e2ld, subdomains, excl - 1))
}

ghost 
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
decreases
opaque
pure func abstractFindPolicyCertificateChainForDomain(domainVar string, rootChain AbstractChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain) {
	return len(rootChain) == 0 ? seq[AbstractPolicy]{} : (let e2ld := rootChain[0].Domain in (
		let subdomainsStr := strings.GhostCutSuffix(domainVar, e2ld) in (
			let subdomains := strings.GhostSplit(subdomainsStr, ".") in (
				len(subdomains) < 1 ? seq[AbstractPolicy]{} : (let maxSubdomain := abstractGetSubdomainString(e2ld, subdomains, len(subdomains)) in (
					abstractGetNewestChainWithRootChain(maxSubdomain, len(e2ld), immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, abstractGetLeafHashesLen(maxSubdomain, policyDnsNameCache, policyCache))))))))
}


ghost 
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires publicsuffix.EffectiveTLDPlusOne(domainVar) in domain(policyDnsNameCache)
decreases
opaque
pure func genAbstractChain(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain) {
	return let rootChains := abstractFindChains(publicsuffix.EffectiveTLDPlusOne(domainVar), immutablePolicyCache, policyCache, policyDnsNameCache, len(let c, _ := policyDnsNameCache[publicsuffix.EffectiveTLDPlusOne(domainVar)] in c)) in (
		len(rootChains) == 0 ? seq[AbstractPolicy]{} : (let rootChain := abstractGetNewestChain(rootChains, len(rootChains)) in abstractFindPolicyCertificateChainForDomain(domainVar, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)))
}

ghost
requires len(certificateChain) > 0 && acc(&certificateChain[len(certificateChain)-1]) && acc(certificateChain[len(certificateChain)-1])
ensures certificateChain[len(certificateChain)-1].Subject.ToRDNSequence().String() == res.CA
ensures trustInfoDNSName == res.DNSName
decreases
pure func toAbstractCertificateChainInfo(certificateChain []*x509.Certificate, trustInfoDNSName string) (res AbstractCertificateChainInfo)

ghost
decreases
opaque
pure func validityOfCA(policy AbstractPolicy, info AbstractCertificateChainInfo) bool {
	return len(policy.AllowedCAs) == 0 || (exists k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) && info.CA == policy.AllowedCAs[k]) //info.CA in policy.AllowedCAs
}

ghost
requires idx <= len(policies)
decreases
opaque
pure func validAgainstAllPolicies(policies AbstractChain, info AbstractCertificateChainInfo, idx int) (res bool) {
	return forall k int :: {policies[k]} 0 <= k && k < idx ==> validityOfCA(policies[k], info) && validityOfDomain(policies[k], info)
}

ghost 
requires (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) && 
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
//requires rootChain != nil ==> acc_policyCertificateChain(rootChain, policyDnsNameCache)
ensures (immutableHash == base64.StdEncoding.EncodeToString(nil) || !(immutableHash in domain(immutablePolicyCache))) ==> res == seq[AbstractPolicy]{}
ensures immutableHash != base64.StdEncoding.EncodeToString(nil) && (immutableHash in domain(immutablePolicyCache)) && len(rootChain) != 0 && immutableHash == rootChain[0].immutableHash ==> res == rootChain
ensures immutableHash != base64.StdEncoding.EncodeToString(nil) && (immutableHash in domain(immutablePolicyCache)) && !(len(rootChain) != 0 && immutableHash == rootChain[0].immutableHash) ==> res == seq[AbstractPolicy]{unfolding ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache) in getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, len(immutablePolicyCache[immutableHash].policyHashes), len(immutablePolicyCache[immutableHash].policyHashes))} ++ abstractGetPolicyCertificateChainWithLatestTimestampInner(unfolding ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) in immutablePolicyCache[immutableHash].immutableIssuerHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)
decreases (immutableHash != base64.StdEncoding.EncodeToString(nil) && immutableHash in domain(immutablePolicyCache)) ? unfolding ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) in immutablePolicyCache[immutableHash].depth : 0
opaque
pure func abstractGetPolicyCertificateChainWithLatestTimestampInner(immutableHash string, rootChain AbstractChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain) {
	return (immutableHash == base64.StdEncoding.EncodeToString(nil) || !(immutableHash in domain(immutablePolicyCache))) ? seq[AbstractPolicy]{} : (
		(len(rootChain) != 0 && immutableHash == rootChain[0].immutableHash) ? rootChain : (
			seq[AbstractPolicy]{unfolding ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache) in getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, len(immutablePolicyCache[immutableHash].policyHashes), len(immutablePolicyCache[immutableHash].policyHashes))} ++ abstractGetPolicyCertificateChainWithLatestTimestampInner(unfolding ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) in immutablePolicyCache[immutableHash].immutableIssuerHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)))
}

ghost
requires (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) &&
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
opaque
decreases
pure func abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash string, rootChain AbstractChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain){
	return abstractGetPolicyCertificateChainWithLatestTimestampInner(immutableHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)
}

/*
ghost
requires perms1 > 0
requires perms2 > 0
requires immutableHash != base64.StdEncoding.EncodeToString(nil) ==> immutableHash in domain(immutablePolicyCache)
preserves (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) &&
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	(forall str string :: {&immutablePolicyCache[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash) && (immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) ==> immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache) && immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
preserves PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache, perms2)
preserves rootChain != nil ==> acc_policyCertificateChain(rootChain, policyDnsNameCache, perms2)
ensures abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache, perms1) == abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache, perms2)
decreases 
func lemmaChainGenerationIndependentFromPerm(immutableHash string, rootChain *PolicyCertificateChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, perms1 perm, perms2 perm)*/

/*
ghost
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k)
requires idx >= 0
requires excl <= len(spcts)
ensures idx >= excl ==> res == maxTimestamp
ensures idx < excl ==> res == findMaxSPCTInner(spcts, idx + 1, maxTime(unfolding cache_SPCT(&spcts[idx], idx) in spcts[idx].AddedTS, maxTimestamp), excl)
decreases len(spcts) - idx
opaque
pure func findMaxSPCTInner(spcts []common.SignedPolicyCertificateTimestamp, idx int, maxTimestamp time.Time, excl int) (res time.Time) {
	return idx >= excl ? maxTimestamp : findMaxSPCTInner(spcts, idx + 1, maxTime(unfolding cache_SPCT(&spcts[idx], idx) in spcts[idx].AddedTS, maxTimestamp), excl)
}

ghost 
requires excl <= len(spcts)
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k)
decreases 
opaque
pure func findMaxSPCT(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, excl int) (res time.Time) {
	return len(spcts) == 0 ? policyTime : findMaxSPCTInner(spcts, 0, policyTime, excl)
}*/

ghost
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k)
requires idx == excl - 1
requires excl > 0
requires excl <= len(spcts)
ensures res == unfoldAndMaxTime(findMaxSPCT(spcts, policyTime, excl - 1, idx), &spcts[excl-1], excl-1)
decreases excl, idx
opaque
pure func findMaxSPCTInner(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, excl int, idx int) (res time.Time) { // idx just to prove termination of findMaxSPCT
	return unfoldAndMaxTime(findMaxSPCT(spcts, policyTime, excl - 1, idx), &spcts[excl-1], excl-1)
}

ghost 
requires idx == excl
requires excl >= 0
requires excl <= len(spcts)
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k)
decreases idx, excl
opaque
pure func findMaxSPCT(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, excl int, idx int) (res time.Time) {
	return excl == 0 ? policyTime : findMaxSPCTInner(spcts, policyTime, excl, idx - 1) // idx just to prove termination
}


/*
ghost
requires forall k int :: {hashes[k]} 0 <= k && k < len(hashes) ==> hashes[k] in domain(policyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
ensures len(hashes) == 0 ==> res == minMaxPolicy
ensures len(hashes) != 0 ==> res == (let maxSPCT := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in (unfolding cache_policyHashes_policy(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache) in (unfolding cache_SPCTs(policyCache[hashes[0]].policy.SPCTs) in (findMaxSPCT(policyCache[hashes[0]].policy.SPCTs, policyCache[hashes[0]].policy.TimeStamp, len(policyCache[hashes[0]].policy.SPCTs), len(policyCache[hashes[0]].policy.SPCTs))))) in (
		(isFirst || minMaxTimestamp.After(maxSPCT)) ? getMinMaxPolicyInner(hashes[1:], false, maxSPCT, unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache), immutablePolicyCache, policyCache, policyDnsNameCache) : getMinMaxPolicyInner(hashes[1:], false, minMaxTimestamp, minMaxPolicy, immutablePolicyCache, policyCache, policyDnsNameCache)))
decreases len(hashes)
opaque
pure func getMinMaxPolicyInner(hashes seq[string], isFirst bool, minMaxTimestamp time.Time, minMaxPolicy AbstractPolicy, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractPolicy) {
	return len(hashes) == 0 ? minMaxPolicy : (let maxSPCT := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in (unfolding cache_policyHashes_policy(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache) in (unfolding cache_SPCTs(policyCache[hashes[0]].policy.SPCTs) in (findMaxSPCT(policyCache[hashes[0]].policy.SPCTs, policyCache[hashes[0]].policy.TimeStamp, len(policyCache[hashes[0]].policy.SPCTs), len(policyCache[hashes[0]].policy.SPCTs))))) in (
		(isFirst || minMaxTimestamp.After(maxSPCT)) ? getMinMaxPolicyInner(hashes[1:], false, maxSPCT, unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache), immutablePolicyCache, policyCache, policyDnsNameCache) : getMinMaxPolicyInner(hashes[1:], false, minMaxTimestamp, minMaxPolicy, immutablePolicyCache, policyCache, policyDnsNameCache)))
}	

ghost
requires immutableHash in domain(immutablePolicyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires acc(&immutablePolicyCache[immutableHash].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache)
decreases
opaque
pure func getMinMaxPolicy(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractPolicy) {
	return getMinMaxPolicyInner(unfolding ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache) in toSeq(immutablePolicyCache[immutableHash].policyHashes), true, time.Time{}, AbstractPolicy{}, immutablePolicyCache, policyCache, policyDnsNameCache)
}*/

ghost
requires idx == excl - 1
requires excl > 1
requires immutableHash in domain(immutablePolicyCache)
/*requires forall str string :: {policyCache[str]} str in domain(policyCache) ==> 
    acc(policyCache[str]) && 
    cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache)*/
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires acc(&immutablePolicyCache[immutableHash].policyHashes) && acc(immutablePolicyCache[immutableHash].policyHashes)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires excl <= len(immutablePolicyCache[immutableHash].policyHashes)
ensures res == let curr := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[excl - 1]].policy, immutablePolicyCache[immutableHash].policyHashes[excl - 1], policyDnsNameCache) in 
	let inner := getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, excl - 1, idx) in
	curr.minMaxTimestamp.Before(inner.minMaxTimestamp) ? curr : inner
decreases idx, excl
opaque
pure func getMinMaxPolicyInner(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, excl int, idx int) (res AbstractPolicy) {
	return let curr := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[excl - 1]].policy, immutablePolicyCache[immutableHash].policyHashes[excl - 1], policyDnsNameCache) in 
	let inner := getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, excl - 1, idx) in
	curr.minMaxTimestamp.Before(inner.minMaxTimestamp) ? curr : inner
}

/*
ghost
requires idx == excl
requires excl >= 1
requires immutableHash in domain(immutablePolicyCache)
requires forall str string :: {policyCache[str]} str in domain(policyCache) ==> 
    acc(policyCache[str]) && 
    cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache)
//requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires acc(&immutablePolicyCache[immutableHash].policyHashes) && acc(immutablePolicyCache[immutableHash].policyHashes)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires excl <= len(immutablePolicyCache[immutableHash].policyHashes)
decreases idx, excl
opaque
pure func getMinMaxPolicy1(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, excl int, idx int) (res AbstractPolicy) {
	return excl == 1 ? (toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy, immutablePolicyCache[immutableHash].policyHashes[0], policyDnsNameCache)) : getMinMaxPolicyInner(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, excl, idx - 1)
}*/

ghost
requires idx == excl
requires excl >= 1
requires immutableHash in domain(immutablePolicyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires acc(&immutablePolicyCache[immutableHash].policyHashes) && acc(immutablePolicyCache[immutableHash].policyHashes)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires excl <= len(immutablePolicyCache[immutableHash].policyHashes)
decreases idx, excl
opaque
pure func getMinMaxPolicy(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, excl int, idx int) (res AbstractPolicy) {
	return excl == 1 ? (unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy, immutablePolicyCache[immutableHash].policyHashes[0], policyDnsNameCache)) : getMinMaxPolicyInner(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, excl, idx - 1)
}

ghost 
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires hash in domain(policyCache)
decreases
opaque
pure func unfoldAndGetChain(hash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) AbstractChain {
	return unfolding ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache) in abstractGetPolicyCertificateChainWithLatestTimestamp(unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in (
			unfolding PolicyCachePermissions_ImmutableHash(policyCache[hash].immutableHash, hash, immutablePolicyCache) in policyCache[hash].immutableHash), seq[AbstractPolicy]{}, immutablePolicyCache, policyCache, policyDnsNameCache)
}

ghost
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires domainVar in domain(policyDnsNameCache)
requires idx >= 0
requires idx <= len(let c, _ := policyDnsNameCache[domainVar] in c)
ensures len(res) == idx
ensures unfolding PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache) in (unfolding acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache) in (
	forall k int :: {res[k]} 0 <= k && k < len(res) ==> res[k] == let hashes, _ := policyDnsNameCache[domainVar] in unfoldAndGetChain(hashes[k], immutablePolicyCache, policyCache, policyDnsNameCache)))
decreases
pure func abstractFindChainsInner(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int) (res seq[AbstractChain])

ghost
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires domainVar in domain(policyDnsNameCache)
requires idx >= 0
requires idx <= len(let c, _ := policyDnsNameCache[domainVar] in c)
ensures len(res) == idx
decreases
opaque
pure func abstractFindChains(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int) (res seq[AbstractChain]) {
	return abstractFindChainsInner(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
}

ghost
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache)
ensures len(chains) == len(res)
ensures forall k int :: {res[k]} {&chains[k]} 0 <= k && k < len(res) ==> (unfoldAndToAbstractChainFromChain(chains[k], k, policyDnsNameCache) == res[k])
decreases
pure func toAbstractChains(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string) (res seq[AbstractChain])

ghost
requires i >= 0 && i < len(chains)
requires forall k int :: {&chains[k]} i <= k && k < len(chains) ==> acc(&chains[k]) && acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache)
ensures len(chains) == len(res)
ensures forall k int :: {res[k]} {&chains[k]} i <= k && k < len(res) ==> (unfoldAndToAbstractChainFromChain(chains[k], k, policyDnsNameCache) == res[k])
decreases
pure func toAbstractChainsFrom(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string, i int) (res seq[AbstractChain])

ghost 
decreases
opaque
pure func validityOfDomain(policy AbstractPolicy, info AbstractCertificateChainInfo) bool {
	return let normDomain := normalizeDomainSpec(policy.Domain) in let polDomain := strings.GhostCutSuffix(normDomain, ".") in (let dns := strings.GhostCutSuffix(info.DNSName, ".") in (
		let subdomain := strings.GhostCutSuffix(dns, "."+polDomain) in (
			let subdomains := strings.GhostSplit(subdomain, ".") in (
				let target := subdomains[len(subdomains) - 1] in (
					(target in policy.AllowedSubdomains) || (
						!(target in policy.DisallowedSubdomains) && (target in policy.ExcludedSubdomains /* TODO IS THIS REALLY WHAT EXCLUDED IS FOR? */ || !("*" in policy.DisallowedSubdomains))))))))
}

// if implemented: fallback of chain generatoion is empty chain.
// functions that generate a chain must then check if empty, if so also return empty result (in the concrete method we return an error at this point anyway)
// this function and abstractGetDomainLatestMinMaxTimestamp must then require len(chain) > 0
ghost 
decreases
opaque
pure func abstractGetDomainRootIssuanceTimestamp(chain AbstractChain) time.Time 

ghost
requires 0 < excl
requires excl <= len(chains)
decreases excl
opaque
pure func abstractGetNewestChain(chains seq[AbstractChain], excl int) AbstractChain {
	return excl == 1 ? chains[excl - 1] : (abstractGetDomainRootIssuanceTimestamp(chains[excl-1]).After(abstractGetDomainRootIssuanceTimestamp(abstractGetNewestChain(chains, excl - 1))) ?
	 chains[excl-1] : abstractGetNewestChain(chains, excl - 1))
}

ghost
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires leafHash in domain(policyCache)
ensures immutableHash in domain(immutablePolicyCache)
decreases
opaque
pure func getImmutableHashFromLeafHash(leafHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (immutableHash string) {
	return unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in unfolding PolicyCachePermissions_ImmutableHash(policyCache[leafHash].immutableHash, leafHash, immutablePolicyCache) in policyCache[leafHash].immutableHash
}

ghost
decreases
opaque
pure func abstractGetDomainLatestMinMaxTimestamp(chain AbstractChain) time.Time

ghost 
requires idx >= 0
requires domainVar in domain(policyDnsNameCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires idx < abstractGetLeafHashesLen(domainVar, policyDnsNameCache, policyCache)
ensures res in domain(policyCache)
decreases
opaque
pure func abstractGetLeafHash(domainVar string, idx int, policyDnsNameCache dict[string][]string, policyCache dict[string]*PolicyCacheEntry) (res string) {
	return unfolding PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache) in (let lH := policyDnsNameCache[domainVar] in (unfolding acc_leafHashes(lH, domainVar, policyCache) in lH[idx]))
}

ghost 
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
ensures domainVar in domain(policyDnsNameCache) ==> res > 0
ensures !(domainVar in domain(policyDnsNameCache)) ==> res == 0
decreases
pure func abstractGetLeafHashesLen(domainVar string, policyDnsNameCache dict[string][]string, policyCache dict[string]*PolicyCacheEntry) (res int) {
	return domainVar in domain(policyDnsNameCache) ? (unfolding PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache) in (let lH := policyDnsNameCache[domainVar] in len(lH))) : 0
}

ghost
decreases
ensures len(parentDomain) < len(subdomain)
pure func abstractParentDomain(subdomain string) (parentDomain string)

ghost
//requires acc_policyCertificateChain(rootChain, policyDnsNameCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
//requires len(subdomain) >= e2ldLen
requires exclJ >= 0
//requires subdomain in domain(policyDnsNameCache) ==> (exclJ > 0 || len(subdomain) > e2ldLen)
requires subdomain in domain(policyDnsNameCache) ==> exclJ <= abstractGetLeafHashesLen(subdomain, policyDnsNameCache, policyCache)
requires exclJ > 0 ==> subdomain in domain(policyDnsNameCache)
decreases len(subdomain), exclJ
opaque
pure func abstractGetNewestChainWithRootChain(subdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, exclJ int) AbstractChain {
	return len(subdomain) <= e2ldLen && (!(subdomain in domain(policyDnsNameCache)) || exclJ < 1) ? seq[AbstractPolicy]{} : (
				exclJ < 1 ? (abstractGetNewestChainWithRootChain(abstractParentDomain(subdomain), e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, abstractParentDomain(subdomain) in domain(policyDnsNameCache) ? abstractGetLeafHashesLen(abstractParentDomain(subdomain), policyDnsNameCache, policyCache) : 0)) : (
				let rec := abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ - 1) in (
					let currChain := (unfolding ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache) in abstractGetPolicyCertificateChainWithLatestTimestamp(getImmutableHashFromLeafHash(abstractGetLeafHash(subdomain, exclJ - 1, policyDnsNameCache, policyCache), immutablePolicyCache, policyCache, policyDnsNameCache), rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)) in (len(rec) == 0 || abstractGetDomainLatestMinMaxTimestamp(currChain).After(abstractGetDomainLatestMinMaxTimestamp(rec)) ? currChain : rec))))
}

ghost
requires idx >= 0
requires idx < len(policies)
ensures validAgainstAllPolicies(policies, info, idx) && validityOfCA(policies[idx], info) && validityOfDomain(policies[idx], info) ==> validAgainstAllPolicies(policies, info, idx + 1)
ensures !validAgainstAllPolicies(policies, info, idx) ==> !validAgainstAllPolicies(policies, info, idx + 1)
ensures validAgainstAllPolicies(policies, info, idx) && (!validityOfCA(policies[idx], info) || !validityOfDomain(policies[idx], info)) ==> !validAgainstAllPolicies(policies, info, idx + 1)
decreases
func lemmaValidAgainstAllPoliciesPlus1(policies AbstractChain, info AbstractCertificateChainInfo, idx int) {
	reveal validAgainstAllPolicies(policies, info, idx)
	reveal validAgainstAllPolicies(policies, info, idx + 1)
}

ghost
requires len(policy.AllowedCAs) > 0 && (forall k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) ==> policy.AllowedCAs[k] != info.CA)
ensures !validityOfCA(policy, info)
decreases
func lemmaNotValidAgainstCA(policy AbstractPolicy, info AbstractCertificateChainInfo) {
	reveal validityOfCA(policy, info)
}

ghost
requires len(policy.AllowedCAs) == 0 || (exists k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) && policy.AllowedCAs[k] == info.CA)
ensures validityOfCA(policy, info)
decreases
func lemmaValidAgainstCA(policy AbstractPolicy, info AbstractCertificateChainInfo) {
	reveal validityOfCA(policy, info)
}

/*ghost
requires len(abstractChain) == 0
ensures validAgainstAllPolicies(abstractChain, info, 0)
decreases
func lemmaEmptyConflictingPolicyAttributes(abstractChain AbstractChain, info common.AbstractCertificateChainInfo)
*/
ghost
ensures validAgainstAllPolicies(abstractChain, info, 0)
decreases
func lemmaCheckNoPolicy(abstractChain AbstractChain, info AbstractCertificateChainInfo) {
	reveal validAgainstAllPolicies(abstractChain, info, 0)
}

ghost 
requires perms > 0
requires acc(acc_inj_trustInfo_policy(policy, l), perms)
requires toAbstractPolicy(policy, l) == abstractPolicy
requires unfolding acc(acc_inj_trustInfo_policy(policy, l), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainAllowed)
ensures acc(acc_inj_trustInfo_policy(policy, l), perms)
ensures validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainAllowedValid(policy *common.PolicyCertificate, l int, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	reveal validityOfDomain(abstractPolicy, info)
}

ghost 
requires perms > 0
requires acc(acc_inj_trustInfo_policy(policy, l), perms)
requires toAbstractPolicy(policy, l) == abstractPolicy
requires unfolding acc(acc_inj_trustInfo_policy(policy, l), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainExcluded)
ensures acc(acc_inj_trustInfo_policy(policy, l), perms)
ensures validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainExcludedValid(policy *common.PolicyCertificate, l int, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	reveal validityOfDomain(abstractPolicy, info)
}

ghost 
requires perms > 0
requires acc(acc_inj_trustInfo_policy(policy, l), perms)
requires toAbstractPolicy(policy, l) == abstractPolicy
requires unfolding acc(acc_inj_trustInfo_policy(policy, l), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainDisallowed)
ensures acc(acc_inj_trustInfo_policy(policy, l), perms)
ensures !validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainDisallowedInvalid(policy *common.PolicyCertificate, l int, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	reveal validityOfDomain(abstractPolicy, info)
}

ghost
requires perms > 0
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires domainVar in domain(policyDnsNameCache)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures domainVar in domain(policyDnsNameCache)
ensures seq[AbstractChain]{} == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, 0)
decreases
func lemmaFindAbstractChainsEmpty(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, perms perm) {
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, 0)
}

ghost 
requires idx >= 0
requires perms > 0
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires domainVar in domain(policyDnsNameCache)
requires idx < let c, _ := policyDnsNameCache[domainVar] in len(c)
requires idx < len(chains)
requires chains[:idx] == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
requires unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/8) in (let hashes, _ := policyDnsNameCache[domainVar] in len(hashes) > idx)
requires chains[idx] == unfoldAndGetChain(unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/8) in (let hashes, _ := policyDnsNameCache[domainVar] in hashes[idx]), immutablePolicyCache, policyCache, policyDnsNameCache)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures domainVar in domain(policyDnsNameCache)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures idx < let c, _ := policyDnsNameCache[domainVar] in len(c)
ensures chains[:idx + 1] == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1)
decreases
func lemmaFindAbstractChainsInduction(chains seq[AbstractChain], domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int, perms perm) {
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
	reveal unfoldAndGetChain(unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/8) in (let hashes, _ := policyDnsNameCache[domainVar] in hashes[idx]), immutablePolicyCache, policyCache, policyDnsNameCache)
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1)
}

/*
ghost
requires idx >= 0
requires perms > 0
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires domainVar in domain(policyDnsNameCache)
requires idx < let c, _ := policyDnsNameCache[domainVar] in len(c)
requires idx == len(chains) - 1
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
requires toAbstractChains(chains, policyDnsNameCache)[:idx] == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
//requires toAbstractChains(chains[:idx], policyDnsNameCache) == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
requires unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/4) in (let hashes, _ := policyDnsNameCache[domainVar] in len(hashes) > idx)
requires unfolding acc(acc_inj_policyCertificateChain(chains[idx], idx, policyDnsNameCache), perms) in unfolding acc(acc_policyCertificateChain(chains[idx], policyDnsNameCache), perms) in toAbstractChainFromChain(chains[idx].PolicyCertificates, policyDnsNameCache, chains[idx]) == unfoldAndGetChain(unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/4) in (let hashes, _ := policyDnsNameCache[domainVar] in hashes[idx]), immutablePolicyCache, policyCache, policyDnsNameCache)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures domainVar in domain(policyDnsNameCache)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures idx < let c, _ := policyDnsNameCache[domainVar] in len(c)
ensures forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
ensures toAbstractChains(chains, policyDnsNameCache) == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1)
decreases 
func lemmaFindAbstractChainsInduction(chains []*PolicyCertificateChain, domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int, perms perm) {
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
	reveal unfoldAndGetChain(unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/4) in (let hashes, _ := policyDnsNameCache[domainVar] in hashes[idx]), immutablePolicyCache, policyCache, policyDnsNameCache)
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1)
}*/

ghost 
requires perms > 0
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
ensures forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
ensures policyTime == findMaxSPCT(spcts, policyTime, 0, 0)
decreases
func lemmaFindMaxSPCTEmpty(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, perms perm) {
	reveal findMaxSPCT(spcts, policyTime, 0, 0)
}

ghost
requires cache_SPCT(t2, idx)
decreases
opaque
pure func unfoldAndMaxTime(t1 time.Time, t2 *common.SignedPolicyCertificateTimestamp, idx int) time.Time {
	return maxTime(t1, unfolding cache_SPCT(t2, idx) in t2.AddedTS)
}

ghost 
requires perms > 0
requires idx >= 0
requires idx < len(spcts)
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
requires currentMax == findMaxSPCT(spcts, policyTime, idx, idx)
ensures forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
ensures unfoldAndMaxTime(currentMax, &spcts[idx], idx) == findMaxSPCT(spcts, policyTime, idx + 1, idx + 1)
decreases
func lemmaFindMaxSPCTInduction(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, currentMax time.Time, idx int, perms perm) {
	reveal findMaxSPCT(spcts, policyTime, idx + 1, idx + 1)
}

/*ghost
requires perms > 0
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
ensures forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
ensures forall idx int :: {&chains[idx]} 0 < idx && idx <= len(chains) ==> toAbstractChains(chains[:idx], policyDnsNameCache) == toAbstractChains(chains, policyDnsNameCache)[:idx]
decreases
func lemmaHomomorphismOfAbstractChains(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string, perms perm) {

}*/

ghost 
requires perms > 0
requires cachePerms > 0 
requires immutableHash in domain(immutablePolicyCache)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
ensures forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
ensures len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures (unfolding acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy, immutablePolicyCache[immutableHash].policyHashes[0], policyDnsNameCache)) == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, 1, 1)
decreases
func lemmaGetMinMaxPolicyEmpty(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, perms perm, cachePerms perm) {
	reveal getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, 1, 1)
}

ghost 
requires perms > 0
requires cachePerms > 0 
requires immutableHash in domain(immutablePolicyCache)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires idx >= 1
requires idx < len(immutablePolicyCache[immutableHash].policyHashes)
requires currentPolicy == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx, idx)
requires let curr := unfolding acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[idx]].policy, immutablePolicyCache[immutableHash].policyHashes[idx], policyDnsNameCache) in
	curr.minMaxTimestamp.Before(currentPolicy.minMaxTimestamp)
requires len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
ensures forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
ensures idx < len(immutablePolicyCache[immutableHash].policyHashes)
ensures len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures (unfolding acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[idx]].policy, immutablePolicyCache[immutableHash].policyHashes[idx], policyDnsNameCache)) == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
decreases
func lemmaGetMinMaxPolicyInduction1(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, currentPolicy AbstractPolicy, idx int, perms perm, cachePerms perm) {
	reveal getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
}

ghost 
requires perms > 0
requires cachePerms > 0 
requires immutableHash in domain(immutablePolicyCache)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires idx >= 1
requires idx < len(immutablePolicyCache[immutableHash].policyHashes)
requires currentPolicy == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx, idx)
requires let curr := unfolding acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[idx]].policy, immutablePolicyCache[immutableHash].policyHashes[idx], policyDnsNameCache) in
	!curr.minMaxTimestamp.Before(currentPolicy.minMaxTimestamp)
requires len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
ensures forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
ensures idx < len(immutablePolicyCache[immutableHash].policyHashes)
ensures len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures currentPolicy == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
decreases
func lemmaGetMinMaxPolicyInduction2(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, currentPolicy AbstractPolicy, idx int, perms perm, cachePerms perm) {
	reveal getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
}

ghost
requires len(chains) > 0
ensures abstractGetNewestChain(chains, 1) == chains[0]
decreases
func lemmaGetNewestChainBaseCase(chains seq[AbstractChain]) {
	reveal abstractGetNewestChain(chains, 1)
}

ghost 
requires 0 < excl
requires excl < len(chains)
requires abstractGetNewestChain(chains, excl) == curr
requires abstractGetDomainRootIssuanceTimestamp(chains[excl]).After(abstractGetDomainRootIssuanceTimestamp(curr))
ensures abstractGetNewestChain(chains, excl + 1) == chains[excl]
decreases
func lemmaGetNewestChainInduction1(chains seq[AbstractChain], excl int, curr AbstractChain) {
	reveal abstractGetNewestChain(chains, excl + 1)
}

ghost 
requires 0 < excl
requires excl < len(chains)
requires abstractGetNewestChain(chains, excl) == curr
requires !abstractGetDomainRootIssuanceTimestamp(chains[excl]).After(abstractGetDomainRootIssuanceTimestamp(curr))
ensures abstractGetNewestChain(chains, excl + 1) == curr
decreases
func lemmaGetNewestChainInduction2(chains seq[AbstractChain], excl int, curr AbstractChain) {
	reveal abstractGetNewestChain(chains, excl + 1)
}

ghost 
requires perms > 0
requires len(subdomain) == e2ldLen
//requires acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
//ensures acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
ensures abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0) == seq[AbstractPolicy]{}
decreases
func abstractGetNewestChainWithRootChainBaseCase(subdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, perms perm)  {
	reveal abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0)
}

ghost 
requires perms > 0
requires e2ldLen <= len(subdomain)
requires exclJ >= 0
//requires acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
requires subdomain in domain(policyDnsNameCache)
requires exclJ < abstractGetLeafHashesLen(subdomain, policyDnsNameCache, policyCache)
requires abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ) == maxChain
requires len(maxChain) == 0 || abstractGetDomainLatestMinMaxTimestamp(unfolding acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8) in abstractGetPolicyCertificateChainWithLatestTimestamp(getImmutableHashFromLeafHash(abstractGetLeafHash(subdomain, exclJ, policyDnsNameCache, policyCache), immutablePolicyCache, policyCache, policyDnsNameCache), rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)).After(abstractGetDomainLatestMinMaxTimestamp(maxChain))
//ensures acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
ensures abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ + 1) == (unfolding acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8) in abstractGetPolicyCertificateChainWithLatestTimestamp(getImmutableHashFromLeafHash(abstractGetLeafHash(subdomain, exclJ, policyDnsNameCache, policyCache), immutablePolicyCache, policyCache, policyDnsNameCache), rootChain, immutablePolicyCache, policyCache, policyDnsNameCache))
decreases
func abstractGetNewestChainWithRootChainInduction1SameSubdomain(subdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, exclJ int, maxChain AbstractChain, perms perm)  {
	reveal abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ + 1)
}

ghost 
requires perms > 0
requires len(subdomain) >= e2ldLen
//requires acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
requires abstractParentDomain(nextSubdomain) == subdomain
requires abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, abstractGetLeafHashesLen(subdomain, policyDnsNameCache, policyCache)) == maxChain
requires len(nextSubdomain) > len(subdomain)
//ensures acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
ensures abstractGetNewestChainWithRootChain(nextSubdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0) == maxChain
decreases
func abstractGetNewestChainWithRootChainInductionNextSubdomain(subdomain string, nextSubdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, maxChain AbstractChain, perms perm)  {
	reveal abstractGetNewestChainWithRootChain(nextSubdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0)
}

ghost 
requires perms > 0
requires e2ldLen <= len(subdomain)
requires exclJ >= 0
//requires acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
requires subdomain in domain(policyDnsNameCache)
requires exclJ < abstractGetLeafHashesLen(subdomain, policyDnsNameCache, policyCache)
requires abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ) == maxChain
requires len(maxChain) != 0 && !abstractGetDomainLatestMinMaxTimestamp(unfolding acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8) in abstractGetPolicyCertificateChainWithLatestTimestamp(getImmutableHashFromLeafHash(abstractGetLeafHash(subdomain, exclJ, policyDnsNameCache, policyCache), immutablePolicyCache, policyCache, policyDnsNameCache), rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)).After(abstractGetDomainLatestMinMaxTimestamp(maxChain))
//ensures acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
ensures abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ + 1) == maxChain
decreases
func abstractGetNewestChainWithRootChainInduction2SameSubdomain(subdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, exclJ int, maxChain AbstractChain, perms perm)  {
	reveal abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ + 1)
}

ghost 
requires perms > 0
requires len(subdomain) >= e2ldLen
//requires acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
requires !(nextSubdomain in domain(policyDnsNameCache))
requires abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, abstractGetLeafHashesLen(subdomain, policyDnsNameCache, policyCache)) == maxChain
requires abstractParentDomain(nextSubdomain) == subdomain
//ensures acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
ensures abstractGetNewestChainWithRootChain(nextSubdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0) == maxChain
decreases
func abstractGetNewestChainWithRootChainSkip(subdomain string, nextSubdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, maxChain AbstractChain, perms perm)  {
	reveal abstractGetNewestChainWithRootChain(nextSubdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0)
}

ghost 
requires len(subdomains) > 0
ensures abstractGetSubdomainString(e2ld, subdomains, 1) == e2ld
decreases
func lemmaGetSubdomainStringBaseCase(e2ld string, subdomains seq[string]) {
	reveal abstractGetSubdomainString(e2ld, subdomains, 1)
}

ghost
requires idx >= 1
requires idx <= len(subdomains) - 1
requires abstractGetSubdomainString(e2ld, subdomains, idx) == currentStr
ensures abstractGetSubdomainString(e2ld, subdomains, idx + 1) == subdomains[len(subdomains) - 1 - idx] + "." + currentStr
decreases
func lemmaGetSubdomainStringInductionStep(e2ld string, subdomains seq[string], idx int, currentStr string) {
	reveal abstractGetSubdomainString(e2ld, subdomains, idx + 1)
}