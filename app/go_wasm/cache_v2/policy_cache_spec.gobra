package cache_v2

import (
    "fpki/pkg/common"
    "encoding/base64"
    "net/publicsuffix"
)

pred acc_leafHashes(hashes []string, str string) {
	//forall k int :: {hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k], _)
	forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k])
}

pred cache_SPCT(spct *common.SignedPolicyCertificateTimestamp, l int, ghost policyPerm perm) {
	policyPerm > 0 && acc(spct, policyPerm)
}

pred cache_SPCTs(arr []common.SignedPolicyCertificateTimestamp, ghost policyPerm perm) {
	policyPerm > 0 && forall l int :: {&arr[l]} 0 <= l && l < len(arr) ==> cache_SPCT(&arr[l], l, policyPerm)
}

pred policy_IssuerHash(issuerHash []byte, ghost policyPerm perm) {
	policyPerm > 0 && forall k int :: {&issuerHash[k]} 0 <= k && k < len(issuerHash) ==> acc(&issuerHash[k], policyPerm)
}

// If we include this directly in PolicyCachePermissions instead of putting it like this into a separate predicate it will not terminate upon a verification error after unfold
pred cache_policyHashes_policy(policy *common.PolicyCertificate, hash string, ghost policyDnsNameCache dict[string][]string, ghost policyPerm perm) {
	policyPerm > 0 &&
	acc(policy, policyPerm) && 
	policy.Domain() in domain(policyDnsNameCache) && cache_SPCTs(policy.SPCTs, policyPerm) && policy_IssuerHash(policy.IssuerHash, policyPerm) && acc_strs(policy.PolicyAttributes.AllowedCAs, policyPerm) && acc_strs(policy.PolicyAttributes.AllowedSubdomains, policyPerm) && acc_strs(policy.PolicyAttributes.DisallowedSubdomains, policyPerm) && acc_strs(policy.PolicyAttributes.ExcludedSubdomains, policyPerm)
}

pred ImmutablePolicyCachePermissions_policyHashes(hashes []string, immutableHash string, ghost policyCache dict[string]*PolicyCacheEntry) {
    len(hashes) > 0 && forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k]) && hashes[k] in domain(policyCache)
}

pred ImmutablePolicyCachePermissions(ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, ghost policyCache dict[string]*PolicyCacheEntry, ghost cachePerms perm) { // cachePerms only relevant for issuerHash to prove that it doesn't change upon recursion
    cachePerms > 0 && 
    (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) &&  // dict needed in trigger to make sure that gobra generates a valid trigger!
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash, cachePerms)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
}

pred PolicyCachePermissions_ImmutableHash(immutableHash string, policyHash string, ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry) {
	immutableHash != base64.StdEncoding.EncodeToString(nil) && 
    immutableHash in domain(immutablePolicyCache) 
}

pred PolicyCachePermissions(ghost policyCache dict[string]*PolicyCacheEntry, ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, ghost policyDnsNameCache dict[string][]string, ghost perms perm) {
    perms > 0 &&
    forall str string :: {policyCache[str]} str in domain(policyCache) ==> 
    acc(policyCache[str]) && 
    PolicyCachePermissions_ImmutableHash(policyCache[str].immutableHash, str, immutablePolicyCache) && // We don't need these invariants in a lot of places -> put into separate predicate to not carry quantifier around
    cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache, perms) //acc(policyCache[str].policy, perms) && cache_SPCTs(policyCache[str].policy.SPCTs, perms)
}

pred PolicyDnsNameCachePermissions(ghost policyDnsNameCache dict[string][]string) {
    forall str string :: {policyDnsNameCache[str]} str in domain(policyDnsNameCache) ==> let leafHashes, ok := policyDnsNameCache[str] in len(leafHashes) > 0 && acc_leafHashes(leafHashes, str)
}

pred acc_strs(arr []string, policyPerms perm) {
	policyPerms > 0 &&
	forall k int :: {&arr[k]} 0 <= k && k < len(arr) ==> acc(&arr[k], policyPerms)
}

pred acc_inj_chainCertificate(cert *common.PolicyCertificate, i int, ghost policyDnsNameCache dict[string][]string, ghost policyPerm perm, chain *PolicyCertificateChain) { // chain s.t. we do not have issues to folding the cert twice for two chains
	policyPerm > 0 && acc(cert, policyPerm) && cert.Domain() in domain(policyDnsNameCache) && cache_SPCTs(cert.SPCTs, policyPerm) && policy_IssuerHash(cert.IssuerHash, policyPerm) && acc_strs(cert.PolicyAttributes.AllowedCAs, policyPerm) && acc_strs(cert.PolicyAttributes.AllowedSubdomains, policyPerm) && acc_strs(cert.PolicyAttributes.DisallowedSubdomains, policyPerm) && acc_strs(cert.PolicyAttributes.ExcludedSubdomains, policyPerm)
}

pred acc_policyCertificateChain(chain *PolicyCertificateChain, ghost policyDnsNameCache dict[string][]string, ghost perms perm) {
	acc(chain) &&
	len(chain.PolicyCertificates) >= 1 &&
	(forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc(&chain.PolicyCertificates[l])) &&
	(forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc_inj_chainCertificate(chain.PolicyCertificates[l], len(chain.PolicyCertificates) - l - 1, policyDnsNameCache, perms, chain)) 
	//unfolding acc_inj_chainCertificate(chain.PolicyCertificates[0], len(chain.PolicyCertificates) - 0 - 1, perms, chain) in chain.PolicyCertificates[0].Domain() in domain(policyDnsNameCache) // needed s.t. inner loop in findPolicyCertificateChainForDomain executes at least once and res is set
} 

pred acc_inj_policyCertificateChain(chain *PolicyCertificateChain, i int, ghost policyDnsNameCache dict[string][]string, ghost perms perm) {
	acc_policyCertificateChain(chain, policyDnsNameCache, perms)
}

pred acc_inj_trustInfo_policy(policy *common.PolicyCertificate, i int, ghost perms perm) {
	perms > 0 && acc(policy, perms) && cache_SPCTs(policy.SPCTs, perms) && policy_IssuerHash(policy.IssuerHash, perms) && acc_strs(policy.PolicyAttributes.AllowedCAs, perms) && acc_strs(policy.PolicyAttributes.AllowedSubdomains, perms) && acc_strs(policy.PolicyAttributes.DisallowedSubdomains, perms) && acc_strs(policy.PolicyAttributes.ExcludedSubdomains, perms)
}

pred acc_policyAttributes(attr *common.PolicyAttributes, ghost perms perm) {
	perms > 0 && 
	acc(&attr.AllowedCAs) && acc(&attr.AllowedSubdomains) && acc(&attr.DisallowedSubdomains) && acc(&attr.ExcludedSubdomains) &&
	acc_strs(attr.AllowedCAs, perms) &&
	acc_strs(attr.AllowedSubdomains, perms) && 
	acc_strs(attr.DisallowedSubdomains, perms) &&
	acc_strs(attr.ExcludedSubdomains, perms)
}

pred acc_inj_trustInfo_conflictingPolicyAttributes_attr(attr *ConflictingPolicyAttribute, i int, ghost perms perm) {
	acc(attr) && acc_policyAttributes(attr.Attribute, perms)
}

pred acc_trustInfo(trustInfo *PolicyTrustInfo, ghost policyDnsNameCache dict[string][]string, ghost perms perm) {
	acc(trustInfo) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(&trustInfo.ConflictingPolicyAttributes[k])) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc_inj_trustInfo_conflictingPolicyAttributes_attr(trustInfo.ConflictingPolicyAttributes[k], k, perms)) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(&trustInfo.PolicyChain[k])) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc_inj_trustInfo_policy(trustInfo.PolicyChain[k], k, perms)) &&
	len(trustInfo.CertificateChain) > 0 && acc(&trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) && acc(trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) &&
	let e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName) in (e2ld in domain(policyDnsNameCache)) &&
	len(trustInfo.PolicyChain) >= 0
}

