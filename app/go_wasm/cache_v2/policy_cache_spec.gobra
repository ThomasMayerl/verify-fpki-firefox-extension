package cache_v2

import (
	"crypto/x509"
    "fpki/pkg/common"
    "encoding/base64"
    "net/publicsuffix"
	"strings"
	"time"
	"fpki/pkg/common/crypto"
)

pred acc_leafHashes(hashes []string, str string, ghost policyCache dict[string]*PolicyCacheEntry) {
	//forall k int :: {hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k], _)
	forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k]) && hashes[k] in domain(policyCache)
}

pred cache_SPCT(spct *common.SignedPolicyCertificateTimestamp, l int) {
	acc(spct)
}

pred cache_SPCTs(arr []common.SignedPolicyCertificateTimestamp) {
	forall l int :: {&arr[l]} 0 <= l && l < len(arr) ==> cache_SPCT(&arr[l], l)
}

pred policy_IssuerHash(issuerHash []byte) {
	forall k int :: {&issuerHash[k]} 0 <= k && k < len(issuerHash) ==> acc(&issuerHash[k])
}

// If we include this directly in PolicyCachePermissions instead of putting it like this into a separate predicate it will not terminate upon a verification error after unfold
pred cache_policyHashes_policy(policy *common.PolicyCertificate, hash string, ghost policyDnsNameCache dict[string][]string) {
	acc(policy) && 
	policy.Domain() in domain(policyDnsNameCache) && cache_SPCTs(policy.SPCTs) && policy_IssuerHash(policy.IssuerHash) && acc_strs(policy.PolicyAttributes.AllowedCAs) && acc_strs(policy.PolicyAttributes.AllowedSubdomains) && acc_strs(policy.PolicyAttributes.DisallowedSubdomains) && acc_strs(policy.PolicyAttributes.ExcludedSubdomains)
}

pred ImmutablePolicyCachePermissions_policyHashes(hashes []string, immutableHash string, ghost policyCache dict[string]*PolicyCacheEntry) {
    len(hashes) > 0 && forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k]) && hashes[k] in domain(policyCache)
}

pred ImmutablePolicyCachePermissions(ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, ghost policyCache dict[string]*PolicyCacheEntry) { 
    (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) && 
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	(forall str string :: {&immutablePolicyCache[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash) && ((immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) && immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache)) ==> immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
}

pred PolicyCachePermissions_ImmutableHash(immutableHash string, policyHash string, ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry) {
	immutableHash != base64.StdEncoding.EncodeToString(nil) && 
    immutableHash in domain(immutablePolicyCache) 
}

// Note: This pred used to have policy perms only for the cache_policyHashes_policy predicate. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred PolicyCachePermissions(ghost policyCache dict[string]*PolicyCacheEntry, ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, ghost policyDnsNameCache dict[string][]string) {
    forall str string :: {policyCache[str]} str in domain(policyCache) ==> 
    acc(policyCache[str]) && 
    PolicyCachePermissions_ImmutableHash(policyCache[str].immutableHash, str, immutablePolicyCache) && // We don't need these invariants in a lot of places -> put into separate predicate to not carry quantifier around
    cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache) //acc(policyCache[str].policy, perms) && cache_SPCTs(policyCache[str].policy.SPCTs, perms)
}

pred PolicyDnsNameCachePermissions(ghost policyDnsNameCache dict[string][]string, ghost policyCache dict[string]*PolicyCacheEntry) {
    forall str string :: {policyDnsNameCache[str]} str in domain(policyDnsNameCache) ==> let leafHashes, ok := policyDnsNameCache[str] in len(leafHashes) > 0 && acc_leafHashes(leafHashes, str, policyCache)
}

pred acc_strs(arr []string) {
	forall k int :: {&arr[k]} 0 <= k && k < len(arr) ==> acc(&arr[k])
}

pred acc_inj_chainCertificate(cert *common.PolicyCertificate, i int, ghost policyDnsNameCache dict[string][]string, chain *PolicyCertificateChain) { // chain s.t. we do not have issues to folding the cert twice for two chains
	acc(cert) && cert.Domain() in domain(policyDnsNameCache) && cache_SPCTs(cert.SPCTs) && policy_IssuerHash(cert.IssuerHash) && acc_strs(cert.PolicyAttributes.AllowedCAs) && acc_strs(cert.PolicyAttributes.AllowedSubdomains) && acc_strs(cert.PolicyAttributes.DisallowedSubdomains) && acc_strs(cert.PolicyAttributes.ExcludedSubdomains)
}

// Note: This pred used to have policy perms only for the acc_inj_chainCertificate predicate. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred acc_policyCertificateChain(chain *PolicyCertificateChain, ghost policyDnsNameCache dict[string][]string) {
	acc(chain) &&
	len(chain.PolicyCertificates) >= 1 &&
	(forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc(&chain.PolicyCertificates[l])) &&
	(forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc_inj_chainCertificate(chain.PolicyCertificates[l], len(chain.PolicyCertificates) - l - 1, policyDnsNameCache, chain)) 
	//unfolding acc_inj_chainCertificate(chain.PolicyCertificates[0], len(chain.PolicyCertificates) - 0 - 1, perms, chain) in chain.PolicyCertificates[0].Domain() in domain(policyDnsNameCache) // needed s.t. inner loop in findPolicyCertificateChainForDomain executes at least once and res is set
} 

pred acc_inj_policyCertificateChain(chain *PolicyCertificateChain, i int, ghost policyDnsNameCache dict[string][]string) {
	acc_policyCertificateChain(chain, policyDnsNameCache)
}

pred acc_inj_trustInfo_policy(policy *common.PolicyCertificate, i int) {
	acc(policy) && cache_SPCTs(policy.SPCTs) && policy_IssuerHash(policy.IssuerHash) && acc_strs(policy.PolicyAttributes.AllowedCAs) && acc_strs(policy.PolicyAttributes.AllowedSubdomains) && acc_strs(policy.PolicyAttributes.DisallowedSubdomains) && acc_strs(policy.PolicyAttributes.ExcludedSubdomains)
}

pred acc_policyAttributes(attr *common.PolicyAttributes) {
	acc(&attr.AllowedCAs) && acc(&attr.AllowedSubdomains) && acc(&attr.DisallowedSubdomains) && acc(&attr.ExcludedSubdomains) &&
	acc_strs(attr.AllowedCAs) &&
	acc_strs(attr.AllowedSubdomains) && 
	acc_strs(attr.DisallowedSubdomains) &&
	acc_strs(attr.ExcludedSubdomains)
}

pred acc_inj_trustInfo_conflictingPolicyAttributes_attr(attr *ConflictingPolicyAttribute, i int) {
	acc(attr) && acc_policyAttributes(attr.Attribute)
}

// Note: This pred used to have policy perms only for the acc_inj_trustInfo_policy and acc_inj_trustInfo_conflictingPolicyAttributes_attr predicates. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred acc_trustInfo(trustInfo *PolicyTrustInfo, ghost policyDnsNameCache dict[string][]string) {
	acc(trustInfo) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(&trustInfo.ConflictingPolicyAttributes[k])) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc_inj_trustInfo_conflictingPolicyAttributes_attr(trustInfo.ConflictingPolicyAttributes[k], k)) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(&trustInfo.PolicyChain[k])) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc_inj_trustInfo_policy(trustInfo.PolicyChain[k], k)) &&
	len(trustInfo.CertificateChain) > 0 && acc(&trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) && acc(trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) &&
	let e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName) in (e2ld in domain(policyDnsNameCache)) &&
	len(trustInfo.PolicyChain) >= 0
}

// --- | CORRECTNESS | ---

ghost type AbstractPolicy ghost struct {
	AllowedCAs seq[string]
	AllowedSubdomains seq[string]
	DisallowedSubdomains seq[string]
	ExcludedSubdomains seq[string]
	Domain string
	minMaxTimestamp time.Time
}

ghost type AbstractCertificateChainInfo ghost struct {
	CA string
	DNSName string
}


ghost type AbstractChain seq[AbstractPolicy]

// from Gobra tutorial at https://github.com/viperproject/gobra/blob/master/docs/tutorial.md
ghost
requires forall j int :: 0 <= j && j < len(s) ==> acc(&s[j])
ensures  len(res) == len(s)
ensures  forall j int :: {s[j]} {res[j]} 0 <= j && j < len(s) ==> s[j] == res[j]
decreases len(s)
opaque
pure func toSeq(s []string) (res seq[string]) {
	return (len(s) == 0 ? seq[string]{} :
		toSeq(s[:len(s)-1]) ++ seq[string]{s[len(s) - 1]})
}

ghost
requires acc_strs(s)
decreases
opaque
pure func strsToSeq(s []string) (res seq[string]) {
	return unfolding acc_strs(s) in toSeq(s)
}

ghost
requires cache_SPCTs(spcts)
decreases
opaque 
pure func unfoldAndFindMaxSPCT(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time) time.Time {
	return unfolding cache_SPCTs(spcts) in findMaxSPCT(spcts, policyTime, len(spcts), len(spcts))
}

ghost 
requires acc_inj_trustInfo_policy(policyCertificate, l)
decreases
//opaque
pure func toAbstractPolicy(policyCertificate *common.PolicyCertificate, l int) AbstractPolicy {
	return unfolding acc_inj_trustInfo_policy(policyCertificate, l) in (
		AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		minMaxTimestamp: unfoldAndFindMaxSPCT(policyCertificate.SPCTs, policyCertificate.TimeStamp),
		})
}

ghost
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc(&policyCertificates[l])
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc_inj_trustInfo_policy(policyCertificates[l], l)
ensures len(policyCertificates) == len(res)
ensures forall k int :: {res[k]} 0 <= k && k < len(policyCertificates) ==> res[k] == toAbstractPolicy(policyCertificates[k], k)
decreases
pure func toAbstractChain(policyCertificates []*common.PolicyCertificate) (res AbstractChain)

ghost 
requires cache_policyHashes_policy(policyCertificate, hash, policyDnsNameCache)
decreases
pure func toAbstractPolicyFromCache(policyCertificate *common.PolicyCertificate, hash string, policyDnsNameCache dict[string][]string) AbstractPolicy {
	return unfolding cache_policyHashes_policy(policyCertificate, hash, policyDnsNameCache) in (
		AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		minMaxTimestamp: unfoldAndFindMaxSPCT(policyCertificate.SPCTs, policyCertificate.TimeStamp),
		})
}

ghost 
requires acc_inj_chainCertificate(policyCertificate, l, policyDnsNameCache, chain)
decreases
pure func toAbstractPolicyFromChain(policyCertificate *common.PolicyCertificate, l int, policyDnsNameCache dict[string][]string, chain *PolicyCertificateChain) AbstractPolicy {
	return unfolding acc_inj_chainCertificate(policyCertificate, l, policyDnsNameCache, chain) in (
		AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		minMaxTimestamp: unfoldAndFindMaxSPCT(policyCertificate.SPCTs, policyCertificate.TimeStamp),
		})
}

ghost 
requires acc(policyCertificate)
requires acc_strs(policyCertificate.PolicyAttributes.AllowedCAs) 
requires acc_strs(policyCertificate.PolicyAttributes.AllowedSubdomains) 
requires acc_strs(policyCertificate.PolicyAttributes.DisallowedSubdomains)
requires acc_strs(policyCertificate.PolicyAttributes.ExcludedSubdomains)
requires cache_SPCTs(policyCertificate.SPCTs)
decreases
pure func toAbstractPolicyFromBlank(policyCertificate *common.PolicyCertificate) AbstractPolicy {
	return AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		minMaxTimestamp: unfoldAndFindMaxSPCT(policyCertificate.SPCTs, policyCertificate.TimeStamp),
		}
}

ghost
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc(&policyCertificates[l])
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc_inj_chainCertificate(policyCertificates[l], len(policyCertificates) - l - 1, policyDnsNameCache, chain)
ensures len(policyCertificates) == len(res)
ensures forall k int :: {res[k]} 0 <= k && k < len(policyCertificates) ==> res[k] == toAbstractPolicyFromChain(policyCertificates[k], len(policyCertificates) - k - 1, policyDnsNameCache, chain)
decreases
pure func toAbstractChainFromChain(policyCertificates []*common.PolicyCertificate, policyDnsNameCache dict[string][]string, chain *PolicyCertificateChain) (res AbstractChain)

ghost
requires acc_inj_policyCertificateChain(chain, k, policyDnsNameCache)
decreases
opaque
pure func unfoldAndToAbstractChainFromChain(chain *PolicyCertificateChain, k int, policyDnsNameCache dict[string][]string) AbstractChain {
	return unfolding acc_inj_policyCertificateChain(chain, k, policyDnsNameCache) in unfolding acc_policyCertificateChain(chain, policyDnsNameCache) in toAbstractChainFromChain(chain.PolicyCertificates, policyDnsNameCache, chain)
}

/*
ghost
requires perms > 0
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc(&policyCertificates[l])
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc_inj_trustInfo_policy(policyCertificates[l], l, perms)
ensures len(policyCertificates) == len(res)
ensures forall k int :: {res[k].Domain} 0 <= k && k < len(policyCertificates) ==> res[k].Domain == unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in policyCertificates[k].Domain()
ensures (forall k int :: {res[k].AllowedCAs} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.AllowedCAs, perms) in toSeq(policyCertificates[k].PolicyAttributes.AllowedCAs) == res[k].AllowedCAs)))
ensures (forall k int :: {res[k].AllowedSubdomains} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.AllowedSubdomains, perms) in toSeq(policyCertificates[k].PolicyAttributes.AllowedSubdomains) == res[k].AllowedSubdomains)))
ensures (forall k int :: {res[k].DisallowedSubdomains} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.DisallowedSubdomains, perms) in toSeq(policyCertificates[k].PolicyAttributes.DisallowedSubdomains) == res[k].DisallowedSubdomains)))
ensures (forall k int :: {res[k].ExcludedSubdomains} 0 <= k && k < len(policyCertificates) ==> 
	unfolding acc_inj_trustInfo_policy(policyCertificates[k], k, perms) in (
		(unfolding acc_strs(policyCertificates[k].PolicyAttributes.ExcludedSubdomains, perms) in toSeq(policyCertificates[k].PolicyAttributes.ExcludedSubdomains) == res[k].ExcludedSubdomains)))
decreases
pure func toAbstractChain(policyCertificates []*common.PolicyCertificate, perms perm) (res AbstractChain)*/



ghost 
decreases
pure func genAbstractChain(immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain)

ghost
requires len(certificateChain) > 0 && acc(&certificateChain[len(certificateChain)-1]) && acc(certificateChain[len(certificateChain)-1])
ensures certificateChain[len(certificateChain)-1].Subject.ToRDNSequence().String() == res.CA
ensures trustInfoDNSName == res.DNSName
decreases
pure func toAbstractCertificateChainInfo(certificateChain []*x509.Certificate, trustInfoDNSName string) (res AbstractCertificateChainInfo)

ghost
decreases
opaque
pure func validityOfCA(policy AbstractPolicy, info AbstractCertificateChainInfo) bool {
	return len(policy.AllowedCAs) == 0 || (exists k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) && info.CA == policy.AllowedCAs[k]) //info.CA in policy.AllowedCAs
}

ghost
requires idx <= len(policies)
decreases
opaque
pure func validAgainstAllPolicies(policies AbstractChain, info AbstractCertificateChainInfo, idx int) (res bool) {
	return forall k int :: {policies[k]} 0 <= k && k < idx ==> validityOfCA(policies[k], info) && validityOfDomain(policies[k], info)
}

ghost
requires acc(policy)
decreases
pure func abstractGetImmutablePolicyHash(policy *common.PolicyCertificate) (res string) {
	return let h := crypto.abstractComputeHashAsSigner(policy) in base64.StdEncoding.AbstractEncodeToString(h)
}

ghost
requires acc_policyCertificateChain(chain, policyDnsNameCache)
decreases
opaque
pure func getImmutableHashOfFirstCert(chain *PolicyCertificateChain, policyDnsNameCache dict[string][]string) (res string) {
	return unfolding acc_policyCertificateChain(chain, policyDnsNameCache) in unfolding acc_inj_chainCertificate(chain.PolicyCertificates[0], len(chain.PolicyCertificates) - 0 - 1, policyDnsNameCache, chain) in abstractGetImmutablePolicyHash(chain.PolicyCertificates[0]) 
}

ghost
requires acc_policyCertificateChain(chain, policyDnsNameCache)
decreases
opaque
pure func getAbstractChainFromChain(chain *PolicyCertificateChain, policyDnsNameCache dict[string][]string) AbstractChain {
	return unfolding acc_policyCertificateChain(chain, policyDnsNameCache) in toAbstractChainFromChain(chain.PolicyCertificates, policyDnsNameCache, chain)
}

ghost 
requires (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) && 
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	(forall str string :: {&immutablePolicyCache[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash) && ((immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) && immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache)) ==> immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires rootChain != nil ==> acc_policyCertificateChain(rootChain, policyDnsNameCache)
ensures (immutableHash == base64.StdEncoding.EncodeToString(nil) || !(immutableHash in domain(immutablePolicyCache))) ==> res == seq[AbstractPolicy]{}
ensures immutableHash != base64.StdEncoding.EncodeToString(nil) && (immutableHash in domain(immutablePolicyCache)) && rootChain != nil && immutableHash == getImmutableHashOfFirstCert(rootChain, policyDnsNameCache) ==> res == getAbstractChainFromChain(rootChain, policyDnsNameCache)
ensures immutableHash != base64.StdEncoding.EncodeToString(nil) && (immutableHash in domain(immutablePolicyCache)) && !(rootChain != nil && immutableHash == getImmutableHashOfFirstCert(rootChain, policyDnsNameCache)) ==> res == seq[AbstractPolicy]{unfolding ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache) in getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, len(immutablePolicyCache[immutableHash].policyHashes), len(immutablePolicyCache[immutableHash].policyHashes))} ++ abstractGetPolicyCertificateChainWithLatestTimestampInner(immutablePolicyCache[immutableHash].immutableIssuerHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)
decreases (immutableHash != base64.StdEncoding.EncodeToString(nil) && immutableHash in domain(immutablePolicyCache)) ? immutablePolicyCache[immutableHash].depth : 0
opaque
pure func abstractGetPolicyCertificateChainWithLatestTimestampInner(immutableHash string, rootChain *PolicyCertificateChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain) {
	return (immutableHash == base64.StdEncoding.EncodeToString(nil) || !(immutableHash in domain(immutablePolicyCache))) ? seq[AbstractPolicy]{} : (
		(rootChain != nil && immutableHash == getImmutableHashOfFirstCert(rootChain, policyDnsNameCache)) ? getAbstractChainFromChain(rootChain, policyDnsNameCache) : (
			seq[AbstractPolicy]{unfolding ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache) in getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, len(immutablePolicyCache[immutableHash].policyHashes), len(immutablePolicyCache[immutableHash].policyHashes))} ++ abstractGetPolicyCertificateChainWithLatestTimestampInner(immutablePolicyCache[immutableHash].immutableIssuerHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)))
}

ghost
requires (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) &&
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	(forall str string :: {&immutablePolicyCache[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash) && ((immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) && immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache)) ==> immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires rootChain != nil ==> acc_policyCertificateChain(rootChain, policyDnsNameCache)
opaque
decreases
pure func abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash string, rootChain *PolicyCertificateChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain){
	return abstractGetPolicyCertificateChainWithLatestTimestampInner(immutableHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)
}

/*
ghost
requires perms1 > 0
requires perms2 > 0
requires immutableHash != base64.StdEncoding.EncodeToString(nil) ==> immutableHash in domain(immutablePolicyCache)
preserves (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) &&
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	(forall str string :: {&immutablePolicyCache[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash) && (immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) ==> immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache) && immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
preserves PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache, perms2)
preserves rootChain != nil ==> acc_policyCertificateChain(rootChain, policyDnsNameCache, perms2)
ensures abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache, perms1) == abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache, perms2)
decreases 
func lemmaChainGenerationIndependentFromPerm(immutableHash string, rootChain *PolicyCertificateChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, perms1 perm, perms2 perm)*/

/*
ghost
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k)
requires idx >= 0
requires excl <= len(spcts)
ensures idx >= excl ==> res == maxTimestamp
ensures idx < excl ==> res == findMaxSPCTInner(spcts, idx + 1, maxTime(unfolding cache_SPCT(&spcts[idx], idx) in spcts[idx].AddedTS, maxTimestamp), excl)
decreases len(spcts) - idx
opaque
pure func findMaxSPCTInner(spcts []common.SignedPolicyCertificateTimestamp, idx int, maxTimestamp time.Time, excl int) (res time.Time) {
	return idx >= excl ? maxTimestamp : findMaxSPCTInner(spcts, idx + 1, maxTime(unfolding cache_SPCT(&spcts[idx], idx) in spcts[idx].AddedTS, maxTimestamp), excl)
}

ghost 
requires excl <= len(spcts)
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k)
decreases 
opaque
pure func findMaxSPCT(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, excl int) (res time.Time) {
	return len(spcts) == 0 ? policyTime : findMaxSPCTInner(spcts, 0, policyTime, excl)
}*/

ghost
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k)
requires idx == excl - 1
requires excl > 0
requires excl <= len(spcts)
ensures res == maxTime(findMaxSPCT(spcts, policyTime, excl - 1, idx), unfolding cache_SPCT(&spcts[excl-1], excl-1) in spcts[excl-1].AddedTS)
decreases excl, idx
opaque
pure func findMaxSPCTInner(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, excl int, idx int) (res time.Time) { // idx just to prove termination of findMaxSPCT
	return maxTime(findMaxSPCT(spcts, policyTime, excl - 1, idx), unfolding cache_SPCT(&spcts[excl-1], excl-1) in spcts[excl-1].AddedTS)
}

ghost 
requires idx == excl
requires excl >= 0
requires excl <= len(spcts)
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k)
decreases idx, excl
opaque
pure func findMaxSPCT(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, excl int, idx int) (res time.Time) {
	return excl == 0 ? policyTime : findMaxSPCTInner(spcts, policyTime, excl, idx - 1) // idx just to prove termination
}


/*
ghost
requires forall k int :: {hashes[k]} 0 <= k && k < len(hashes) ==> hashes[k] in domain(policyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
ensures len(hashes) == 0 ==> res == minMaxPolicy
ensures len(hashes) != 0 ==> res == (let maxSPCT := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in (unfolding cache_policyHashes_policy(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache) in (unfolding cache_SPCTs(policyCache[hashes[0]].policy.SPCTs) in (findMaxSPCT(policyCache[hashes[0]].policy.SPCTs, policyCache[hashes[0]].policy.TimeStamp, len(policyCache[hashes[0]].policy.SPCTs), len(policyCache[hashes[0]].policy.SPCTs))))) in (
		(isFirst || minMaxTimestamp.After(maxSPCT)) ? getMinMaxPolicyInner(hashes[1:], false, maxSPCT, unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache), immutablePolicyCache, policyCache, policyDnsNameCache) : getMinMaxPolicyInner(hashes[1:], false, minMaxTimestamp, minMaxPolicy, immutablePolicyCache, policyCache, policyDnsNameCache)))
decreases len(hashes)
opaque
pure func getMinMaxPolicyInner(hashes seq[string], isFirst bool, minMaxTimestamp time.Time, minMaxPolicy AbstractPolicy, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractPolicy) {
	return len(hashes) == 0 ? minMaxPolicy : (let maxSPCT := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in (unfolding cache_policyHashes_policy(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache) in (unfolding cache_SPCTs(policyCache[hashes[0]].policy.SPCTs) in (findMaxSPCT(policyCache[hashes[0]].policy.SPCTs, policyCache[hashes[0]].policy.TimeStamp, len(policyCache[hashes[0]].policy.SPCTs), len(policyCache[hashes[0]].policy.SPCTs))))) in (
		(isFirst || minMaxTimestamp.After(maxSPCT)) ? getMinMaxPolicyInner(hashes[1:], false, maxSPCT, unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[hashes[0]].policy, hashes[0], policyDnsNameCache), immutablePolicyCache, policyCache, policyDnsNameCache) : getMinMaxPolicyInner(hashes[1:], false, minMaxTimestamp, minMaxPolicy, immutablePolicyCache, policyCache, policyDnsNameCache)))
}	

ghost
requires immutableHash in domain(immutablePolicyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires acc(&immutablePolicyCache[immutableHash].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache)
decreases
opaque
pure func getMinMaxPolicy(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractPolicy) {
	return getMinMaxPolicyInner(unfolding ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache) in toSeq(immutablePolicyCache[immutableHash].policyHashes), true, time.Time{}, AbstractPolicy{}, immutablePolicyCache, policyCache, policyDnsNameCache)
}*/

ghost
requires idx == excl - 1
requires excl > 1
requires immutableHash in domain(immutablePolicyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires acc(&immutablePolicyCache[immutableHash].policyHashes) && acc(immutablePolicyCache[immutableHash].policyHashes)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires excl <= len(immutablePolicyCache[immutableHash].policyHashes)
ensures res == let curr := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[excl - 1]].policy, immutablePolicyCache[immutableHash].policyHashes[excl - 1], policyDnsNameCache) in 
	let inner := getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, excl - 1, idx) in
	curr.minMaxTimestamp.Before(inner.minMaxTimestamp) ? curr : inner
decreases idx, excl
opaque
pure func getMinMaxPolicyInner(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, excl int, idx int) (res AbstractPolicy) {
	return let curr := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[excl - 1]].policy, immutablePolicyCache[immutableHash].policyHashes[excl - 1], policyDnsNameCache) in 
	let inner := getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, excl - 1, idx) in
	curr.minMaxTimestamp.Before(inner.minMaxTimestamp) ? curr : inner
}

ghost
requires idx == excl
requires excl >= 1
requires immutableHash in domain(immutablePolicyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires acc(&immutablePolicyCache[immutableHash].policyHashes) && acc(immutablePolicyCache[immutableHash].policyHashes)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires excl <= len(immutablePolicyCache[immutableHash].policyHashes)
decreases idx, excl
opaque
pure func getMinMaxPolicy(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, excl int, idx int) (res AbstractPolicy) {
	return excl == 1 ? (unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy, immutablePolicyCache[immutableHash].policyHashes[0], policyDnsNameCache)) : getMinMaxPolicyInner(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, excl, idx - 1)
}

ghost 
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires hash in domain(policyCache)
decreases
opaque
pure func unfoldAndGetChain(hash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) AbstractChain {
	return unfolding ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache) in abstractGetPolicyCertificateChainWithLatestTimestamp(unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in (
			unfolding PolicyCachePermissions_ImmutableHash(policyCache[hash].immutableHash, hash, immutablePolicyCache) in policyCache[hash].immutableHash), nil, immutablePolicyCache, policyCache, policyDnsNameCache)
}

ghost
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires domainVar in domain(policyDnsNameCache)
requires idx >= 0
requires idx <= len(let c, _ := policyDnsNameCache[domainVar] in c)
ensures len(res) == idx
ensures unfolding PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache) in (unfolding acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache) in (
	forall k int :: {res[k]} 0 <= k && k < len(res) ==> res[k] == let hashes, _ := policyDnsNameCache[domainVar] in unfoldAndGetChain(hashes[k], immutablePolicyCache, policyCache, policyDnsNameCache)))
decreases
pure func abstractFindChainsInner(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int) (res seq[AbstractChain])

ghost
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires domainVar in domain(policyDnsNameCache)
requires idx >= 0
requires idx <= len(let c, _ := policyDnsNameCache[domainVar] in c)
ensures len(res) == idx
decreases
opaque
pure func abstractFindChains(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int) (res seq[AbstractChain]) {
	return abstractFindChainsInner(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
}

ghost
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache)
ensures len(chains) == len(res)
ensures forall k int :: {res[k]} {&chains[k]} 0 <= k && k < len(res) ==> (unfoldAndToAbstractChainFromChain(chains[k], k, policyDnsNameCache) == res[k])
decreases
pure func toAbstractChains(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string) (res seq[AbstractChain])

ghost 
decreases
opaque
pure func validityOfDomain(policy AbstractPolicy, info AbstractCertificateChainInfo) bool {
	return let normDomain := normalizeDomainSpec(policy.Domain) in let polDomain := strings.GhostCutSuffix(normDomain, ".") in (let dns := strings.GhostCutSuffix(info.DNSName, ".") in (
		let subdomain := strings.GhostCutSuffix(dns, "."+polDomain) in (
			let subdomains := strings.GhostSplit(subdomain, ".") in (
				let target := subdomains[len(subdomains) - 1] in (
					(target in policy.AllowedSubdomains) || (
						!(target in policy.DisallowedSubdomains) && (target in policy.ExcludedSubdomains /* TODO IS THIS REALLY WHAT EXCLUDED IS FOR? */ || !("*" in policy.DisallowedSubdomains))))))))
}

ghost
requires idx >= 0
requires idx < len(policies)
ensures validAgainstAllPolicies(policies, info, idx) && validityOfCA(policies[idx], info) && validityOfDomain(policies[idx], info) ==> validAgainstAllPolicies(policies, info, idx + 1)
ensures !validAgainstAllPolicies(policies, info, idx) ==> !validAgainstAllPolicies(policies, info, idx + 1)
ensures validAgainstAllPolicies(policies, info, idx) && (!validityOfCA(policies[idx], info) || !validityOfDomain(policies[idx], info)) ==> !validAgainstAllPolicies(policies, info, idx + 1)
decreases
func lemmaValidAgainstAllPoliciesPlus1(policies AbstractChain, info AbstractCertificateChainInfo, idx int) {
	reveal validAgainstAllPolicies(policies, info, idx)
	reveal validAgainstAllPolicies(policies, info, idx + 1)
}

ghost
requires len(policy.AllowedCAs) > 0 && (forall k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) ==> policy.AllowedCAs[k] != info.CA)
ensures !validityOfCA(policy, info)
decreases
func lemmaNotValidAgainstCA(policy AbstractPolicy, info AbstractCertificateChainInfo) {
	reveal validityOfCA(policy, info)
}

ghost
requires len(policy.AllowedCAs) == 0 || (exists k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) && policy.AllowedCAs[k] == info.CA)
ensures validityOfCA(policy, info)
decreases
func lemmaValidAgainstCA(policy AbstractPolicy, info AbstractCertificateChainInfo) {
	reveal validityOfCA(policy, info)
}

ghost
requires len(policy.AllowedCAs) > 0 && (forall k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) ==> policy.AllowedCAs[k] != info.CA)
ensures !validityOfCA(policy, info)
decreases
func lemmaNotValidAgainstDomain(policy AbstractPolicy, info AbstractCertificateChainInfo) {
	reveal validityOfCA(policy, info)
}

/*ghost
requires len(abstractChain) == 0
ensures validAgainstAllPolicies(abstractChain, info, 0)
decreases
func lemmaEmptyConflictingPolicyAttributes(abstractChain AbstractChain, info common.AbstractCertificateChainInfo)
*/
ghost
ensures validAgainstAllPolicies(abstractChain, info, 0)
decreases
func lemmaCheckNoPolicy(abstractChain AbstractChain, info AbstractCertificateChainInfo) {
	reveal validAgainstAllPolicies(abstractChain, info, 0)
}

ghost 
requires perms > 0
requires acc(acc_inj_trustInfo_policy(policy, l), perms)
requires toAbstractPolicy(policy, l) == abstractPolicy
requires unfolding acc(acc_inj_trustInfo_policy(policy, l), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainAllowed)
ensures acc(acc_inj_trustInfo_policy(policy, l), perms)
ensures validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainAllowedValid(policy *common.PolicyCertificate, l int, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	reveal validityOfDomain(abstractPolicy, info)
}

ghost 
requires perms > 0
requires acc(acc_inj_trustInfo_policy(policy, l), perms)
requires toAbstractPolicy(policy, l) == abstractPolicy
requires unfolding acc(acc_inj_trustInfo_policy(policy, l), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainExcluded)
ensures acc(acc_inj_trustInfo_policy(policy, l), perms)
ensures validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainExcludedValid(policy *common.PolicyCertificate, l int, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	reveal validityOfDomain(abstractPolicy, info)
}

ghost 
requires perms > 0
requires acc(acc_inj_trustInfo_policy(policy, l), perms)
requires toAbstractPolicy(policy, l) == abstractPolicy
requires unfolding acc(acc_inj_trustInfo_policy(policy, l), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainDisallowed)
ensures acc(acc_inj_trustInfo_policy(policy, l), perms)
ensures !validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainDisallowedInvalid(policy *common.PolicyCertificate, l int, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_trustInfo_policy(policy, l), perms / 2)
	reveal validityOfDomain(abstractPolicy, info)
}

ghost
requires perms > 0
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/2)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires domainVar in domain(policyDnsNameCache)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/2)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures domainVar in domain(policyDnsNameCache)
ensures seq[AbstractChain]{} == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, 0)
decreases
func lemmaFindAbstractChainsEmpty(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, perms perm) {
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, 0)
}

ghost 
requires idx >= 0
requires perms > 0
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires domainVar in domain(policyDnsNameCache)
requires idx < let c, _ := policyDnsNameCache[domainVar] in len(c)
requires idx < len(chains)
requires chains[:idx] == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
requires unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/4) in (let hashes, _ := policyDnsNameCache[domainVar] in len(hashes) > idx)
requires chains[idx] == unfoldAndGetChain(unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/4) in (let hashes, _ := policyDnsNameCache[domainVar] in hashes[idx]), immutablePolicyCache, policyCache, policyDnsNameCache)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures domainVar in domain(policyDnsNameCache)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures idx < let c, _ := policyDnsNameCache[domainVar] in len(c)
ensures chains[:idx + 1] == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1)
decreases
func lemmaFindAbstractChainsInduction(chains seq[AbstractChain], domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int, perms perm) {
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
	reveal unfoldAndGetChain(unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/4) in (let hashes, _ := policyDnsNameCache[domainVar] in hashes[idx]), immutablePolicyCache, policyCache, policyDnsNameCache)
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1)
}

/*
ghost
requires idx >= 0
requires perms > 0
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires domainVar in domain(policyDnsNameCache)
requires idx < let c, _ := policyDnsNameCache[domainVar] in len(c)
requires idx == len(chains) - 1
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
requires toAbstractChains(chains, policyDnsNameCache)[:idx] == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
//requires toAbstractChains(chains[:idx], policyDnsNameCache) == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
requires unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/4) in (let hashes, _ := policyDnsNameCache[domainVar] in len(hashes) > idx)
requires unfolding acc(acc_inj_policyCertificateChain(chains[idx], idx, policyDnsNameCache), perms) in unfolding acc(acc_policyCertificateChain(chains[idx], policyDnsNameCache), perms) in toAbstractChainFromChain(chains[idx].PolicyCertificates, policyDnsNameCache, chains[idx]) == unfoldAndGetChain(unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/4) in (let hashes, _ := policyDnsNameCache[domainVar] in hashes[idx]), immutablePolicyCache, policyCache, policyDnsNameCache)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures domainVar in domain(policyDnsNameCache)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures idx < let c, _ := policyDnsNameCache[domainVar] in len(c)
ensures forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
ensures toAbstractChains(chains, policyDnsNameCache) == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1)
decreases 
func lemmaFindAbstractChainsInduction(chains []*PolicyCertificateChain, domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int, perms perm) {
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
	reveal unfoldAndGetChain(unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/4) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/4) in (let hashes, _ := policyDnsNameCache[domainVar] in hashes[idx]), immutablePolicyCache, policyCache, policyDnsNameCache)
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1)
}*/

ghost 
requires perms > 0
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
ensures forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
ensures policyTime == findMaxSPCT(spcts, policyTime, 0, 0)
decreases
func lemmaFindMaxSPCTEmpty(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, perms perm) {
	reveal findMaxSPCT(spcts, policyTime, 0, 0)
}

ghost 
requires perms > 0
requires idx >= 0
requires idx < len(spcts)
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
requires currentMax == findMaxSPCT(spcts, policyTime, idx, idx)
ensures forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
ensures maxTime(currentMax, unfolding acc(cache_SPCT(&spcts[idx], idx), perms) in spcts[idx].AddedTS) == findMaxSPCT(spcts, policyTime, idx + 1, idx + 1)
//ensures currentMax == maxTime(currentMax, unfolding acc(cache_SPCT(&spcts[idx], idx), perms) in spcts[idx].AddedTS) ==> currentMax == findMaxSPCT(spcts, policyTime, idx + 1)
//ensures let currentTS := (unfolding acc(cache_SPCT(&spcts[idx], idx), perms) in spcts[idx].AddedTS) in (currentTS == maxTime(currentMax, currentTS) ==> currentTS == findMaxSPCT(spcts, policyTime, idx + 1))
decreases
func lemmaFindMaxSPCTInduction(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, currentMax time.Time, idx int, perms perm) {
	//reveal findMaxSPCT(spcts, policyTime, idx)
	reveal findMaxSPCT(spcts, policyTime, idx + 1, idx + 1)
}


/*ghost
requires perms > 0
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
ensures forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
ensures forall idx int :: {&chains[idx]} 0 < idx && idx <= len(chains) ==> toAbstractChains(chains[:idx], policyDnsNameCache) == toAbstractChains(chains, policyDnsNameCache)[:idx]
decreases
func lemmaHomomorphismOfAbstractChains(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string, perms perm) {

}*/

ghost 
requires perms > 0
requires cachePerms > 0 
requires immutableHash in domain(immutablePolicyCache)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
ensures forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
ensures len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures (unfolding acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy, immutablePolicyCache[immutableHash].policyHashes[0], policyDnsNameCache)) == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, 1, 1)
decreases
func lemmaGetMinMaxPolicyEmpty(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, perms perm, cachePerms perm) {
	reveal getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, 1, 1)
}

ghost 
requires perms > 0
requires cachePerms > 0 
requires immutableHash in domain(immutablePolicyCache)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires idx >= 1
requires idx < len(immutablePolicyCache[immutableHash].policyHashes)
requires currentPolicy == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx, idx)
requires let curr := unfolding acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[idx]].policy, immutablePolicyCache[immutableHash].policyHashes[idx], policyDnsNameCache) in
	curr.minMaxTimestamp.Before(currentPolicy.minMaxTimestamp)
requires len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
ensures forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
ensures idx < len(immutablePolicyCache[immutableHash].policyHashes)
ensures len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures (unfolding acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[idx]].policy, immutablePolicyCache[immutableHash].policyHashes[idx], policyDnsNameCache)) == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
decreases
func lemmaGetMinMaxPolicyInduction1(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, currentPolicy AbstractPolicy, idx int, perms perm, cachePerms perm) {
	reveal getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
}

ghost 
requires perms > 0
requires cachePerms > 0 
requires immutableHash in domain(immutablePolicyCache)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires idx >= 1
requires idx < len(immutablePolicyCache[immutableHash].policyHashes)
requires currentPolicy == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx, idx)
requires let curr := unfolding acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[idx]].policy, immutablePolicyCache[immutableHash].policyHashes[idx], policyDnsNameCache) in
	!curr.minMaxTimestamp.Before(currentPolicy.minMaxTimestamp)
requires len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
ensures forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
ensures idx < len(immutablePolicyCache[immutableHash].policyHashes)
ensures len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures currentPolicy == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
decreases
func lemmaGetMinMaxPolicyInduction2(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, currentPolicy AbstractPolicy, idx int, perms perm, cachePerms perm) {
	reveal getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
}

ghost
requires i >= 0
requires i <= len(chains)
requires perms > 0
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
ensures forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
ensures toAbstractChains(chains[:i], policyDnsNameCache) == toAbstractChains(chains, policyDnsNameCache)[:i]
decreases i
func lemmaHomomorphismOfAbstractChains(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string, i int, perms perm) {
	if i == 0 {
	} else {
		/*if i > 1 {
			lemmaHomomorphismOfAbstractChains(chains, policyDnsNameCache, i - 1, perms / 2)
			assert toAbstractChains(chains[:i-1], policyDnsNameCache) == toAbstractChains(chains, policyDnsNameCache)[:i-1]
		} */
		lemmaHomomorphismOfAbstractChains(chains, policyDnsNameCache, i - 1, perms / 2)


		
		/*assert unfoldAndToAbstractChainFromChain(chains[i-1], i-1, policyDnsNameCache) == toAbstractChains(chains, policyDnsNameCache)[i-1]
		assert false*/
		
	}
}
/*
ghost
requires curr >= 0
requires i <= len(chains)
requires curr <= i
requires perms > 0
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
ensures forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k], perms) && acc(acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache), perms)
ensures toAbstractChains(chains[:curr], policyDnsNameCache) == toAbstractChains(chains, policyDnsNameCache)[:curr]
decreases i
func lemmaHomomorphismOfAbstractChains(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string, curr int, i int, perms perm) {
	if curr < i {

	}
}*/