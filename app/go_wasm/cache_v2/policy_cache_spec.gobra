package cache_v2

import (
	"crypto/x509"
    "fpki/pkg/common"
    "encoding/base64"
    "net/publicsuffix"
	"strings"
	"time"
	"fpki/pkg/common/crypto"
)

pred acc_leafHashes(hashes []string, str string, ghost policyCache dict[string]*PolicyCacheEntry) {
	forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k]) && hashes[k] in domain(policyCache)
}

pred cache_SPCT(spct *common.SignedPolicyCertificateTimestamp, l int) {
	acc(spct)
}

pred cache_SPCTs(arr []common.SignedPolicyCertificateTimestamp) {
	forall l int :: {&arr[l]} 0 <= l && l < len(arr) ==> cache_SPCT(&arr[l], l)
}

pred policy_IssuerHash(issuerHash []byte) {
	forall k int :: {&issuerHash[k]} 0 <= k && k < len(issuerHash) ==> acc(&issuerHash[k])
}

// If we include this directly in PolicyCachePermissions instead of putting it like this into a separate predicate it will not terminate upon a verification error after unfold
pred cache_policyHashes_policy(policy *common.PolicyCertificate, hash string, ghost policyDnsNameCache dict[string][]string) {
	acc(policy) && 
	policy.Domain() in domain(policyDnsNameCache) && cache_SPCTs(policy.SPCTs) && policy_IssuerHash(policy.IssuerHash) && acc_strs(policy.PolicyAttributes.AllowedCAs) && acc_strs(policy.PolicyAttributes.AllowedSubdomains) && acc_strs(policy.PolicyAttributes.DisallowedSubdomains) && acc_strs(policy.PolicyAttributes.ExcludedSubdomains)
}

pred ImmutablePolicyCachePermissions_policyHashes(hashes []string, immutableHash string, ghost policyCache dict[string]*PolicyCacheEntry) {
    len(hashes) > 0 && forall k int :: {&hashes[k]} 0 <= k && k < len(hashes) ==> acc(&hashes[k]) && hashes[k] in domain(policyCache)
}

pred ImmutablePolicyCachePermissions_issuer(ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry) {
	(forall str string :: {&immutablePolicyCache[str].depth} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].depth) && immutablePolicyCache[str].depth > 0) &&
	(forall str string :: {&immutablePolicyCache[str].immutableIssuerHash} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].immutableIssuerHash) && ((immutablePolicyCache[str].immutableIssuerHash != base64.StdEncoding.EncodeToString(nil) && immutablePolicyCache[str].immutableIssuerHash in domain(immutablePolicyCache)) ==> immutablePolicyCache[immutablePolicyCache[str].immutableIssuerHash].depth == immutablePolicyCache[str].depth - 1))
}

pred ImmutablePolicyCachePermissions(ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, ghost policyCache dict[string]*PolicyCacheEntry) { 
	(forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> str != base64.StdEncoding.EncodeToString(nil)) &&
    (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) && 
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
}

pred PolicyCachePermissions_ImmutableHash(immutableHash string, policyHash string, ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry) {
	immutableHash != base64.StdEncoding.EncodeToString(nil) && 
    immutableHash in domain(immutablePolicyCache) 
}

// Note: This pred used to have policy perms only for the cache_policyHashes_policy predicate. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred PolicyCachePermissions(ghost policyCache dict[string]*PolicyCacheEntry, ghost immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, ghost policyDnsNameCache dict[string][]string) {
    forall str string :: {policyCache[str]} str in domain(policyCache) ==> 
    acc(policyCache[str]) && 
    PolicyCachePermissions_ImmutableHash(policyCache[str].immutableHash, str, immutablePolicyCache) && // We don't need these invariants in a lot of places -> put into separate predicate to not carry quantifier around
    cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache) //acc(policyCache[str].policy, perms) && cache_SPCTs(policyCache[str].policy.SPCTs, perms)
}

pred PolicyDnsNameCachePermissions(ghost policyDnsNameCache dict[string][]string, ghost policyCache dict[string]*PolicyCacheEntry) {
    forall str string :: {policyDnsNameCache[str]} str in domain(policyDnsNameCache) ==> let leafHashes, ok := policyDnsNameCache[str] in len(leafHashes) > 0 && acc_leafHashes(leafHashes, str, policyCache)
}

pred acc_strs(arr []string) {
	forall k int :: {&arr[k]} 0 <= k && k < len(arr) ==> acc(&arr[k])
}

pred acc_inj_chainCertificate(cert *common.PolicyCertificate, i int, ghost policyDnsNameCache dict[string][]string/*, chain *PolicyCertificateChain*/) {
	acc(cert) && cert.Domain() in domain(policyDnsNameCache) && cache_SPCTs(cert.SPCTs) && policy_IssuerHash(cert.IssuerHash) && acc_strs(cert.PolicyAttributes.AllowedCAs) && acc_strs(cert.PolicyAttributes.AllowedSubdomains) && acc_strs(cert.PolicyAttributes.DisallowedSubdomains) && acc_strs(cert.PolicyAttributes.ExcludedSubdomains)
}

// Note: This pred used to have policy perms only for the acc_inj_chainCertificate predicate. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred acc_policyCertificateChain(chain *PolicyCertificateChain, ghost policyDnsNameCache dict[string][]string) {
	acc(chain) &&
	len(chain.PolicyCertificates) >= 1 &&
	(forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc(&chain.PolicyCertificates[l])) &&
	(forall l int :: {&chain.PolicyCertificates[l]} 0 <= l && l < len(chain.PolicyCertificates) ==> acc_inj_chainCertificate(chain.PolicyCertificates[l], len(chain.PolicyCertificates) - l - 1, policyDnsNameCache))
} 

pred acc_inj_policyCertificateChain(chain *PolicyCertificateChain, i int, ghost policyDnsNameCache dict[string][]string) {
	acc_policyCertificateChain(chain, policyDnsNameCache)
}

pred acc_policyAttributes(attr *common.PolicyAttributes) {
	acc(&attr.AllowedCAs) && acc(&attr.AllowedSubdomains) && acc(&attr.DisallowedSubdomains) && acc(&attr.ExcludedSubdomains) &&
	acc_strs(attr.AllowedCAs) &&
	acc_strs(attr.AllowedSubdomains) && 
	acc_strs(attr.DisallowedSubdomains) &&
	acc_strs(attr.ExcludedSubdomains)
}

pred acc_inj_trustInfo_conflictingPolicyAttributes_attr(attr *ConflictingPolicyAttribute, i int) {
	acc(attr) && acc_policyAttributes(attr.Attribute)
}

// Note: This pred used to have policy perms only for the acc_inj_trustInfo_policy and acc_inj_trustInfo_conflictingPolicyAttributes_attr predicates. Now, with fractional permissions, all inner predicates/acc are fractional. If something doesn't work anymore, this might be why.
pred acc_trustInfo(trustInfo *PolicyTrustInfo, ghost policyDnsNameCache dict[string][]string) {
	acc(trustInfo) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc(&trustInfo.ConflictingPolicyAttributes[k])) &&
	(forall k int :: {&trustInfo.ConflictingPolicyAttributes[k]} 0 <= k && k < len(trustInfo.ConflictingPolicyAttributes) ==> acc_inj_trustInfo_conflictingPolicyAttributes_attr(trustInfo.ConflictingPolicyAttributes[k], k)) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc(&trustInfo.PolicyChain[k])) &&
	(forall k int :: {&trustInfo.PolicyChain[k]} 0 <= k && k < len(trustInfo.PolicyChain) ==> acc_inj_chainCertificate(trustInfo.PolicyChain[k], len(trustInfo.PolicyChain) - k - 1, policyDnsNameCache)) &&
	len(trustInfo.CertificateChain) > 0 && acc(&trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) && acc(trustInfo.CertificateChain[len(trustInfo.CertificateChain)-1]) &&
	let e2ld := publicsuffix.EffectiveTLDPlusOne(trustInfo.DNSName) in (e2ld in domain(policyDnsNameCache)) &&
	len(trustInfo.PolicyChain) >= 0
}

// --- | CORRECTNESS | ---

ghost type AbstractPolicy ghost struct {
	AllowedCAs seq[string]
	AllowedSubdomains seq[string]
	DisallowedSubdomains seq[string]
	ExcludedSubdomains seq[string]
	Domain string
	minMaxTimestamp time.Time
	immutableHash string
}

ghost type AbstractCertificateChainInfo ghost struct {
	CA string
	DNSName string
}


ghost type AbstractChain seq[AbstractPolicy]

// from Gobra tutorial at https://github.com/viperproject/gobra/blob/master/docs/tutorial.md
ghost
requires forall j int :: 0 <= j && j < len(s) ==> acc(&s[j])
ensures  len(res) == len(s)
ensures  forall j int :: {s[j]} {res[j]} 0 <= j && j < len(s) ==> s[j] == res[j]
decreases len(s)
opaque
pure func toSeq(s []string) (res seq[string]) {
	return (len(s) == 0 ? seq[string]{} :
		toSeq(s[:len(s)-1]) ++ seq[string]{s[len(s) - 1]})
}

ghost
requires acc_strs(s)
decreases
opaque
pure func strsToSeq(s []string) (res seq[string]) {
	return unfolding acc_strs(s) in toSeq(s)
}

ghost
requires cache_SPCTs(spcts)
decreases
opaque 
pure func unfoldAndFindMaxSPCT(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time) time.Time {
	return unfolding cache_SPCTs(spcts) in findMaxSPCT(spcts, policyTime, len(spcts), len(spcts))
}

ghost 
requires cache_policyHashes_policy(policyCertificate, hash, policyDnsNameCache)
decreases
pure func toAbstractPolicyFromCache(policyCertificate *common.PolicyCertificate, hash string, policyDnsNameCache dict[string][]string) AbstractPolicy {
	return unfolding cache_policyHashes_policy(policyCertificate, hash, policyDnsNameCache) in toAbstractPolicyFromBlank(policyCertificate)
}

ghost 
requires acc_inj_chainCertificate(policyCertificate, l, policyDnsNameCache)
decreases
pure func toAbstractPolicyFromChain(policyCertificate *common.PolicyCertificate, l int, policyDnsNameCache dict[string][]string) AbstractPolicy {
	return unfolding acc_inj_chainCertificate(policyCertificate, l, policyDnsNameCache) in toAbstractPolicyFromBlank(policyCertificate)
}

ghost 
requires acc(policyCertificate)
requires acc_strs(policyCertificate.PolicyAttributes.AllowedCAs) 
requires acc_strs(policyCertificate.PolicyAttributes.AllowedSubdomains) 
requires acc_strs(policyCertificate.PolicyAttributes.DisallowedSubdomains)
requires acc_strs(policyCertificate.PolicyAttributes.ExcludedSubdomains)
requires cache_SPCTs(policyCertificate.SPCTs)
decreases
pure func toAbstractPolicyFromBlank(policyCertificate *common.PolicyCertificate) AbstractPolicy {
	return AbstractPolicy{
		AllowedCAs: strsToSeq(policyCertificate.PolicyAttributes.AllowedCAs),
		AllowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.AllowedSubdomains),
		DisallowedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.DisallowedSubdomains),
		ExcludedSubdomains: strsToSeq(policyCertificate.PolicyAttributes.ExcludedSubdomains),
		Domain: policyCertificate.Domain(),
		minMaxTimestamp: unfoldAndFindMaxSPCT(policyCertificate.SPCTs, policyCertificate.TimeStamp),
		immutableHash: base64.StdEncoding.AbstractEncodeToString(crypto.abstractComputeHashAsSigner(policyCertificate)),
	}
}

ghost
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc(&policyCertificates[l])
requires forall l int :: {&policyCertificates[l]} 0 <= l && l < len(policyCertificates) ==> acc_inj_chainCertificate(policyCertificates[l], len(policyCertificates) - l - 1, policyDnsNameCache)
ensures len(policyCertificates) == len(res)
ensures forall k int :: {res[k]} 0 <= k && k < len(policyCertificates) ==> res[k] == toAbstractPolicyFromChain(policyCertificates[k], len(policyCertificates) - k - 1, policyDnsNameCache)
decreases
pure func toAbstractChainFromChain(policyCertificates []*common.PolicyCertificate, policyDnsNameCache dict[string][]string) (res AbstractChain)

ghost
requires acc_inj_policyCertificateChain(chain, k, policyDnsNameCache)
decreases
opaque
pure func unfoldAndToAbstractChainFromChain(chain *PolicyCertificateChain, k int, policyDnsNameCache dict[string][]string) AbstractChain {
	return unfolding acc_inj_policyCertificateChain(chain, k, policyDnsNameCache) in unfoldAndToAbstractChainFromChain2(chain, policyDnsNameCache)
}

ghost 
requires acc_policyCertificateChain(chain, policyDnsNameCache)
decreases
opaque
pure func unfoldAndToAbstractChainFromChain2(chain *PolicyCertificateChain, policyDnsNameCache dict[string][]string) AbstractChain {
	return unfolding acc_policyCertificateChain(chain, policyDnsNameCache) in toAbstractChainFromChain(chain.PolicyCertificates, policyDnsNameCache)
}

ghost
requires excl >= 1
requires excl <= len(subdomains)
decreases excl
opaque
pure func abstractGetSubdomainString(e2ld string, subdomains seq[string], excl int) string {
	return excl == 1 ? e2ld : (subdomains[len(subdomains) - 1 - (excl - 1)] + "." + abstractGetSubdomainString(e2ld, subdomains, excl - 1))
}

ghost 
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
decreases
opaque
pure func abstractFindPolicyCertificateChainForDomain(domainVar string, rootChain AbstractChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain) {
	return len(rootChain) == 0 ? seq[AbstractPolicy]{} : (let e2ld := rootChain[0].Domain in (
		let subdomainsStr := strings.GhostCutSuffix(domainVar, e2ld) in (
			let subdomains := strings.GhostSplit(subdomainsStr, ".") in (
				len(subdomains) < 1 ? seq[AbstractPolicy]{} : (let maxSubdomain := abstractGetSubdomainString(e2ld, subdomains, len(subdomains)) in (
					abstractGetNewestChainWithRootChain(maxSubdomain, len(e2ld), immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, abstractGetLeafHashesLen(maxSubdomain, policyDnsNameCache, policyCache))))))))
}


ghost 
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires publicsuffix.EffectiveTLDPlusOne(domainVar) in domain(policyDnsNameCache)
decreases
opaque
pure func genAbstractChain(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain) {
	return let rootChains := abstractFindChains(publicsuffix.EffectiveTLDPlusOne(domainVar), immutablePolicyCache, policyCache, policyDnsNameCache, len(let c, _ := policyDnsNameCache[publicsuffix.EffectiveTLDPlusOne(domainVar)] in c)) in (
		len(rootChains) == 0 ? seq[AbstractPolicy]{} : (let rootChain := abstractGetNewestChain(rootChains, len(rootChains)) in abstractFindPolicyCertificateChainForDomain(domainVar, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)))
}

ghost
requires len(certificateChain) > 0 && acc(&certificateChain[len(certificateChain)-1]) && acc(certificateChain[len(certificateChain)-1])
ensures certificateChain[len(certificateChain)-1].Subject.ToRDNSequence().String() == res.CA
ensures trustInfoDNSName == res.DNSName
decreases
pure func toAbstractCertificateChainInfo(certificateChain []*x509.Certificate, trustInfoDNSName string) (res AbstractCertificateChainInfo)

ghost
decreases
opaque
pure func validityOfCA(policy AbstractPolicy, info AbstractCertificateChainInfo) bool {
	return len(policy.AllowedCAs) == 0 || (exists k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) && info.CA == policy.AllowedCAs[k])
}

ghost
requires idx <= len(policies)
decreases
opaque
pure func validAgainstAllPolicies(policies AbstractChain, info AbstractCertificateChainInfo, idx int) (res bool) {
	return forall k int :: {policies[k]} 0 <= k && k < idx ==> validityOfCA(policies[k], info) && validityOfDomain(policies[k], info)
}

ghost
requires (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> str != base64.StdEncoding.EncodeToString(nil)) &&
	(forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)) &&
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp)) &&
	ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains))
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
opaque
decreases (immutableHash != base64.StdEncoding.EncodeToString(nil) && immutableHash in domain(immutablePolicyCache)) ? unfolding ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) in immutablePolicyCache[immutableHash].depth : 0
pure func abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash string, rootChain AbstractChain, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (res AbstractChain){
	return (len(rootChain) != 0 && immutableHash == rootChain[0].immutableHash) ? rootChain : 
		(immutableHash == base64.StdEncoding.EncodeToString(nil) || !(immutableHash in domain(immutablePolicyCache))) ? seq[AbstractPolicy]{} : (
			seq[AbstractPolicy]{unfolding ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache) in getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, len(immutablePolicyCache[immutableHash].policyHashes), len(immutablePolicyCache[immutableHash].policyHashes))} ++ abstractGetPolicyCertificateChainWithLatestTimestamp(reveal getIssuer(immutableHash, immutablePolicyCache)/*unfolding ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) in immutablePolicyCache[immutableHash].immutableIssuerHash*/, rootChain, immutablePolicyCache, policyCache, policyDnsNameCache))
}

ghost
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k)
requires idx == excl - 1
requires excl > 0
requires excl <= len(spcts)
ensures res == unfoldAndMaxTime(findMaxSPCT(spcts, policyTime, excl - 1, idx), &spcts[excl-1], excl-1)
decreases excl, idx
opaque
pure func findMaxSPCTInner(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, excl int, idx int) (res time.Time) { // idx just to prove termination of findMaxSPCT
	return unfoldAndMaxTime(findMaxSPCT(spcts, policyTime, excl - 1, idx), &spcts[excl-1], excl-1)
}

ghost 
requires idx == excl
requires excl >= 0
requires excl <= len(spcts)
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> cache_SPCT(&spcts[k], k)
decreases idx, excl
opaque
pure func findMaxSPCT(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, excl int, idx int) (res time.Time) {
	return excl == 0 ? policyTime : findMaxSPCTInner(spcts, policyTime, excl, idx - 1) // idx just to prove termination
}

ghost
requires idx == excl - 1
requires excl > 1
requires immutableHash in domain(immutablePolicyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires acc(&immutablePolicyCache[immutableHash].policyHashes) && acc(immutablePolicyCache[immutableHash].policyHashes)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires excl <= len(immutablePolicyCache[immutableHash].policyHashes)
ensures res == let curr := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[excl - 1]].policy, immutablePolicyCache[immutableHash].policyHashes[excl - 1], policyDnsNameCache) in 
	let inner := getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, excl - 1, idx) in
	curr.minMaxTimestamp.Before(inner.minMaxTimestamp) ? curr : inner
decreases idx, excl
opaque
pure func getMinMaxPolicyInner(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, excl int, idx int) (res AbstractPolicy) {
	return let curr := unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[excl - 1]].policy, immutablePolicyCache[immutableHash].policyHashes[excl - 1], policyDnsNameCache) in 
	let inner := getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, excl - 1, idx) in
	curr.minMaxTimestamp.Before(inner.minMaxTimestamp) ? curr : inner
}

ghost
requires ImmutablePolicyCachePermissions_issuer(immutablePolicyCache)
requires immutableHash in domain(immutablePolicyCache)
decreases
opaque 
pure func getIssuer(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry) string {
	return unfolding ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) in immutablePolicyCache[immutableHash].immutableIssuerHash
}

ghost
requires idx == excl
requires excl >= 1
requires immutableHash in domain(immutablePolicyCache)
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires acc(&immutablePolicyCache[immutableHash].policyHashes) && acc(immutablePolicyCache[immutableHash].policyHashes)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires excl <= len(immutablePolicyCache[immutableHash].policyHashes)
decreases idx, excl
opaque
pure func getMinMaxPolicy(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, excl int, idx int) (res AbstractPolicy) {
	return excl == 1 ? (unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy, immutablePolicyCache[immutableHash].policyHashes[0], policyDnsNameCache)) : getMinMaxPolicyInner(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, excl, idx - 1)
}

ghost 
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires hash in domain(policyCache)
decreases
opaque
pure func unfoldAndGetChain(hash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) AbstractChain {
	return unfolding ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache) in abstractGetPolicyCertificateChainWithLatestTimestamp(unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in (
			unfolding PolicyCachePermissions_ImmutableHash(policyCache[hash].immutableHash, hash, immutablePolicyCache) in policyCache[hash].immutableHash), seq[AbstractPolicy]{}, immutablePolicyCache, policyCache, policyDnsNameCache)
}

ghost
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires domainVar in domain(policyDnsNameCache)
requires idx >= 0
requires idx <= len(let c, _ := policyDnsNameCache[domainVar] in c)
ensures len(res) == idx
ensures unfolding PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache) in (unfolding acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache) in (
	forall k int :: {res[k]} 0 <= k && k < len(res) ==> res[k] == let hashes, _ := policyDnsNameCache[domainVar] in unfoldAndGetChain(hashes[k], immutablePolicyCache, policyCache, policyDnsNameCache)))
decreases
pure func abstractFindChainsInner(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int) (res seq[AbstractChain])

ghost
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires domainVar in domain(policyDnsNameCache)
requires idx >= 0
requires idx <= len(let c, _ := policyDnsNameCache[domainVar] in c)
ensures len(res) == idx
decreases
opaque
pure func abstractFindChains(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int) (res seq[AbstractChain]) {
	return abstractFindChainsInner(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
}

ghost
requires forall k int :: {&chains[k]} 0 <= k && k < len(chains) ==> acc(&chains[k]) && acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache)
ensures len(chains) == len(res)
ensures forall k int :: {res[k]} {&chains[k]} 0 <= k && k < len(res) ==> (unfoldAndToAbstractChainFromChain(chains[k], k, policyDnsNameCache) == res[k])
decreases
pure func toAbstractChains(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string) (res seq[AbstractChain])

ghost
requires i >= 0 && i < len(chains)
requires forall k int :: {&chains[k]} i <= k && k < len(chains) ==> acc(&chains[k]) && acc_inj_policyCertificateChain(chains[k], k, policyDnsNameCache)
ensures len(chains) == len(res)
ensures forall k int :: {res[k]} {&chains[k]} i <= k && k < len(res) ==> (unfoldAndToAbstractChainFromChain(chains[k], k, policyDnsNameCache) == res[k])
decreases
pure func toAbstractChainsFrom(chains []*PolicyCertificateChain, policyDnsNameCache dict[string][]string, i int) (res seq[AbstractChain])

ghost 
decreases
opaque
pure func validityOfDomain(policy AbstractPolicy, info AbstractCertificateChainInfo) bool {
	return let normDomain := normalizeDomainSpec(policy.Domain) in let polDomain := strings.GhostCutSuffix(normDomain, ".") in (let dns := strings.GhostCutSuffix(info.DNSName, ".") in (
		let subdomain := strings.GhostCutSuffix(dns, "."+polDomain) in (
			let subdomains := strings.GhostSplit(subdomain, ".") in (
				let target := subdomains[len(subdomains) - 1] in (
					(target in policy.AllowedSubdomains) || (
						!(target in policy.DisallowedSubdomains) && (target in policy.ExcludedSubdomains || !("*" in policy.DisallowedSubdomains))))))))
}

// if implemented: fallback of chain generatoion is empty chain.
// functions that generate a chain must then check if empty, if so also return empty result (in the concrete method we return an error at this point anyway)
// this function and abstractGetDomainLatestMinMaxTimestamp must then require len(chain) > 0
ghost 
decreases
opaque
pure func abstractGetDomainRootIssuanceTimestamp(chain AbstractChain) time.Time 

ghost
requires 0 < excl
requires excl <= len(chains)
decreases excl
opaque
pure func abstractGetNewestChain(chains seq[AbstractChain], excl int) AbstractChain {
	return excl == 1 ? chains[excl - 1] : (abstractGetDomainRootIssuanceTimestamp(chains[excl-1]).After(abstractGetDomainRootIssuanceTimestamp(abstractGetNewestChain(chains, excl - 1))) ?
	 chains[excl-1] : abstractGetNewestChain(chains, excl - 1))
}

ghost
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires leafHash in domain(policyCache)
ensures immutableHash in domain(immutablePolicyCache)
decreases
opaque
pure func getImmutableHashFromLeafHash(leafHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string) (immutableHash string) {
	return unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in unfolding PolicyCachePermissions_ImmutableHash(policyCache[leafHash].immutableHash, leafHash, immutablePolicyCache) in policyCache[leafHash].immutableHash
}

ghost
decreases
opaque
pure func abstractGetDomainLatestMinMaxTimestamp(chain AbstractChain) time.Time

ghost 
requires idx >= 0
requires domainVar in domain(policyDnsNameCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires idx < abstractGetLeafHashesLen(domainVar, policyDnsNameCache, policyCache)
ensures res in domain(policyCache)
decreases
opaque
pure func abstractGetLeafHash(domainVar string, idx int, policyDnsNameCache dict[string][]string, policyCache dict[string]*PolicyCacheEntry) (res string) {
	return unfolding PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache) in (let lH := policyDnsNameCache[domainVar] in (unfolding acc_leafHashes(lH, domainVar, policyCache) in lH[idx]))
}

ghost 
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
ensures domainVar in domain(policyDnsNameCache) ==> res > 0
ensures !(domainVar in domain(policyDnsNameCache)) ==> res == 0
decreases
pure func abstractGetLeafHashesLen(domainVar string, policyDnsNameCache dict[string][]string, policyCache dict[string]*PolicyCacheEntry) (res int) {
	return domainVar in domain(policyDnsNameCache) ? (unfolding PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache) in (let lH := policyDnsNameCache[domainVar] in len(lH))) : 0
}

ghost
decreases
ensures len(parentDomain) < len(subdomain)
pure func abstractParentDomain(subdomain string) (parentDomain string)

ghost
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
requires exclJ >= 0
requires subdomain in domain(policyDnsNameCache) ==> exclJ <= abstractGetLeafHashesLen(subdomain, policyDnsNameCache, policyCache)
requires exclJ > 0 ==> subdomain in domain(policyDnsNameCache)
decreases len(subdomain), exclJ
opaque
pure func abstractGetNewestChainWithRootChain(subdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, exclJ int) AbstractChain {
	return len(subdomain) <= e2ldLen && (!(subdomain in domain(policyDnsNameCache)) || exclJ < 1) ? seq[AbstractPolicy]{} : (
				exclJ < 1 ? (abstractGetNewestChainWithRootChain(abstractParentDomain(subdomain), e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, abstractParentDomain(subdomain) in domain(policyDnsNameCache) ? abstractGetLeafHashesLen(abstractParentDomain(subdomain), policyDnsNameCache, policyCache) : 0)) : (
				let rec := abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ - 1) in (
					let currChain := (unfolding ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache) in abstractGetPolicyCertificateChainWithLatestTimestamp(getImmutableHashFromLeafHash(abstractGetLeafHash(subdomain, exclJ - 1, policyDnsNameCache, policyCache), immutablePolicyCache, policyCache, policyDnsNameCache), rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)) in (len(rec) == 0 || abstractGetDomainLatestMinMaxTimestamp(currChain).After(abstractGetDomainLatestMinMaxTimestamp(rec)) ? currChain : rec))))
}



ghost
requires idx >= 0
requires idx < len(policies)
ensures validAgainstAllPolicies(policies, info, idx) && validityOfCA(policies[idx], info) && validityOfDomain(policies[idx], info) ==> validAgainstAllPolicies(policies, info, idx + 1)
ensures !validAgainstAllPolicies(policies, info, idx) ==> !validAgainstAllPolicies(policies, info, idx + 1)
ensures validAgainstAllPolicies(policies, info, idx) && (!validityOfCA(policies[idx], info) || !validityOfDomain(policies[idx], info)) ==> !validAgainstAllPolicies(policies, info, idx + 1)
decreases
func lemmaValidAgainstAllPoliciesPlus1(policies AbstractChain, info AbstractCertificateChainInfo, idx int) {
	reveal validAgainstAllPolicies(policies, info, idx)
	reveal validAgainstAllPolicies(policies, info, idx + 1)
}

ghost
requires len(policy.AllowedCAs) > 0 && (forall k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) ==> policy.AllowedCAs[k] != info.CA)
ensures !validityOfCA(policy, info)
decreases
func lemmaNotValidAgainstCA(policy AbstractPolicy, info AbstractCertificateChainInfo) {
	reveal validityOfCA(policy, info)
}

ghost
requires len(policy.AllowedCAs) == 0 || (exists k int :: {policy.AllowedCAs[k]} 0 <= k && k < len(policy.AllowedCAs) && policy.AllowedCAs[k] == info.CA)
ensures validityOfCA(policy, info)
decreases
func lemmaValidAgainstCA(policy AbstractPolicy, info AbstractCertificateChainInfo) {
	reveal validityOfCA(policy, info)
}

ghost
ensures validAgainstAllPolicies(abstractChain, info, 0)
decreases
func lemmaCheckNoPolicy(abstractChain AbstractChain, info AbstractCertificateChainInfo) {
	reveal validAgainstAllPolicies(abstractChain, info, 0)
}

ghost 
requires perms > 0
requires acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
requires toAbstractPolicyFromChain(policy, l, policyDnsNameCache) == abstractPolicy
requires unfolding acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainAllowed)
ensures acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
ensures validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainAllowedValid(policy *common.PolicyCertificate, l int, policyDnsNameCache dict[string][]string, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
	reveal validityOfDomain(abstractPolicy, info)
}

ghost 
requires perms > 0
requires acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
requires toAbstractPolicyFromChain(policy, l, policyDnsNameCache) == abstractPolicy
requires unfolding acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainExcluded)
ensures acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
ensures validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainExcludedValid(policy *common.PolicyCertificate, l int, policyDnsNameCache dict[string][]string, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
	reveal validityOfDomain(abstractPolicy, info)
}

ghost 
requires perms > 0
requires acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
requires toAbstractPolicyFromChain(policy, l, policyDnsNameCache) == abstractPolicy
requires unfolding acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms) in unfolding acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms) in (common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName) == common.PolicyAttributeDomainDisallowed)
ensures acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
ensures !validityOfDomain(abstractPolicy, info)
decreases
func lemmaDomainDisallowedInvalid(policy *common.PolicyCertificate, l int, policyDnsNameCache dict[string][]string, abstractPolicy AbstractPolicy, info AbstractCertificateChainInfo, perms perm) {
	unfold acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
	unfold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	unfold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal common.DomainValiditySpec(policy.PolicyAttributes, normalizeDomainSpec(policy.Domain()), info.DNSName)
	fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms / 2)
	fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms / 2)
	reveal strsToSeq(policy.PolicyAttributes.AllowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.DisallowedSubdomains)
	reveal strsToSeq(policy.PolicyAttributes.ExcludedSubdomains)
	fold acc(acc_inj_chainCertificate(policy, l, policyDnsNameCache), perms)
	reveal validityOfDomain(abstractPolicy, info)
}

ghost
requires perms > 0
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires domainVar in domain(policyDnsNameCache)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures domainVar in domain(policyDnsNameCache)
ensures seq[AbstractChain]{} == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, 0)
decreases
func lemmaFindAbstractChainsEmpty(domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, perms perm) {
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, 0)
}

ghost 
requires idx >= 0
requires perms > 0
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires domainVar in domain(policyDnsNameCache)
requires idx < let c, _ := policyDnsNameCache[domainVar] in len(c)
requires idx < len(chains)
requires chains[:idx] == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
requires unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/8) in (let hashes, _ := policyDnsNameCache[domainVar] in len(hashes) > idx)
requires chains[idx] == unfoldAndGetChain(unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/8) in (let hashes, _ := policyDnsNameCache[domainVar] in hashes[idx]), immutablePolicyCache, policyCache, policyDnsNameCache)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures domainVar in domain(policyDnsNameCache)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures idx < let c, _ := policyDnsNameCache[domainVar] in len(c)
ensures chains[:idx + 1] == abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1)
decreases
func lemmaFindAbstractChainsInduction(chains seq[AbstractChain], domainVar string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int, perms perm) {
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
	reveal unfoldAndGetChain(unfolding acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8) in unfolding acc(acc_leafHashes(policyDnsNameCache[domainVar], domainVar, policyCache), 1/8) in (let hashes, _ := policyDnsNameCache[domainVar] in hashes[idx]), immutablePolicyCache, policyCache, policyDnsNameCache)
	reveal abstractFindChains(domainVar, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1)
}

ghost 
requires perms > 0
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
ensures forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
ensures policyTime == findMaxSPCT(spcts, policyTime, 0, 0)
decreases
func lemmaFindMaxSPCTEmpty(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, perms perm) {
	reveal findMaxSPCT(spcts, policyTime, 0, 0)
}

ghost
requires cache_SPCT(t2, idx)
decreases
opaque
pure func unfoldAndMaxTime(t1 time.Time, t2 *common.SignedPolicyCertificateTimestamp, idx int) time.Time {
	return maxTime(t1, unfolding cache_SPCT(t2, idx) in t2.AddedTS)
}

ghost 
requires perms > 0
requires idx >= 0
requires idx < len(spcts)
requires forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
requires currentMax == findMaxSPCT(spcts, policyTime, idx, idx)
ensures forall k int :: {&spcts[k]} 0 <= k && k < len(spcts) ==> acc(cache_SPCT(&spcts[k], k), perms)
ensures unfoldAndMaxTime(currentMax, &spcts[idx], idx) == findMaxSPCT(spcts, policyTime, idx + 1, idx + 1)
decreases
func lemmaFindMaxSPCTInduction(spcts []common.SignedPolicyCertificateTimestamp, policyTime time.Time, currentMax time.Time, idx int, perms perm) {
	reveal findMaxSPCT(spcts, policyTime, idx + 1, idx + 1)
}

ghost
requires immutableHash in domain(immutablePolicyCache)
requires acc(&immutablePolicyCache[immutableHash].policyHashes)
requires len(immutablePolicyCache[immutableHash].policyHashes) > 0
requires PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache)
requires 0 <= idx && idx < len(immutablePolicyCache[immutableHash].policyHashes)
requires acc(&immutablePolicyCache[immutableHash].policyHashes[idx]) && immutablePolicyCache[immutableHash].policyHashes[idx] in domain(policyCache)
decreases
opaque
pure func unfoldAndToAbstractPolicyFromCache(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, idx int) AbstractPolicy {
	return (unfolding PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[idx]].policy, immutablePolicyCache[immutableHash].policyHashes[idx], policyDnsNameCache))
}


ghost 
requires perms > 0
requires cachePerms > 0 
requires immutableHash in domain(immutablePolicyCache)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
ensures forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
ensures len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures unfoldAndToAbstractPolicyFromCache(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, 0) == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, 1, 1)
decreases
func lemmaGetMinMaxPolicyEmpty(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, perms perm, cachePerms perm) {
	reveal unfoldAndToAbstractPolicyFromCache(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, 0)
	assert unfoldAndToAbstractPolicyFromCache(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, 0) == (unfolding acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[0]].policy,  immutablePolicyCache[immutableHash].policyHashes[0], policyDnsNameCache))
	reveal getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, 1, 1)
}

ghost 
requires perms > 0
requires cachePerms > 0 
requires immutableHash in domain(immutablePolicyCache)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires idx >= 1
requires idx < len(immutablePolicyCache[immutableHash].policyHashes)
requires currentPolicy == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx, idx)
requires let curr := unfoldAndToAbstractPolicyFromCache(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx) in
	curr.minMaxTimestamp.Before(currentPolicy.minMaxTimestamp)
requires len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
ensures forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
ensures idx < len(immutablePolicyCache[immutableHash].policyHashes)
ensures len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures unfoldAndToAbstractPolicyFromCache(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx) == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
decreases
func lemmaGetMinMaxPolicyInduction1(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, currentPolicy AbstractPolicy, idx int, perms perm, cachePerms perm) {
	reveal unfoldAndToAbstractPolicyFromCache(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
	assert unfoldAndToAbstractPolicyFromCache(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx) == (unfolding acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[idx]].policy,  immutablePolicyCache[immutableHash].policyHashes[idx], policyDnsNameCache))
	reveal getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
}

ghost 
requires perms > 0
requires cachePerms > 0 
requires immutableHash in domain(immutablePolicyCache)
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
requires forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
requires idx >= 1
requires idx < len(immutablePolicyCache[immutableHash].policyHashes)
requires currentPolicy == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx, idx)
requires let curr := unfoldAndToAbstractPolicyFromCache(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx) in
	!curr.minMaxTimestamp.Before(currentPolicy.minMaxTimestamp)
requires len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(&immutablePolicyCache[immutableHash].policyHashes, cachePerms) && acc(immutablePolicyCache[immutableHash].policyHashes, cachePerms)
ensures forall k int :: {&immutablePolicyCache[immutableHash].policyHashes[k]} 0 <= k && k < len(immutablePolicyCache[immutableHash].policyHashes) ==> immutablePolicyCache[immutableHash].policyHashes[k] in domain(policyCache)
ensures idx < len(immutablePolicyCache[immutableHash].policyHashes)
ensures len(immutablePolicyCache[immutableHash].policyHashes) > 0
ensures currentPolicy == getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
decreases
func lemmaGetMinMaxPolicyInduction2(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, currentPolicy AbstractPolicy, idx int, perms perm, cachePerms perm) {
	reveal unfoldAndToAbstractPolicyFromCache(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx)
	assert unfoldAndToAbstractPolicyFromCache(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx) == (unfolding acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms) in toAbstractPolicyFromCache(policyCache[immutablePolicyCache[immutableHash].policyHashes[idx]].policy,  immutablePolicyCache[immutableHash].policyHashes[idx], policyDnsNameCache))
	reveal getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, idx + 1, idx + 1)
}

ghost
requires len(chains) > 0
ensures abstractGetNewestChain(chains, 1) == chains[0]
decreases
func lemmaGetNewestChainBaseCase(chains seq[AbstractChain]) {
	reveal abstractGetNewestChain(chains, 1)
}

ghost 
requires 0 < excl
requires excl < len(chains)
requires abstractGetNewestChain(chains, excl) == curr
requires abstractGetDomainRootIssuanceTimestamp(chains[excl]).After(abstractGetDomainRootIssuanceTimestamp(curr))
ensures abstractGetNewestChain(chains, excl + 1) == chains[excl]
decreases
func lemmaGetNewestChainInduction1(chains seq[AbstractChain], excl int, curr AbstractChain) {
	reveal abstractGetNewestChain(chains, excl + 1)
}

ghost 
requires 0 < excl
requires excl < len(chains)
requires abstractGetNewestChain(chains, excl) == curr
requires !abstractGetDomainRootIssuanceTimestamp(chains[excl]).After(abstractGetDomainRootIssuanceTimestamp(curr))
ensures abstractGetNewestChain(chains, excl + 1) == curr
decreases
func lemmaGetNewestChainInduction2(chains seq[AbstractChain], excl int, curr AbstractChain) {
	reveal abstractGetNewestChain(chains, excl + 1)
}

ghost 
requires perms > 0
requires len(subdomain) == e2ldLen
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/8)
ensures abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0) == seq[AbstractPolicy]{}
decreases
func abstractGetNewestChainWithRootChainBaseCase(subdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, perms perm)  {
	reveal abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0)
}

ghost 
requires perms > 0
requires e2ldLen <= len(subdomain)
requires exclJ >= 0
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
requires subdomain in domain(policyDnsNameCache)
requires exclJ < abstractGetLeafHashesLen(subdomain, policyDnsNameCache, policyCache)
requires abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ) == maxChain
requires len(maxChain) == 0 || abstractGetDomainLatestMinMaxTimestamp(unfolding acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8) in abstractGetPolicyCertificateChainWithLatestTimestamp(getImmutableHashFromLeafHash(abstractGetLeafHash(subdomain, exclJ, policyDnsNameCache, policyCache), immutablePolicyCache, policyCache, policyDnsNameCache), rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)).After(abstractGetDomainLatestMinMaxTimestamp(maxChain))
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
ensures abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ + 1) == (unfolding acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8) in abstractGetPolicyCertificateChainWithLatestTimestamp(getImmutableHashFromLeafHash(abstractGetLeafHash(subdomain, exclJ, policyDnsNameCache, policyCache), immutablePolicyCache, policyCache, policyDnsNameCache), rootChain, immutablePolicyCache, policyCache, policyDnsNameCache))
decreases
func abstractGetNewestChainWithRootChainInduction1SameSubdomain(subdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, exclJ int, maxChain AbstractChain, perms perm)  {
	reveal abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ + 1)
}

ghost 
requires perms > 0
requires len(subdomain) >= e2ldLen
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
requires abstractParentDomain(nextSubdomain) == subdomain
requires abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, abstractGetLeafHashesLen(subdomain, policyDnsNameCache, policyCache)) == maxChain
requires len(nextSubdomain) > len(subdomain)
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
ensures abstractGetNewestChainWithRootChain(nextSubdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0) == maxChain
decreases
func abstractGetNewestChainWithRootChainInductionNextSubdomain(subdomain string, nextSubdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, maxChain AbstractChain, perms perm)  {
	reveal abstractGetNewestChainWithRootChain(nextSubdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0)
}

ghost 
requires perms > 0
requires e2ldLen <= len(subdomain)
requires exclJ >= 0
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
requires subdomain in domain(policyDnsNameCache)
requires exclJ < abstractGetLeafHashesLen(subdomain, policyDnsNameCache, policyCache)
requires abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ) == maxChain
requires len(maxChain) != 0 && !abstractGetDomainLatestMinMaxTimestamp(unfolding acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8) in abstractGetPolicyCertificateChainWithLatestTimestamp(getImmutableHashFromLeafHash(abstractGetLeafHash(subdomain, exclJ, policyDnsNameCache, policyCache), immutablePolicyCache, policyCache, policyDnsNameCache), rootChain, immutablePolicyCache, policyCache, policyDnsNameCache)).After(abstractGetDomainLatestMinMaxTimestamp(maxChain))
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
ensures abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ + 1) == maxChain
decreases
func abstractGetNewestChainWithRootChainInduction2SameSubdomain(subdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, exclJ int, maxChain AbstractChain, perms perm)  {
	reveal abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, exclJ + 1)
}

ghost 
requires perms > 0
requires len(subdomain) >= e2ldLen
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
requires acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
requires !(nextSubdomain in domain(policyDnsNameCache))
requires abstractGetNewestChainWithRootChain(subdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, abstractGetLeafHashesLen(subdomain, policyDnsNameCache, policyCache)) == maxChain
requires abstractParentDomain(nextSubdomain) == subdomain
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures acc(ImmutablePolicyCachePermissions(immutablePolicyCache, policyCache), 1/8)
ensures acc(PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache), 1/16)
ensures abstractGetNewestChainWithRootChain(nextSubdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0) == maxChain
decreases
func abstractGetNewestChainWithRootChainSkip(subdomain string, nextSubdomain string, e2ldLen int, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, rootChain AbstractChain, maxChain AbstractChain, perms perm)  {
	reveal abstractGetNewestChainWithRootChain(nextSubdomain, e2ldLen, immutablePolicyCache, policyCache, policyDnsNameCache, rootChain, 0)
}

ghost 
requires len(subdomains) > 0
ensures abstractGetSubdomainString(e2ld, subdomains, 1) == e2ld
decreases
func lemmaGetSubdomainStringBaseCase(e2ld string, subdomains seq[string]) {
	reveal abstractGetSubdomainString(e2ld, subdomains, 1)
}

ghost
requires idx >= 1
requires idx <= len(subdomains) - 1
requires abstractGetSubdomainString(e2ld, subdomains, idx) == currentStr
ensures abstractGetSubdomainString(e2ld, subdomains, idx + 1) == subdomains[len(subdomains) - 1 - idx] + "." + currentStr
decreases
func lemmaGetSubdomainStringInductionStep(e2ld string, subdomains seq[string], idx int, currentStr string) {
	reveal abstractGetSubdomainString(e2ld, subdomains, idx + 1)
}

ghost
requires !strings.GhostContains(subdomain, ".")
ensures abstractParentDomain(subdomain + "." + parentDomain) == parentDomain
decreases
func lemmaParentDomain(subdomain string, parentDomain string)

ghost
requires perms > 0
requires acc(resChain, perms) &&
	len(resChain.PolicyCertificates) >= 1 &&
	(forall l int :: {&resChain.PolicyCertificates[l]} 0 <= l && l < len(resChain.PolicyCertificates) ==> acc(&resChain.PolicyCertificates[l], perms)) &&
	(forall l int :: {&resChain.PolicyCertificates[l]} 0 <= l && l < len(resChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(resChain.PolicyCertificates[l], len(resChain.PolicyCertificates) - l - 1, policyDnsNameCache), perms))
requires acc(parentChain, perms) &&
	len(parentChain.PolicyCertificates) >= 1 &&
	(forall l int :: {&parentChain.PolicyCertificates[l]} 0 <= l && l < len(parentChain.PolicyCertificates) ==> acc(&parentChain.PolicyCertificates[l], perms)) &&
	(forall l int :: {&parentChain.PolicyCertificates[l]} 0 <= l && l < len(parentChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(parentChain.PolicyCertificates[l], len(parentChain.PolicyCertificates) - l - 1, policyDnsNameCache), perms))
requires len(resChain.PolicyCertificates) == len(parentChain.PolicyCertificates) + 1
requires forall k int :: {&resChain.PolicyCertificates[k]} 1 <= k && k < len(resChain.PolicyCertificates) ==> resChain.PolicyCertificates[k] == parentChain.PolicyCertificates[k - 1]
requires toAbstractPolicyFromChain(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 0 - 1, policyDnsNameCache) == policy
requires toAbstractChainFromChain(parentChain.PolicyCertificates, policyDnsNameCache) == parentChainAbs
ensures acc(acc_policyCertificateChain(resChain, policyDnsNameCache), perms)
ensures acc(acc_policyCertificateChain(parentChain, policyDnsNameCache), perms)
ensures unfoldAndToAbstractChainFromChain2(resChain, (policyDnsNameCache))[1:] == unfoldAndToAbstractChainFromChain2(parentChain, policyDnsNameCache)
ensures unfoldAndToAbstractChainFromChain2(resChain, policyDnsNameCache) == seq[AbstractPolicy]{policy} ++ parentChainAbs
decreases
func lemmaAddToChainAndFold(resChain *PolicyCertificateChain, parentChain *PolicyCertificateChain, policy AbstractPolicy, parentChainAbs AbstractChain, policyDnsNameCache dict[string][]string, perms perm) {
	fold acc(acc_policyCertificateChain(resChain, policyDnsNameCache), perms)
	fold acc(acc_policyCertificateChain(parentChain, policyDnsNameCache), perms)
	reveal unfoldAndToAbstractChainFromChain2(parentChain, (policyDnsNameCache))
	reveal unfoldAndToAbstractChainFromChain2(resChain, policyDnsNameCache)
}

ghost
requires perms > 0
requires acc(resChain, perms) &&
	len(resChain.PolicyCertificates) >= 1 &&
	(forall l int :: {&resChain.PolicyCertificates[l]} 0 <= l && l < len(resChain.PolicyCertificates) ==> acc(&resChain.PolicyCertificates[l], perms)) &&
	(forall l int :: {&resChain.PolicyCertificates[l]} 0 <= l && l < len(resChain.PolicyCertificates) ==> acc(acc_inj_chainCertificate(resChain.PolicyCertificates[l], len(resChain.PolicyCertificates) - l - 1, policyDnsNameCache), perms))
requires len(resChain.PolicyCertificates) == 1
requires toAbstractPolicyFromChain(resChain.PolicyCertificates[0], len(resChain.PolicyCertificates) - 0 - 1, policyDnsNameCache) == policy
ensures acc(acc_policyCertificateChain(resChain, policyDnsNameCache), perms)
ensures unfoldAndToAbstractChainFromChain2(resChain, policyDnsNameCache) == seq[AbstractPolicy]{policy}
decreases
func lemmaAddToChainAndFold2(resChain *PolicyCertificateChain, policy AbstractPolicy, policyDnsNameCache dict[string][]string, perms perm) {
	fold acc(acc_policyCertificateChain(resChain, policyDnsNameCache), perms)
	reveal unfoldAndToAbstractChainFromChain2(resChain, policyDnsNameCache)
}

ghost
requires perms > 0
requires cachePerms > 0
requires acc(acc_policyCertificateChain(resChain, policyDnsNameCache), perms)
requires rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
requires (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> str != base64.StdEncoding.EncodeToString(nil)) && 
	(forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes, cachePerms) && acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache), cachePerms)) &&
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp, cachePerms)) &&
	acc(ImmutablePolicyCachePermissions_issuer(immutablePolicyCache), cachePerms) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs, cachePerms)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains, cachePerms)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains, cachePerms)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains, cachePerms))
requires acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
requires immutableHash != base64.StdEncoding.EncodeToString(nil) && immutableHash in domain(immutablePolicyCache)
requires let rc := rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, policyDnsNameCache) : seq[AbstractPolicy]{} in !(len(rc) != 0 && immutableHash == rc[0].immutableHash) 
requires unfoldAndToAbstractChainFromChain2(resChain, policyDnsNameCache) == seq[AbstractPolicy]{unfolding acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[immutableHash].policyHashes, immutableHash, policyCache), cachePerms) in getMinMaxPolicy(immutableHash, immutablePolicyCache, policyCache, policyDnsNameCache, len(immutablePolicyCache[immutableHash].policyHashes), len(immutablePolicyCache[immutableHash].policyHashes))} ++ abstractGetPolicyCertificateChainWithLatestTimestamp(getIssuer(immutableHash, immutablePolicyCache), rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, policyDnsNameCache) : seq[AbstractPolicy]{}, immutablePolicyCache, policyCache, policyDnsNameCache)
ensures acc(acc_policyCertificateChain(resChain, policyDnsNameCache), perms)
ensures rootChain != nil ==> acc(acc_policyCertificateChain(rootChain, policyDnsNameCache), perms)
ensures (forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> str != base64.StdEncoding.EncodeToString(nil)) &&
	(forall str string :: {&immutablePolicyCache[str].policyHashes} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyHashes, cachePerms) && acc(ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache), cachePerms)) &&
    (forall str string :: {&immutablePolicyCache[str].timestamp} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].timestamp, cachePerms)) &&
	acc(ImmutablePolicyCachePermissions_issuer(immutablePolicyCache), cachePerms) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedCAs} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedCAs, cachePerms)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.AllowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.AllowedSubdomains, cachePerms)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.DisallowedSubdomains, cachePerms)) &&
	(forall str string :: {&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains} str in domain(immutablePolicyCache) ==> acc(&immutablePolicyCache[str].policyAttributes.ExcludedSubdomains, cachePerms))
ensures acc(PolicyCachePermissions(policyCache, immutablePolicyCache, policyDnsNameCache), perms)
ensures immutableHash != base64.StdEncoding.EncodeToString(nil) && immutableHash in domain(immutablePolicyCache)
ensures let rc := rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, policyDnsNameCache) : seq[AbstractPolicy]{} in !(len(rc) != 0 && immutableHash == rc[0].immutableHash) 
ensures unfoldAndToAbstractChainFromChain2(resChain, policyDnsNameCache) == abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, policyDnsNameCache) : seq[AbstractPolicy]{}, immutablePolicyCache, policyCache, policyDnsNameCache)
decreases
func lemmaChainGenerationSpec(resChain *PolicyCertificateChain, rootChain *PolicyCertificateChain, immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry, policyDnsNameCache dict[string][]string, perms perm, cachePerms perm) {
	reveal abstractGetPolicyCertificateChainWithLatestTimestamp(immutableHash, rootChain != nil ? unfoldAndToAbstractChainFromChain2(rootChain, policyDnsNameCache) : seq[AbstractPolicy]{}, immutablePolicyCache, policyCache, policyDnsNameCache)
	reveal unfoldAndToAbstractChainFromChain2(resChain, policyDnsNameCache)
	if rootChain != nil {
		reveal unfoldAndToAbstractChainFromChain2(rootChain, policyDnsNameCache)
	}
	reveal isIssuerNil(immutableHash, immutablePolicyCache)
}

ghost
requires ImmutablePolicyCachePermissions_issuer(immutablePolicyCache)
requires immutableHash in domain(immutablePolicyCache)
decreases
opaque
pure func isIssuerNil(immutableHash string, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry) bool {
	return unfolding ImmutablePolicyCachePermissions_issuer(immutablePolicyCache) in immutablePolicyCache[immutableHash].immutableIssuerHash == base64.StdEncoding.EncodeToString(nil)
}

ghost
requires perms > 0
requires acc(acc_policyCertificateChain(chain, policyDnsNameCache), perms)
requires unfolding acc(acc_policyCertificateChain(chain, policyDnsNameCache), perms) in len(chain.PolicyCertificates) != 0
requires unfolding acc(acc_policyCertificateChain(chain, policyDnsNameCache), perms) in base64.StdEncoding.AbstractEncodeToString(crypto.abstractComputeHashAsSigner(chain.PolicyCertificates[0])) == immHash
ensures acc(acc_policyCertificateChain(chain, policyDnsNameCache), perms)
ensures len(unfoldAndToAbstractChainFromChain2(chain, policyDnsNameCache)) != 0
ensures unfoldAndToAbstractChainFromChain2(chain, policyDnsNameCache)[0].immutableHash == immHash
decreases
func lemmaAbstractChainZero(chain *PolicyCertificateChain, policyDnsNameCache dict[string][]string, immHash string, perms perm) {
	reveal unfoldAndToAbstractChainFromChain2(chain, policyDnsNameCache)
}

ghost
requires perms > 0
requires acc(acc_policyCertificateChain(chain, policyDnsNameCache), perms)
ensures acc(acc_policyCertificateChain(chain, policyDnsNameCache), perms)
ensures unfolding acc(acc_policyCertificateChain(chain, policyDnsNameCache), perms) in len(chain.PolicyCertificates) == 0 ==> len(unfoldAndToAbstractChainFromChain2(chain, policyDnsNameCache)) == 0
ensures (unfolding acc(acc_policyCertificateChain(chain, policyDnsNameCache), perms) in (len(chain.PolicyCertificates) > 0 && base64.StdEncoding.AbstractEncodeToString(crypto.abstractComputeHashAsSigner(chain.PolicyCertificates[0])) != immHash)) ==> (len(unfoldAndToAbstractChainFromChain2(chain, policyDnsNameCache)) > 0 && unfoldAndToAbstractChainFromChain2(chain, policyDnsNameCache)[0].immutableHash != immHash)
decreases
func lemmaAbstractChainZero2(chain *PolicyCertificateChain, policyDnsNameCache dict[string][]string, immHash string, perms perm) {
	reveal unfoldAndToAbstractChainFromChain2(chain, policyDnsNameCache)
}
