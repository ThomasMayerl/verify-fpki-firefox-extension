package cache_v2

import (
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"log"
	"path/filepath"
	"strings"
	"time"
	"fpki/pkg/common"
	"fpki/pkg/common/crypto"
	"fpki/pkg/util"
)

// TODO: integrate map server proof validation
// TODO: might want to have a more forgiving error handling
//       (right now, logs fatally)

type PolicyCacheEntry struct {
	// policy to store
	policy *common.PolicyCertificate

	// hash over the policy's immutable fields
	immutableHash string
}

type ImmutablePolicyCacheEntry struct {
	// policies with these immutable fields
	policyHashes []string

	// attributes
	policyAttributes common.PolicyAttributes

	// timestamp
	timestamp time.Time

	// hash over the parent's immutable fields
	immutableIssuerHash string

	// added
	ghost depth int
}

// cache mapping base64 encoded policy hash to a PolicyCacheEntry
var policyCache@ = map[string]*PolicyCacheEntry{}

// cache mapping base64 encoded hash over the immutable policy
// certificate fields to a PolicyCacheEntry
var immutablePolicyCache@ = map[string]*ImmutablePolicyCacheEntry{}

// map containing all policy hashes that should be ignored
// (not be requested from the map server again) in the future
// (e.g., because they correspond to expired policies)
var ignoredPolicyHashes@ = map[string]struct{}{}

// cache mapping a dns name to a list of policy hashes
// of policies that correspond to this dns name
var policyDnsNameCache@ = map[string][]string{}


// initialize the caches based on the (root) policy certificates in
// the PCA trust store (trust store location: trustStoreDir)
preserves acc(&policyCache)
preserves acc(&immutablePolicyCache)
preserves acc(&policyDnsNameCache)
preserves acc(&ignoredPolicyHashes)
ensures outPerms > 0 && outPerms <= 1
ensures acc(policyCache)
ensures acc(immutablePolicyCache)
ensures acc(policyDnsNameCache)
ensures acc(ignoredPolicyHashes)
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
ensures PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
func InitializePolicyCache(trustStoreDir string) (res int, ghost outPerms perm) { // added return param names
	policyCache = map[string]*PolicyCacheEntry{}
	immutablePolicyCache = map[string]*ImmutablePolicyCacheEntry{}
	ignoredPolicyHashes = map[string]struct{}{}
	policyDnsNameCache = map[string][]string{}

	fold PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache))
	fold ImmutablePolicyCachePermissions_issuer(dict(immutablePolicyCache))
	fold ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
	fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))

	files, err := cacheFileSystem.ReadDir(trustStoreDir)
	if err != nil {
		log.Fatal(err)
	}
	added := 0

	ghost perms := perm(1)

	invariant perms > 0
	invariant perms <= 1
	invariant forall k int :: {&files[k]} 0 <= k && k < len(files) ==> acc(&files[k]) && files[k] != nil
	invariant acc(&policyCache)
	invariant acc(&immutablePolicyCache)
	invariant acc(&policyDnsNameCache)
	invariant acc(&ignoredPolicyHashes)
	invariant acc(policyCache)
	invariant acc(immutablePolicyCache)
	invariant acc(policyDnsNameCache)
	invariant acc(ignoredPolicyHashes)
	invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), perms)
	invariant ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
	invariant PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
	for _, file := range files {
		if !strings.HasSuffix(file.Name(), ".pc") {
			continue
		}

		// parse trust root certificate
		path := filepath.Join(trustStoreDir, file.Name())
		fileBytes, err := cacheFileSystem.ReadFile(path)
		if err != nil {
			log.Fatal(err)
		}
		fmt.Printf("initializing with root (%s): %s\n", file, fileBytes)
		policy, err := util.PolicyCertificateFromBytes(fileBytes)
		if err != nil {
			log.Fatalf("loading policy certificate from trust store (%s): %s", path, err)
		}
		ghost
		invariant acc(&policy.SPCTs)
		invariant forall k int :: {&policy.SPCTs[k]} 0 <= k && k < i ==> acc(cache_SPCT(&policy.SPCTs[k], k), perms)
		invariant forall k int :: {&policy.SPCTs[k]} i <= k && k < len(policy.SPCTs) ==> acc(&policy.SPCTs[k])
		invariant 0 <= i && i <= len(policy.SPCTs)
		decreases len(policy.SPCTs) - i
		for i := 0; i < len(policy.SPCTs); i++ {
			fold acc(cache_SPCT(&policy.SPCTs[i], i), perms)
		}

		fold acc(cache_SPCTs(policy.SPCTs), perms)

		policyHash := getPolicyHash(policy, 1/2)
		immutablePolicyHash := getImmutablePolicyHash(policy, 1/2)
		immutableIssuerHash := getIssuerHash(policy)

		fold acc(policy_IssuerHash(policy.IssuerHash), perms)
		fold acc(acc_strs(policy.PolicyAttributes.AllowedCAs), perms)
		fold acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), perms)
		fold acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), perms)
		fold acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), perms)

		tmp := allocatePolicyCacheEntries(policy, policyHash, immutablePolicyHash, immutableIssuerHash, perms)
		ghost perms = tmp // remove permissions already to keep allocatePolicyCacheEntries simpler (might be called multiple times for same certificate from other functions?)

		added += 1
	}
	return added, perms
}

// takes a list of certificate hashes
// and returns a list containing all certificate hashes
// from the input that are not yet cached
preserves acc(&ignoredPolicyHashes, 1/2)
preserves acc(ignoredPolicyHashes, 1/2)
preserves acc(&policyCache, 1/2)
preserves acc(policyCache, 1/2)
preserves forall k int :: {&policyHashes[k]} 0 <= k && k < len(policyHashes) ==> acc(&policyHashes[k])
ensures forall k int :: {&res[k]} 0 <= k && k < len(res) ==> acc(&res[k])
func GetMissingPolicyHashesList(policyHashes []string) (res []string) { //Added return param name

	var missingPolicyHashes []string
	invariant acc(&ignoredPolicyHashes, 1/2)
	invariant acc(ignoredPolicyHashes, 1/2)
	invariant acc(&policyCache, 1/2)
	invariant acc(policyCache, 1/2) 
	invariant forall k int :: {&policyHashes[k]} 0 <= k && k < len(policyHashes) ==> acc(&policyHashes[k])
	invariant forall k int :: {&missingPolicyHashes[k]} 0 <= k && k < len(missingPolicyHashes) ==> acc(&missingPolicyHashes[k])
	for _, policyHash := range policyHashes {

		// if the certificate either should be ignored (e.g., we have seen
		// it before and it has expired) or it is already cached,
		// do not include it in the output (it does not have to
		// be requested again)
		_, ignore := ignoredPolicyHashes[policyHash]
		if ignore {
			continue
		}
		// TODO WHY DOES THIS NOT WORK IN GOBRA?
		// if certificateCache[policyHash] == nil {
		// TODO ISN'T THIS WRONG? COPY-PASTE?
		/*if cCacheEntry, _ := certificateCache[policyHash]; cCacheEntry == nil {
			missingPolicyHashes = append(perm(1), missingPolicyHashes, policyHash)
		}*/
		// SHOULD BE LIKE THIS?
		if pCacheEntry, _ := policyCache[policyHash]; pCacheEntry == nil {
			missingPolicyHashes = append(perm(1), missingPolicyHashes, policyHash)
		}
	}
	return missingPolicyHashes
}

requires acc(policiesInRequest)
ensures res === let arr, ok := policiesInRequest[str] in arr
decreases
pure func getPoliciesFromMap(policiesInRequest map[string][]*common.PolicyCertificate, str string) (res []*common.PolicyCertificate) 

requires acc(&policyDnsNameCache, 1/2)
requires acc(policyDnsNameCache, 1/2)
ensures res === let entry, ok := policyDnsNameCache[str] in entry
decreases
pure func getHashesFromDnsCache(str string) (res []string)

requires forall k int :: {&arr[k]} 0 <= k && k < len(arr) ==> acc(&arr[k])
ensures forall k int :: {&newArr[k]} 0 <= k && k < len(newArr) ==> acc(&newArr[k]) 
ensures len(newArr) == old(len(arr)) + 1
ensures newArr[len(newArr) - 1] == toAdd
ensures forall k int :: {&newArr[k]} {&arr[k]} 0 <= k && k < len(arr) ==> old(arr[k]) == newArr[k]
func appendPolicyCertificate(arr []*common.PolicyCertificate, toAdd *common.PolicyCertificate) (newArr []*common.PolicyCertificate)

// adds a list of certificates to the cache
// TODO: pot. hashing the certificates is unnecessary as the hashes might already
// be available from the first mapserver response
requires inPerms > 0 && inPerms <= 1
requires (forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> acc(&policies[k], _)) &&
(forall k int :: {&policies[k].SPCTs} 0 <= k && k < len(policies) ==> acc(&policies[k].SPCTs, inPerms) && acc(cache_SPCTs(policies[k].SPCTs), inPerms)) &&
(forall k int :: {&policies[k].IssuerHash} 0 <= k && k < len(policies) ==> acc(&policies[k].IssuerHash, inPerms) && acc(policy_IssuerHash(policies[k].IssuerHash), inPerms)) &&
(forall k int :: {&policies[k].TimeStamp} 0 <= k && k < len(policies) ==> acc(&policies[k].TimeStamp, inPerms)) &&
(forall k int :: {&policies[k].DomainField} 0 <= k && k < len(policies) ==> acc(&policies[k].DomainField, inPerms)) &&
(forall k int :: {&policies[k].PolicyAttributes.ExcludedSubdomains} 0 <= k && k < len(policies) ==> acc(&policies[k].PolicyAttributes.ExcludedSubdomains, inPerms) && acc(acc_strs(policies[k].PolicyAttributes.ExcludedSubdomains), inPerms)) &&
(forall k int :: {&policies[k].PolicyAttributes.DisallowedSubdomains} 0 <= k && k < len(policies) ==> acc(&policies[k].PolicyAttributes.DisallowedSubdomains, inPerms) && acc(acc_strs(policies[k].PolicyAttributes.DisallowedSubdomains), inPerms)) &&
(forall k int :: {&policies[k].PolicyAttributes.AllowedSubdomains} 0 <= k && k < len(policies) ==> acc(&policies[k].PolicyAttributes.AllowedSubdomains, inPerms) && acc(acc_strs(policies[k].PolicyAttributes.AllowedSubdomains), inPerms)) &&
(forall k int :: {&policies[k].PolicyAttributes.AllowedCAs} 0 <= k && k < len(policies) ==> acc(&policies[k].PolicyAttributes.AllowedCAs, inPerms) && acc(acc_strs(policies[k].PolicyAttributes.AllowedCAs), inPerms))
requires acc(&policyCache)
requires acc(policyCache)
requires acc(&immutablePolicyCache)
requires acc(immutablePolicyCache)
requires acc(&policyDnsNameCache)
requires acc(policyDnsNameCache)
requires acc(&ignoredPolicyHashes)
requires acc(ignoredPolicyHashes)
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
requires ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
requires PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
ensures outPerms <= inPerms
ensures outPerms > 0 && outPerms <= 1
ensures acc(&policyCache)
ensures acc(policyCache)
ensures acc(&immutablePolicyCache)
ensures acc(immutablePolicyCache)
ensures acc(&policyDnsNameCache)
ensures acc(policyDnsNameCache)
ensures acc(&ignoredPolicyHashes)
ensures acc(ignoredPolicyHashes)
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
ensures PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
preserves acc(&NCertificatesAdded)
preserves acc(&MS)
preserves acc(&MSS)
ensures forall k int :: {&res[k]} 0 <= k && k < len(res) ==> acc(&res[k])
func AddPoliciesToCache(policies []*common.PolicyCertificate, ghost inPerms perm) (res []string, ghost outPerms perm) { // added return param name
	ghost outPerms = inPerms
	
	nEntriesBefore := len(policyCache)
	now := time.Now()

	// fmt.Printf("policy 0: %v\n", policies[0])
	// create a map of all policies in the request, indicating whether
	// the policy has already been processed
	policiesInRequestProcessed := map[*common.PolicyCertificate]bool{}
	// create a map of all policies for a given hash over the immutable
	// policy fields
	policiesInRequest := map[string][]*common.PolicyCertificate{}

	// The len(policies) > 0 condition in some invariants are necessary because 0 <= i can otherwise not be proven.
	// Gobra Issue #934

	invariant acc(policiesInRequestProcessed)
	invariant acc(policiesInRequest)
	invariant forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> acc(&policies[k], _)
	invariant len(policies) > 0 ==> 0 <= i && i <= len(policies)
	invariant len(policies) > 0 ==> (forall k int :: {&policies[k].SPCTs} idx <= k && k < len(policies) ==> acc(&policies[k].SPCTs, outPerms) && acc(cache_SPCTs(policies[k].SPCTs), outPerms)) &&
		(forall k int :: {&policies[k].IssuerHash} idx <= k && k < len(policies) ==> acc(&policies[k].IssuerHash, outPerms) && acc(policy_IssuerHash(policies[k].IssuerHash), outPerms)) &&
		(forall k int :: {&policies[k].TimeStamp} idx <= k && k < len(policies) ==> acc(&policies[k].TimeStamp, outPerms)) &&
		(forall k int :: {&policies[k].DomainField} idx <= k && k < len(policies) ==> acc(&policies[k].DomainField, outPerms)) &&
		(forall k int :: {&policies[k].PolicyAttributes.ExcludedSubdomains} idx <= k && k < len(policies) ==> acc(&policies[k].PolicyAttributes.ExcludedSubdomains, outPerms) && acc(acc_strs(policies[k].PolicyAttributes.ExcludedSubdomains), outPerms)) &&
		(forall k int :: {&policies[k].PolicyAttributes.DisallowedSubdomains} idx <= k && k < len(policies) ==> acc(&policies[k].PolicyAttributes.DisallowedSubdomains, outPerms) && acc(acc_strs(policies[k].PolicyAttributes.DisallowedSubdomains), outPerms)) &&
		(forall k int :: {&policies[k].PolicyAttributes.AllowedSubdomains} idx <= k && k < len(policies) ==> acc(&policies[k].PolicyAttributes.AllowedSubdomains, outPerms) && acc(acc_strs(policies[k].PolicyAttributes.AllowedSubdomains), outPerms)) &&
		(forall k int :: {&policies[k].PolicyAttributes.AllowedCAs} idx <= k && k < len(policies) ==> acc(&policies[k].PolicyAttributes.AllowedCAs, outPerms) && acc(acc_strs(policies[k].PolicyAttributes.AllowedCAs), outPerms))
	invariant forall str string :: {str in domain(policiesInRequest)} str in domain(policiesInRequest) ==> getPoliciesFromMap(policiesInRequest, str) != nil
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k]} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k]) && getPoliciesFromMap(policiesInRequest, str)[k] in domain(policiesInRequestProcessed)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].SPCTs} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].SPCTs, outPerms) && acc(cache_SPCTs(getPoliciesFromMap(policiesInRequest, str)[k].SPCTs), outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash, outPerms) && acc(policy_IssuerHash(getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash), outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].TimeStamp} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].TimeStamp, outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].DomainField} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].DomainField, outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains), outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains), outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains), outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs), outPerms)
	invariant len(policies) > 0 ==> forall k int :: {&policies[k]} 0 <= k && k < idx ==> (exists str string, l int :: {&getPoliciesFromMap(policiesInRequest, str)[l]} str in domain(policiesInRequest) && 0 <= l && l < len(getPoliciesFromMap(policiesInRequest, str)) && policies[k] == getPoliciesFromMap(policiesInRequest, str)[l])
	invariant len(policies) > 0 ==> forall k int :: {&policies[k].SPCTs} idx <= k && k < len(policies) ==> (forall str string, l int :: {&getPoliciesFromMap(policiesInRequest, str)[l].SPCTs} str in domain(policiesInRequest) && 0 <= l && l < len(getPoliciesFromMap(policiesInRequest, str)) ==> getPoliciesFromMap(policiesInRequest, str)[l].SPCTs !== policies[k].SPCTs)
	invariant len(policies) > 0 ==> forall k int :: {&policies[k].IssuerHash} idx <= k && k < len(policies) ==> (forall str string, l int :: {&getPoliciesFromMap(policiesInRequest, str)[l].IssuerHash} str in domain(policiesInRequest) && 0 <= l && l < len(getPoliciesFromMap(policiesInRequest, str)) ==> policies[k].IssuerHash !== getPoliciesFromMap(policiesInRequest, str)[l].IssuerHash)
	invariant len(policies) > 0 ==> forall k int :: {&policies[k].PolicyAttributes.AllowedCAs} idx <= k && k < len(policies) ==> (forall str string, l int :: {&getPoliciesFromMap(policiesInRequest, str)[l].PolicyAttributes.AllowedCAs} str in domain(policiesInRequest) && 0 <= l && l < len(getPoliciesFromMap(policiesInRequest, str)) ==> policies[k].PolicyAttributes.AllowedCAs !== getPoliciesFromMap(policiesInRequest, str)[l].PolicyAttributes.AllowedCAs)
	invariant len(policies) > 0 ==> forall k int :: {&policies[k].PolicyAttributes.AllowedSubdomains} idx <= k && k < len(policies) ==> (forall str string, l int :: {&getPoliciesFromMap(policiesInRequest, str)[l].PolicyAttributes.AllowedSubdomains} str in domain(policiesInRequest) && 0 <= l && l < len(getPoliciesFromMap(policiesInRequest, str)) ==> policies[k].PolicyAttributes.AllowedSubdomains !== getPoliciesFromMap(policiesInRequest, str)[l].PolicyAttributes.AllowedSubdomains)
	invariant len(policies) > 0 ==> forall k int :: {&policies[k].PolicyAttributes.DisallowedSubdomains} idx <= k && k < len(policies) ==> (forall str string, l int :: {&getPoliciesFromMap(policiesInRequest, str)[l].PolicyAttributes.DisallowedSubdomains} str in domain(policiesInRequest) && 0 <= l && l < len(getPoliciesFromMap(policiesInRequest, str)) ==> policies[k].PolicyAttributes.DisallowedSubdomains !== getPoliciesFromMap(policiesInRequest, str)[l].PolicyAttributes.DisallowedSubdomains)
	invariant len(policies) > 0 ==> forall k int :: {&policies[k].PolicyAttributes.ExcludedSubdomains} idx <= k && k < len(policies) ==> (forall str string, l int :: {&getPoliciesFromMap(policiesInRequest, str)[l].PolicyAttributes.ExcludedSubdomains} str in domain(policiesInRequest) && 0 <= l && l < len(getPoliciesFromMap(policiesInRequest, str)) ==> policies[k].PolicyAttributes.ExcludedSubdomains !== getPoliciesFromMap(policiesInRequest, str)[l].PolicyAttributes.ExcludedSubdomains)
	for i /*added*/, policy := range policies with idx /*added*/ {
		policiesInRequestProcessed[policy] = false
		immutablePolicyHash := getImmutablePolicyHash(policy, outPerms / 2)
		v := policiesInRequest[immutablePolicyHash]
		if v == nil {
			policiesInRequest[immutablePolicyHash] = []*common.PolicyCertificate{}
		}
		
		entry, _ := policiesInRequest[immutablePolicyHash]
		// TODO why does this not work - missing knowledge about already existant items? ISSUE #935
		//policiesInRequest[immutablePolicyHash] = append(perm(1/2), entry, policy)
		policiesInRequest[immutablePolicyHash] = appendPolicyCertificate(entry, policy)
	}

	// add all certificates to cache
	// skip certificates that have already been added
	// in a recursive step
	var processedPolicyHashes []string
	invariant outPerms > 0
	invariant outPerms <= inPerms
	invariant acc(policiesInRequestProcessed)
	invariant acc(policiesInRequest) 
	invariant forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> acc(&policies[k], _)
	invariant len(policies) > 0 ==> 0 <= i && i <= len(policies)
	invariant forall str string :: {str in domain(policiesInRequest)} str in domain(policiesInRequest) ==> getPoliciesFromMap(policiesInRequest, str) != nil
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k]} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k]) && getPoliciesFromMap(policiesInRequest, str)[k] in domain(policiesInRequestProcessed)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].SPCTs} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].SPCTs, outPerms) && acc(cache_SPCTs(getPoliciesFromMap(policiesInRequest, str)[k].SPCTs), outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash, outPerms) && acc(policy_IssuerHash(getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash), outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].TimeStamp} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].TimeStamp, outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].DomainField} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].DomainField, outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains), outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains), outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains), outPerms)
	invariant forall str string, k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs} str in domain(policiesInRequest) && 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs), outPerms)
	invariant forall k int :: {&policies[k]} 0 <= k && k < len(policies) ==> (exists str string, l int :: {&getPoliciesFromMap(policiesInRequest, str)[l]} str in domain(policiesInRequest) && 0 <= l && l < len(getPoliciesFromMap(policiesInRequest, str)) && policies[k] == getPoliciesFromMap(policiesInRequest, str)[l])
	invariant forall k int :: {&processedPolicyHashes[k]} 0 <= k && k < len(processedPolicyHashes) ==> acc(&processedPolicyHashes[k])
	invariant acc(&policyCache)
	invariant acc(policyCache)
	invariant acc(&immutablePolicyCache)
	invariant acc(immutablePolicyCache)
	invariant acc(&policyDnsNameCache)
	invariant acc(policyDnsNameCache)
	invariant acc(&ignoredPolicyHashes)
	invariant acc(ignoredPolicyHashes)
	invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
	invariant ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
	invariant PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
	invariant acc(&NCertificatesAdded)
	invariant acc(&MSS)
	for i /*added*/, policy := range policies with idx /*added*/ {
		if !policiesInRequestProcessed[policy] {
			hashes, added, tmpPerms := processPolicy(policy, policiesInRequestProcessed, policiesInRequest, perm(1/2), outPerms)
			outPerms = tmpPerms
			processedPolicyHashes = append(perm(1), processedPolicyHashes, hashes...)
			if added {
				NCertificatesAdded++
			} else {
				fmt.Printf("[Go] Did not add policy: %v\n", policy)
			}
		}
	}
	MS = MS + time.Now().Sub(now).Milliseconds()
	fmt.Printf("[Go] Added %d policies to cache\n", len(policyCache)-nEntriesBefore)
	fmt.Printf("[Go] Total # cache entries: %d\n", len(policyCache))
	fmt.Printf("[Go] Time spent checking signatures: %d ms\n ", MSS)

	MS = 0
	NCertificatesAdded = int64(len(policyCache) - nEntriesBefore)
	return processedPolicyHashes, outPerms
}

// process a certificate by potentially adding
// it to the cache
// recursively processes parent certificates
// returns the hashes of all processed certificates
//requires cachePerms > 0
requires inPerms > 0 && inPerms <= 1
requires policiesInRequestPerm > 0
requires acc(policiesInRequestProcessed)
requires acc(policiesInRequest, policiesInRequestPerm)
requires acc(&policyCache)
requires acc(&immutablePolicyCache)
requires acc(&policyDnsNameCache)
requires acc(&ignoredPolicyHashes)
requires acc(policyCache)
requires acc(immutablePolicyCache)
requires acc(policyDnsNameCache)
requires acc(ignoredPolicyHashes)
requires ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
requires PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
requires forall str string :: {str in domain(policiesInRequest)} str in domain(policiesInRequest) ==> (forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k]} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k], policiesInRequestPerm) && getPoliciesFromMap(policiesInRequest, str)[k] in domain(policiesInRequestProcessed)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].SPCTs} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].SPCTs, inPerms) && acc(cache_SPCTs(getPoliciesFromMap(policiesInRequest, str)[k].SPCTs), inPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash, inPerms) && acc(policy_IssuerHash(getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash), inPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].TimeStamp} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].TimeStamp, inPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].DomainField} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].DomainField, inPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs, inPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs), inPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains, inPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains), inPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains, inPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains), inPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains, inPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains), inPerms))
requires exists str string :: str in domain(policiesInRequest) && (exists k int :: 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) && getPoliciesFromMap(policiesInRequest, str)[k] == policy)
preserves acc(&NCertificatesAdded)
preserves acc(&MSS)
ensures outPerms > 0 && outPerms <= inPerms && outPerms <= 1
ensures acc(policiesInRequestProcessed)
ensures acc(policiesInRequest, policiesInRequestPerm)
ensures acc(&policyCache)
ensures acc(&immutablePolicyCache)
ensures acc(&policyDnsNameCache)
ensures acc(&ignoredPolicyHashes)
ensures acc(policyCache)
ensures acc(immutablePolicyCache)
ensures acc(policyDnsNameCache)
ensures acc(ignoredPolicyHashes)
ensures ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
ensures forall str string :: {str in domain(policiesInRequest)} str in domain(policiesInRequest) ==> (forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k]} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k], policiesInRequestPerm) && getPoliciesFromMap(policiesInRequest, str)[k] in domain(policiesInRequestProcessed)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].SPCTs} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].SPCTs, outPerms) && acc(cache_SPCTs(getPoliciesFromMap(policiesInRequest, str)[k].SPCTs), outPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash, outPerms) && acc(policy_IssuerHash(getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash), outPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].TimeStamp} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].TimeStamp, outPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].DomainField} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].DomainField, outPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs), outPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains), outPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains), outPerms)) &&
(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains), outPerms))
ensures exists str string :: str in domain(policiesInRequest) && (exists k int :: 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) && getPoliciesFromMap(policiesInRequest, str)[k] == policy)
ensures policiesInRequestProcessed[policy] == true
ensures forall k int :: {&res[k]} 0 <= k && k < len(res) ==> acc(&res[k])
func processPolicy(policy *common.PolicyCertificate,
	policiesInRequestProcessed map[*common.PolicyCertificate]bool,
	policiesInRequest map[string][]*common.PolicyCertificate,
	ghost policiesInRequestPerm perm,
	ghost inPerms perm) (res []string, added bool, ghost outPerms perm) { // added parameter names
	ghost outPerms = inPerms

	policyHash := getPolicyHash(policy, outPerms / 2)
	processedPolicyHashes := []string{policyHash}
	immutablePolicyHash := getImmutablePolicyHash(policy, outPerms / 2)

	// mark the certificate as processed on exit
	
	// TODO WHY DOES THIS NOT WORK?
	/*defer func() {
		policiesInRequestProcessed[policy] = true
	}()*/

	// if have already processed the certificate in the request, return whether
	// it was added to the cache
	_, inCache := policyCache[policyHash]
	if policiesInRequestProcessed[policy] || inCache {
		policiesInRequestProcessed[policy] = true // added
		return processedPolicyHashes, inCache, outPerms
	}
	_, ignored := ignoredPolicyHashes[policyHash]
	if ignored {
		policiesInRequestProcessed[policy] = true // added
		return processedPolicyHashes, false, outPerms
	}

	// recursively process parent certificates present in the request
	issuerHash := unfolding acc(policy_IssuerHash(policy.IssuerHash), outPerms) in getIssuerHash(policy)
	// TODO WHY DOES THIS NOT WORK parentPolicies := policiesInRequest[issuerHash]
	parentPolicies := getPoliciesFromMap(policiesInRequest, issuerHash)

	invariant acc(&NCertificatesAdded)
	invariant acc(&MSS)
	invariant outPerms > 0 && outPerms <= old(outPerms) && outPerms <= inPerms
	invariant acc(policiesInRequestProcessed)
	invariant policiesInRequestPerm > 0
	invariant acc(policiesInRequest, policiesInRequestPerm)
	invariant acc(&policyCache)
	invariant acc(&immutablePolicyCache)
	invariant acc(&policyDnsNameCache)
	invariant acc(&ignoredPolicyHashes)
	invariant acc(policyCache)
	invariant acc(immutablePolicyCache)
	invariant acc(policyDnsNameCache)
	invariant acc(ignoredPolicyHashes)
	invariant ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
	invariant acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
	invariant PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
	invariant forall str string :: {str in domain(policiesInRequest)} str in domain(policiesInRequest) ==> (forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k]} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k], policiesInRequestPerm) && getPoliciesFromMap(policiesInRequest, str)[k] in domain(policiesInRequestProcessed)) &&
		(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].SPCTs} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].SPCTs, outPerms) && acc(cache_SPCTs(getPoliciesFromMap(policiesInRequest, str)[k].SPCTs), outPerms)) &&
		(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash, outPerms) && acc(policy_IssuerHash(getPoliciesFromMap(policiesInRequest, str)[k].IssuerHash), outPerms)) &&
		(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].TimeStamp} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].TimeStamp, outPerms)) &&
		(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].DomainField} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].DomainField, outPerms)) &&
		(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedCAs), outPerms)) &&
		(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.AllowedSubdomains), outPerms)) &&
		(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.DisallowedSubdomains), outPerms)) &&
		(forall k int :: {&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains} 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) ==> acc(&getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains, outPerms) && acc(acc_strs(getPoliciesFromMap(policiesInRequest, str)[k].PolicyAttributes.ExcludedSubdomains), outPerms))
	invariant exists str string :: str in domain(policiesInRequest) && (exists k int :: 0 <= k && k < len(getPoliciesFromMap(policiesInRequest, str)) && getPoliciesFromMap(policiesInRequest, str)[k] == policy)
	invariant parentPolicies === getPoliciesFromMap(policiesInRequest, issuerHash)
	invariant forall k int :: {&processedPolicyHashes[k]} 0 <= k && k < len(processedPolicyHashes) ==> acc(&processedPolicyHashes[k])
	//for _, parentPolicy := range parentPolicies {
	invariant 0 <= i && i <= len(parentPolicies)
	for i := 0; i < len(parentPolicies); i++ {
		parentPolicy := parentPolicies[i]
		if parentHashes, added, tmp := processPolicy(parentPolicy, policiesInRequestProcessed, policiesInRequest, policiesInRequestPerm / 2, outPerms); added {
			ghost outPerms = tmp
			processedPolicyHashes = append(perm(1/2), processedPolicyHashes, parentHashes...)
			NCertificatesAdded++
		} else {
			ghost outPerms = tmp
			log.Printf("[Go] Did not add policy: %v\n", parentPolicy)
		}
	}

	// now, the cache should be populated with parents (if there were any in the request
	// or already cached)

	// get potential parent certificates of the current certificate
	parentImmutablePolicyCacheEntry, _ := immutablePolicyCache[issuerHash]
	unfold ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
	// if no potential parent certificate is present in the cache,
	// cannot add the certificate to the cache
	if parentImmutablePolicyCacheEntry == nil || len(parentImmutablePolicyCacheEntry.policyHashes) == 0 {
		policiesInRequestProcessed[policy] = true // added statement instead of defer
		fold ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
		return processedPolicyHashes, false, outPerms
	}

	unfold ImmutablePolicyCachePermissions_policyHashes(parentImmutablePolicyCacheEntry.policyHashes, issuerHash, dict(policyCache))
	unfold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
	// check signature
	potParentPolicy := policyCache[parentImmutablePolicyCacheEntry.policyHashes[0]].policy

	// check that the certificate signature can be verified using the
	// parent certificate and the certificate is currently valid.
	policiesInRequestProcessed[policy] = true //added
	ghost parentPolicyHash := parentImmutablePolicyCacheEntry.policyHashes[0]
	fold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
	fold ImmutablePolicyCachePermissions_policyHashes(parentImmutablePolicyCacheEntry.policyHashes, issuerHash, dict(policyCache))
	fold ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
	// changed from return processedPolicyHashes, verifyPolicyAndAllocateCaches(policy, potParentPolicy, policyHash,
	//	immutablePolicyHash, issuerHash)

	addedToCache, tmp := verifyPolicyAndAllocateCaches(policy, potParentPolicy, policyHash,	immutablePolicyHash, issuerHash, outPerms / 2, parentPolicyHash) /* outPerms needs to be / 2 because otherwise we could not check that we still have access. this also means that we get less permissions back but this is fine we only have to read from existing policies*/ 

	ghost outPerms = tmp

	return processedPolicyHashes, addedToCache, outPerms
}

// verify child policy with a (pot.) parent certificate and allocate
// cache entries for the child if necessary
// returns true if the policy was added to the cache and false if the
// policy was added to the ignored policies
requires inPerms > 0 && inPerms <= 1
requires acc(&policy.SPCTs, inPerms) && acc(cache_SPCTs(policy.SPCTs), inPerms) &&
	acc(&policy.IssuerHash, inPerms) && acc(policy_IssuerHash(policy.IssuerHash), inPerms) &&
	acc(&policy.TimeStamp, inPerms) &&
	acc(&policy.DomainField, inPerms) &&
	acc(&policy.PolicyAttributes.ExcludedSubdomains, inPerms) &&
	acc(&policy.PolicyAttributes.DisallowedSubdomains, inPerms) &&
	acc(&policy.PolicyAttributes.AllowedSubdomains, inPerms) &&
	acc(&policy.PolicyAttributes.AllowedCAs, inPerms) 
requires acc(acc_strs(policy.PolicyAttributes.AllowedCAs), inPerms)
requires acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), inPerms)
requires acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), inPerms)
requires acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), inPerms)
requires acc(&policyCache)
requires acc(&immutablePolicyCache)
requires acc(&policyDnsNameCache)
requires acc(&ignoredPolicyHashes)
requires acc(immutablePolicyCache)
requires acc(policyCache)
requires acc(policyDnsNameCache)
requires acc(ignoredPolicyHashes)
requires ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
requires PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
requires parentPolicyHash in domain(policyCache) && unfolding acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms) in policyCache[parentPolicyHash].policy == parentPolicy
requires immutablePolicyHash != base64.StdEncoding.EncodeToString(nil)
preserves acc(&MSS)
ensures outPerms > 0 && outPerms <= inPerms && outPerms <= 1
ensures acc(&policy.SPCTs, outPerms) && acc(cache_SPCTs(policy.SPCTs), outPerms) &&
	acc(&policy.IssuerHash, outPerms) && acc(policy_IssuerHash(policy.IssuerHash), outPerms) &&
	acc(&policy.TimeStamp, outPerms) &&
	acc(&policy.DomainField, outPerms) &&
	acc(&policy.PolicyAttributes.ExcludedSubdomains, outPerms) &&
	acc(&policy.PolicyAttributes.DisallowedSubdomains, outPerms) &&
	acc(&policy.PolicyAttributes.AllowedSubdomains, outPerms) &&
	acc(&policy.PolicyAttributes.AllowedCAs, outPerms)
ensures acc(acc_strs(policy.PolicyAttributes.AllowedCAs), outPerms)
ensures acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), outPerms)
ensures acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), outPerms)
ensures acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), outPerms)
ensures acc(&policyCache)
ensures acc(&immutablePolicyCache)
ensures acc(&policyDnsNameCache)
ensures acc(&ignoredPolicyHashes)
ensures acc(immutablePolicyCache)
ensures acc(policyCache)
ensures acc(policyDnsNameCache)
ensures acc(ignoredPolicyHashes)
ensures ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
ensures parentPolicyHash in domain(policyCache)
ensures forall str string :: {str in domain(immutablePolicyCache)} old(str in domain(immutablePolicyCache)) ==> (str in domain(immutablePolicyCache) && (let elem, _ := immutablePolicyCache[str] in elem) == old(let elem, _ := immutablePolicyCache[str] in elem))
func verifyPolicyAndAllocateCaches(
	policy *common.PolicyCertificate,
	parentPolicy *common.PolicyCertificate,
	policyHash string,
	immutablePolicyHash string,
	immutableIssuerPolicyHash string,
	ghost inPerms perm,
	ghost parentPolicyHash string) (res bool, ghost outPerms perm) { // added return param name
	ghost outPerms = inPerms
	unfold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
	unfold acc(cache_policyHashes_policy(parentPolicy, parentPolicyHash, dict(policyDnsNameCache)), outPerms)
	err := verifyChildWithParentPolicy(policy, parentPolicy, outPerms / 2)
	fold acc(cache_policyHashes_policy(parentPolicy, parentPolicyHash, dict(policyDnsNameCache)), outPerms)
	fold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)

	// if policy is a valid child of parentPolicy, allocate new cache entries
	if err == nil {
		assert parentPolicyHash in domain(policyCache)
		tmp := allocatePolicyCacheEntries(policy, policyHash, immutablePolicyHash, immutableIssuerPolicyHash, outPerms)
		ghost outPerms = tmp
		assert parentPolicyHash in domain(policyCache)
		return true, outPerms
	} else {
		// TODO I THINK THIS IS INCORRECT -> COPY PASTE MISTAKE!!!!!
		// ignore certificate for future requests if it wasn't added to the cache
		// (e.g., because it was already expired)
		/*ignoredCertificateHashes[policyHash] = struct{}{}
		return false, outPerms*/


		// CORRECT VERSION?!
		ignoredPolicyHashes[policyHash] = struct{}{}
		assert parentPolicyHash in domain(policyCache)
		return false, outPerms
	}
}


// check a policy against a parent policy
// checks whether parent verifies the child signature.
// if the signature does not verify or some other constraint is violated, returns an error
// otherwise, if the validation succeeds, it returns nil
requires policyPerms > 0
preserves acc(policy, policyPerms)
preserves acc(parentPolicy, policyPerms)
preserves acc(&MSS)
func verifyChildWithParentPolicy(policy *common.PolicyCertificate, parentPolicy *common.PolicyCertificate, ghost policyPerms perm) error {
	// TODO (cyrill): do policy validity check: validity period, domain constraints, ...

	// TODO (cyrill): do parent-child validity check: validity period of child is within parent, Child domain is sub-domain of parent domain, ...

	now := time.Now()
	err := crypto.VerifyIssuerSignature(parentPolicy, policy, policyPerms / 2)
	MSS = MSS + time.Now().Sub(now).Milliseconds()
	if err != nil {
		return fmt.Errorf("Failed to verify issuer signature: %s", err)
	}
	return nil
}


// not implemented because we cannot iterate over dictonaries in the current version of gobra
ghost
requires perms > 0
requires forall str string :: {str in domain(oldImmutablePolicyCache)} str in domain(oldImmutablePolicyCache) ==> str in domain(immutablePolicyCache)
requires forall str string :: {str in domain(policyCache)} str in domain(policyCache) && str != exceptFor ==> acc(policyCache[str], perms / 2) && acc(PolicyCachePermissions_ImmutableHash(policyCache[str].immutableHash, str, oldImmutablePolicyCache), perms)
ensures forall str string :: {str in domain(policyCache)} str in domain(policyCache) && str != exceptFor ==> acc(policyCache[str], perms / 2) && acc(PolicyCachePermissions_ImmutableHash(policyCache[str].immutableHash, str, immutablePolicyCache), perms)
decreases
func refoldForNewImmutablePolicyCache(policyCache dict[string]*PolicyCacheEntry, exceptFor string, oldImmutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, perms perm)


ghost
requires forall str string :: {str in domain(oldPolicyCache)} str in domain(oldPolicyCache) ==> str in domain(policyCache)
requires PolicyDnsNameCachePermissions(policyDnsNameCache, oldPolicyCache)
requires forall str string :: {str in domain(immutablePolicyCache)} str in domain(immutablePolicyCache) && str != exceptFor ==> acc(&immutablePolicyCache[str].policyHashes, 1/2) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, oldPolicyCache)
ensures PolicyDnsNameCachePermissions(policyDnsNameCache, policyCache)
ensures forall str string :: {str in domain(immutablePolicyCache)} str in domain(immutablePolicyCache) && str != exceptFor ==> acc(&immutablePolicyCache[str].policyHashes, 1/2) && ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCache[str].policyHashes, str, policyCache)
decreases
func refoldForNewPolicyCache(immutablePolicyCache dict[string]*ImmutablePolicyCacheEntry, policyDnsNameCache dict[string][]string, exceptFor string, oldPolicyCache dict[string]*PolicyCacheEntry, policyCache dict[string]*PolicyCacheEntry)

ghost decreases
requires outPerms > 0 && outPerms <= 1
requires forall str string :: {str in domain(oldPolicyDnsNameCache)} str in domain(oldPolicyDnsNameCache) ==> str in domain(policyDnsNameCache)
// acc(..., 1/2) so we know that we don't change any other invariants!
requires forall str string :: {policyCache[str]} str in domain(policyCache) && str != excl ==> acc(policyCache[str], outPerms) && acc(cache_policyHashes_policy(policyCache[str].policy, str, oldPolicyDnsNameCache), outPerms)
ensures forall str string :: {policyCache[str]} str in domain(policyCache) && str != excl ==> acc(policyCache[str], outPerms) && acc(cache_policyHashes_policy(policyCache[str].policy, str, policyDnsNameCache), outPerms)
func refoldPoliciesExceptForInclDns(policyCache dict[string]*PolicyCacheEntry, excl string, oldPolicyDnsNameCache dict[string][]string, policyDnsNameCache dict[string][]string, outPerms perm)

// allocate entries in the certificateCache, dnsNameCache, subjectSKICache
// if necessary (for non-root certificates)
requires inPerms > 0 && inPerms <= 1
requires acc(&policy.SPCTs, inPerms) && acc(cache_SPCTs(policy.SPCTs), inPerms) &&
	acc(&policy.IssuerHash, inPerms) && acc(policy_IssuerHash(policy.IssuerHash), inPerms) &&
	acc(&policy.TimeStamp, inPerms) &&
	acc(&policy.DomainField, inPerms) &&
	acc(&policy.PolicyAttributes.ExcludedSubdomains, inPerms) &&
	acc(&policy.PolicyAttributes.DisallowedSubdomains, inPerms) &&
	acc(&policy.PolicyAttributes.AllowedSubdomains, inPerms) &&
	acc(&policy.PolicyAttributes.AllowedCAs, inPerms)
requires acc(acc_strs(policy.PolicyAttributes.AllowedCAs), inPerms)
requires acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), inPerms)
requires acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), inPerms)
requires acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), inPerms)
requires acc(&policyCache)
requires acc(&immutablePolicyCache)
requires acc(&policyDnsNameCache)
requires acc(&ignoredPolicyHashes)
requires acc(immutablePolicyCache)
requires acc(policyCache)
requires acc(policyDnsNameCache)
requires acc(ignoredPolicyHashes)
requires ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
requires acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), inPerms)
requires PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
requires immutablePolicyHash != base64.StdEncoding.EncodeToString(nil)
ensures outPerms > 0 && outPerms <= inPerms && outPerms <= 1
ensures acc(&policy.SPCTs, outPerms) && acc(cache_SPCTs(policy.SPCTs), outPerms) &&
	acc(&policy.IssuerHash, outPerms) && acc(policy_IssuerHash(policy.IssuerHash), outPerms) &&
	acc(&policy.TimeStamp, outPerms) &&
	acc(&policy.DomainField, outPerms) &&
	acc(&policy.PolicyAttributes.ExcludedSubdomains, outPerms) &&
	acc(&policy.PolicyAttributes.DisallowedSubdomains, outPerms) &&
	acc(&policy.PolicyAttributes.AllowedSubdomains, outPerms) &&
	acc(&policy.PolicyAttributes.AllowedCAs, outPerms) 
ensures acc(acc_strs(policy.PolicyAttributes.AllowedCAs), outPerms)
ensures acc(acc_strs(policy.PolicyAttributes.AllowedSubdomains), outPerms)
ensures acc(acc_strs(policy.PolicyAttributes.DisallowedSubdomains), outPerms)
ensures acc(acc_strs(policy.PolicyAttributes.ExcludedSubdomains), outPerms)
ensures acc(&policyCache)
ensures acc(&immutablePolicyCache)
ensures acc(&policyDnsNameCache)
ensures acc(&ignoredPolicyHashes)
ensures acc(immutablePolicyCache)
ensures acc(policyCache)
ensures acc(policyDnsNameCache)
ensures acc(ignoredPolicyHashes)
ensures ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))
ensures acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)
ensures PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
ensures forall str string :: {str in domain(policyCache)} old(str in domain(policyCache)) ==> str in domain(policyCache)
ensures forall str string :: {str in domain(immutablePolicyCache)} old(str in domain(immutablePolicyCache)) ==> (str in domain(immutablePolicyCache) && (let elem, _ := immutablePolicyCache[str] in elem) == old(let elem, _ := immutablePolicyCache[str] in elem))
ensures policy.Domain() in domain(dict(policyDnsNameCache))
func allocatePolicyCacheEntries(policy *common.PolicyCertificate,
	policyHash string,
	immutablePolicyHash string,
	immutableIssuerPolicyHash string,
	ghost inPerms perm) (ghost outPerms perm) { // added return param
	ghost outPerms = inPerms
	fmt.Printf("allocating policy: imm hash = %s, imm issuer hash = %s\n", immutablePolicyHash, immutableIssuerPolicyHash)

	ghost oldPolicyCache := dict(policyCache)
	ghost oldImmutablePolicyCache := dict(immutablePolicyCache)
	
	unfold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)

	// add to policy cache
	var policyCacheEntry *PolicyCacheEntry
	policyCacheEntry = &PolicyCacheEntry{
		policy:        policy,
		immutableHash: immutablePolicyHash,
	}
	outPerms = outPerms / 2
	policyCache[policyHash] = policyCacheEntry

	unfold ImmutablePolicyCachePermissions(dict(immutablePolicyCache), oldPolicyCache)

	// allocate new immutableHash entry or adjust existing entry
	immutablePolicyCacheEntry, inCache := immutablePolicyCache[immutablePolicyHash]
	if !inCache {
		immutablePolicyCacheEntry = &ImmutablePolicyCacheEntry{
			policyAttributes:    policy.PolicyAttributes,
			immutableIssuerHash: immutableIssuerPolicyHash,
			timestamp:           policy.TimeStamp,
		}
		ghost if immutableIssuerPolicyHash in domain(immutablePolicyCache) {
			assume unfolding ImmutablePolicyCachePermissions_issuer(dict(immutablePolicyCache)) in (immutablePolicyCacheEntry.depth == immutablePolicyCache[immutableIssuerPolicyHash].depth + 1) // if we assign this directly in struct assignment above we will retrieve a gpointer and not a normal pointer
		} else {
			assume immutablePolicyCacheEntry.depth == 1
		}
		immutablePolicyCache[immutablePolicyHash] = immutablePolicyCacheEntry
	} 

	ghost if inCache {
		unfold ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCacheEntry.policyHashes, immutablePolicyHash, oldPolicyCache)
	}

	immutablePolicyCacheEntry.policyHashes = append(perm(1/2), immutablePolicyCacheEntry.policyHashes, policyHash)
	
	fold acc(PolicyCachePermissions_ImmutableHash(immutablePolicyHash, policyHash, dict(immutablePolicyCache)), outPerms)
	ghost refoldForNewImmutablePolicyCache(dict(policyCache), policyHash, oldImmutablePolicyCache, dict(immutablePolicyCache), outPerms)
	fold ImmutablePolicyCachePermissions_policyHashes(immutablePolicyCacheEntry.policyHashes, immutablePolicyHash, dict(policyCache))
	ghost refoldForNewPolicyCache(dict(immutablePolicyCache), dict(policyDnsNameCache), immutablePolicyHash, oldPolicyCache, dict(policyCache))
	fold ImmutablePolicyCachePermissions(dict(immutablePolicyCache), dict(policyCache))

	ghost oldPolicyDnsNameCache := dict(policyDnsNameCache)

	// add to dns cache
	// TODO WHY DOES THIS NOT WORK
	// policyDnsNameCache[policy.Domain()] = append(perm(1), policyDnsNameCache[policy.Domain()], policyHash)

	unfold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
	ghost if policy.Domain() in domain(policyDnsNameCache) {
		unfold acc_leafHashes(policyDnsNameCache[policy.Domain()], policy.Domain(), dict(policyCache))
	}
	
	policyDnsNameCache[policy.Domain()] = append(perm(1/2), getHashesFromDnsCache(policy.Domain()), policyHash)
	fold acc_leafHashes(policyDnsNameCache[policy.Domain()], policy.Domain(), dict(policyCache))

	fold acc(cache_policyHashes_policy(policy, policyHash, dict(policyDnsNameCache)), outPerms)
	ghost refoldPoliciesExceptForInclDns(dict(policyCache), policyHash, oldPolicyDnsNameCache, dict(policyDnsNameCache),/* inPerms,*/ outPerms)
	fold acc(PolicyCachePermissions(dict(policyCache), dict(immutablePolicyCache), dict(policyDnsNameCache)), outPerms)

	fold PolicyDnsNameCachePermissions(dict(policyDnsNameCache), dict(policyCache))
}

// compute the base64 encoded issuer hash field 
decreases
requires acc(policy) && acc(policy.IssuerHash)
pure func getIssuerHash(policy *common.PolicyCertificate) (res string) { // added return param name
	return base64.StdEncoding.EncodeToString(policy.IssuerHash)
}

// compute the base64 encoded hash over the immutable fields of the
// policy certificate
requires policyPerms > 0
preserves acc(policy, policyPerms)
ensures policy != nil ==> res != base64.StdEncoding.EncodeToString(nil)
ensures res == base64.StdEncoding.AbstractEncodeToString(crypto.abstractComputeHashAsSigner(policy))
func getImmutablePolicyHash(policy *common.PolicyCertificate, ghost policyPerms perm) (res string) { // added return param name
	hash, err := crypto.ComputeHashAsSigner(policy)
	if err != nil {
		assert false
		log.Fatalf("Failed to compute hash over immutable policy certificate fields: %s", err)
	}
	return base64.StdEncoding.EncodeToString(hash)
}

// compute the base64 encoded hash of a policy certificate
requires policyPerms > 0
preserves acc(policy, policyPerms)
ensures res != base64.StdEncoding.EncodeToString(nil)
func getPolicyHash(policy *common.PolicyCertificate, ghost policyPerms perm) (res string) { // added return param name
	h := sha256.New()
	json, err := common.ToJSON(policy)
	if err != nil {
		log.Fatalf("Failed to encode policy certificate to JSON: %s", err)
	}
	_, err = h.Write(json)
	if err != nil {
		log.Fatal(err)
	}
	hash := h.Sum(nil)
	return base64.StdEncoding.EncodeToString(hash)
}
