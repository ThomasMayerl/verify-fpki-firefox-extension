package cache_v2

import (
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/base64"
	"encoding/pem"
	"log"
	"math/big"
	"math/rand"
	"time"
)

const CERTIFICATE = "CERTIFICATE"

// EncodePEM encodes the content as PEM of type pemType.
func EncodePEM(content []byte, pemType string) []byte {
	block := &pem.Block{
		Type:  pemType,
		Bytes: content,
	}
	return pem.EncodeToMemory(block)
}

// CreateAndStoreRSAPrivateKey creates an RSA private key
func CreateAndStoreRSAPrivateKey(r *rand.Rand) (*rsa.PrivateKey, error) {
	privateKey, err := rsa.GenerateKey(r, 2048)
	if err != nil {
		return nil, err
	}
	return privateKey, nil
}

// ValidityPeriod returns a validity period starting
// at time.Now() and ending at
// time.Now + the specified years, months, days and hours.
func ValidityPeriod(years int,
	months int,
	days int,
	hours int) (time.Time, time.Time) {
	notBefore := time.Now().UTC()
	notAfter := notBefore.AddDate(years, months, days)
	notAfter = notAfter.Add(time.Hour * time.Duration(hours))
	return notBefore, notAfter
}

// CreateCertificateTemplate creates a template for a x509 certificate.
// The validity period starts at time.Now() and ends at
// time.Now() + the specified years, months, days, hours.
// If parent is nil, the issuer and the subject will be
// equivalent.
requires len(dnsNames) >= 1 && acc(&dnsNames[0])
requires acc(parent)
ensures acc(&dnsNames[0])
ensures acc(parent)
func CreateCertificateTemplate(serialNr *big.Int,
	dnsNames []string,
	years int,
	months int,
	days int,
	hours int,
	isCA bool,
	parent *x509.Certificate,
	signatureAlgorithm x509.SignatureAlgorithm) (*x509.Certificate, error) {

	subject := pkix.Name{
		SerialNumber: serialNr.String(),
		CommonName:   dnsNames[0],
	}

	// self signed certificate (trust anchor) if parent is nil
	var issuer pkix.Name = subject
	if parent != nil {
		issuer = parent.Subject
	}

	notBefore, notAfter := ValidityPeriod(years, months, days, hours)

	var keyUsage x509.KeyUsage
	if isCA {
		keyUsage = x509.KeyUsageCertSign | x509.KeyUsageCRLSign
	} else {
		keyUsage = x509.KeyUsageDigitalSignature
	}

	template := &x509.Certificate{

		SerialNumber:          serialNr,
		SignatureAlgorithm:    signatureAlgorithm,
		Issuer:                issuer,
		Subject:               subject,
		NotBefore:             notBefore,
		NotAfter:              notAfter,
		BasicConstraintsValid: true,
		IsCA:                  isCA,
		MaxPathLen:            -1,
		KeyUsage:              keyUsage,
		DNSNames:              dnsNames,
	}
	return template, nil
}

// CreateCertificate creates a x509 certificate binding the public
// key to the information specified in the template.
// The certificate is signed by the parentSigner.
// The certificate is returned in PEM encoding.
func CreateCertificate(template *x509.Certificate,
	publicKey crypto.PublicKey,
	parent *x509.Certificate,
	parentSigner crypto.Signer,
	r *rand.Rand) ([]byte, error) {

	var certBytes []byte
	var err error
	if parent == nil {
		certBytes, err = x509.CreateCertificate(r, template, template, publicKey, parentSigner)
	} else {
		certBytes, err = x509.CreateCertificate(r, template, parent, publicKey, parentSigner)
	}
	if err != nil {
		return nil, err
	}
	pem := EncodePEM(certBytes, CERTIFICATE)
	return pem, nil
}

requires forall k int :: 0 <= k && k < len(times) ==> acc(&times[k])
ensures forall k int :: 0 <= k && k < len(times) ==> acc(&times[k])
func maxTime(times ...time.Time) (maxTime time.Time) {
	// TODO: Needed for Gobra because Gobra cannot deal with ranges over variadic parameters?
	// Was like this before:
	// for i, t := range times {
	invariant 0 <= i && i <= len(times)
	invariant forall k int :: 0 <= k && k < len(times) ==> acc(&times[k])
	for i := 0; i < len(times); i++ {
		if i == 0 || times[i].After(maxTime) { // times[i] was t before
			maxTime = times[i] // times[i] was t before
		}
	}
	return
}

// TODO: Was generic before. Could be that this does not work
requires forall k int :: 0 <= k && k < len(list) ==> acc(&list[k])
ensures forall k int :: 0 <= k && k < len(list) ==> acc(&list[k])
func TransformListToInterfaceType(list []any) []interface{} {
	t := make([]interface{}, len(list))
	invariant forall k int :: 0 <= k && k < len(list) ==> acc(&list[k])
	invariant forall k int :: 0 <= k && k < len(t) ==> acc(&t[k])
	for i, e := range list {
		t[i] = e
	}
	return t
}

// TODO: Was generic before. Could be that this does not work
requires forall k int :: 0 <= k && k < len(list) ==> acc(&list[k]) && forall j int :: 0 <= j && j < len(list[k]) ==> acc(&list[k][j])
ensures forall k int :: 0 <= k && k < len(list) ==> acc(&list[k]) && forall j int :: 0 <= j && j < len(list[k]) ==> acc(&list[k][j])
func TransformNestedListsToInterfaceType(list [][]any) []interface{} {
	t := make([]interface{}, len(list))
	invariant forall k int :: 0 <= k && k < len(list) ==> acc(&list[k]) && forall j int :: 0 <= j && j < len(list[k]) ==> acc(&list[k][j])
	invariant forall k int :: 0 <= k && k < len(t) ==> acc(&t[k])
	for i, e := range list {
		ti := make([]interface{}, len(e))
		invariant forall j int :: 0 <= j && j < len(e) ==> acc(&e[j])
		invariant forall k int :: 0 <= k && k < len(ti) ==> acc(&ti[k])
		for j, ej := range e {
			ti[j] = ej
		}	
		t[i] = ti
	}
	return t
}

requires forall k int :: 0 <= k && k < len(slice) ==> acc(&slice[k])
ensures forall k int :: 0 <= k && k < len(slice) ==> acc(&slice[k])
func SliceToSet(slice []string) map[string]struct{} {
	setVar := make(map[string]struct{})
	invariant forall k int :: 0 <= k && k < len(slice) ==> acc(&slice[k])
	invariant acc(setVar)
	for _, e := range slice {
		setVar[e] = struct{}{}
	}
	return setVar
}

// compute the base64 encoded hash of the base64 encoded payload
func GetPayloadAndHash(b64payload string) ([]byte, string) {
	payload, err := base64.StdEncoding.DecodeString(b64payload)
	if err != nil {
		log.Fatal(err)
	}
	h := sha256.New()
	_, err = h.Write(payload)
	if err != nil {
		log.Fatal(err)
	}
	hash := h.Sum(nil)
	return payload, base64.StdEncoding.EncodeToString(hash)
}
