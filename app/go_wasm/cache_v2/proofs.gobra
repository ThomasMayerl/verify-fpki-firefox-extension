package cache_v2

import (
	"bytes"
	"crypto/rsa"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"log"
	"sort"

	"fpki/pkg/common"
	"fpki/pkg/common/crypto"
	mapCommon "fpki/pkg/mapserver/common"
	"fpki/pkg/mapserver/trie"
	"fpki/pkg/util"
)

type MapServerInfo struct {
	// some identifier of the map server
	identifier string

	// TODO: allow for other algorithms than RSA
	// the public key used to verify the map server's MHT signature
	publicKey *rsa.PublicKey
}

type ProofCacheEntry struct {
	// inclusion proof
	poi *mapCommon.PoI

	// the map server's tree head signature
	treeHeadSignature []byte

	// the certificate hashes included in the map server's response
	// used to check whether the leaf in the proof is the expected one
	// sorted based on their byte representation
	sortedCertificateHashes []*common.SHA256Output

	// leaf hash (i.e., sha256 hash of sorted concatenated certificate hashes)
	calculatedLeafHash []byte

	// proof key value (i.e., sha256 hash of domain)
	calculatedProofKey []byte

	// map server that sent the inclusion proof
	mapserverID string

	// true if the proof has been validated
	evaluated bool

	// the result of proof validation if the proof
	// has been evaluated
	result bool

	// the last encountered error (if any error occurred)
	lastError error
}

preserves acc(e)
func (e *ProofCacheEntry) Evaluated() bool {
	return e.evaluated
}

preserves acc(e)
func (e *ProofCacheEntry) Result() bool {
	return e.result
}

preserves acc(e)
func (e *ProofCacheEntry) LastError() error {
	return e.lastError
}

// map server info cache
var mapserverInfoCache = map[string]*MapServerInfo{}

// cache mapping base64 encoded (leaf hash + map server identifier) to a ProofCacheEntry
var proofCache = map[string]*ProofCacheEntry{}

ensures acc(mapserverInfoCache)
ensures acc(proofCache) && len(proofCache) == 0
func InitializeMapserverInfoCache(configMap map[string]interface{}) bool /*{
	mapserverInfoCache = map[string]*MapServerInfo{}
	proofCache = map[string]*ProofCacheEntry{}

	identities := []string{}
	mapserversJSON := configMap["mapservers"].([]interface{})
	for _, entryInterface := range mapserversJSON {
		entry := entryInterface.(map[string]interface{})
		id := entry["identity"].(string)
		publicKeyDERBase64, ok := entry["publickey"]
		if ok {
			publicKey, err := util.DERBase64ToRSAPublic(publicKeyDERBase64.(string))
			if err != nil {
				log.Panicf("Cannot extract RSA public key from DER: %s", err)
			}
			mapserverInfoCache[id] = &MapServerInfo{identifier: id, publicKey: publicKey}
			identities = append(identities, id)
		} else {
			fmt.Printf("Ignoring map server without public key: %s\n", id)
		}
	}
	fmt.Printf("Added %d map servers: %s\n", len(identities), identities)
	return true
}
*/
// MHT proof verifications are cached to ensure they only need to be verified once.
// The key is calculated as follows: hash(hash(domain), hash(leaf), mapserverID)
preserves forall k int :: {&proofKey[k]} 0 <= k && k < len(proofKey) ==> acc(&proofKey[k])
preserves forall k int :: {&leafHash[k]} 0 <= k && k < len(leafHash) ==> acc(&leafHash[k])
func GetProofCacheKey(proofKey []byte, leafHash []byte, mapserverID string) (string, error) {
	h := sha256.New()
	_, err := h.Write(proofKey)
	if err != nil {
		return "", fmt.Errorf("Failed to write proof key: %s", err)
	}
	_, err = h.Write(leafHash)
	if err != nil {
		return "", fmt.Errorf("Failed to write leaf hash: %s", err)
	}
	_, err = h.Write([]byte(mapserverID))
	if err != nil {
		return "", fmt.Errorf("Failed to write mapserver ID: %s", err)
	}
	hash := h.Sum(nil)
	return base64.StdEncoding.EncodeToString(hash), nil
}

// add a new cache entry for this map server response if it does not exist yet and return the key used in the cache
requires forall k int :: {&certIDs[k]} 0 <= k && k < len(certIDs) ==> acc(&certIDs[k])
requires forall k int :: {&policyIDs[k]} 0 <= k && k < len(policyIDs) ==> acc(&policyIDs[k])
preserves acc(proofCache)
preserves forall str string :: {str in domain(proofCache)} str in domain(proofCache) ==> acc_inj_proofCacheEntry(proofCache[str], str)
ensures err != nil ==> res in domain(proofCache)
func AddMapServerResponseToCacheIfNecessary(response mapCommon.MapServerResponse, certIDs, policyIDs []*common.SHA256Output, mapserverID string) (res string, err error) /*{ // add names to return parameters
	// merge and sort cert and policy IDs
	ids := append(perm(1), certIDs[:0:0], certIDs...)
	ids = append(perm(1), ids, policyIDs...)
	sort.Slice(ids, func(i, j int) bool {
		return bytes.Compare(ids[i][:], ids[j][:]) == -1
	})

	// generate proof key
	proofKey := common.SHA256Hash([]byte(response.DomainEntry.DomainName))

	// calculate leaf hash to compare leaf values in PoPs (ignored in PoAs)
	concatenatedLeafHashes := common.IDsToBytes(ids)
	leafHash := common.SHA256Hash(concatenatedLeafHashes)

	// add entry to cache if necessary
	proofCacheKey, err := GetProofCacheKey(proofKey, leafHash, mapserverID)
	if err != nil {
		return "", err
	}
	if _, ok := proofCache[proofCacheKey]; !ok {
		proofCache[proofCacheKey] = newProofCacheEntry(&response.PoI, proofKey, mapserverID, response.TreeHeadSig, ids, leafHash)
	}
	return proofCacheKey, nil
}*/

// helper function to allocate a new ProofCacheEntry
requires acc(mapserverInfoCache, _)
requires acc(poi)
requires forall k int :: {&poi.ProofValue[k]} 0 <= k && k < len(poi.ProofValue) ==> acc(&poi.ProofValue[k])
requires mapserverID in mapserverInfoCache
requires forall k int :: {&leafHash[k]} 0 <= k && k < len(leafHash) ==> acc(&leafHash[k])
ensures acc_inj_proofCacheEntry(res, "")
func newProofCacheEntry(poi *mapCommon.PoI, proofKey []byte, mapserverID string, treeHeadSignature []byte,
	sortedCertificateHashes []*common.SHA256Output, leafHash []byte) (res *ProofCacheEntry) { // name return param
	proofCacheEntry@ := ProofCacheEntry{
		poi:                     poi,
		treeHeadSignature:       treeHeadSignature,
		sortedCertificateHashes: sortedCertificateHashes,
		calculatedLeafHash:      leafHash,
		calculatedProofKey:      proofKey,
		mapserverID:             mapserverID,
		evaluated:               false,
		result:                  false,
		lastError:               nil,
	}
	defer fold acc_inj_proofCacheEntry(&proofCacheEntry, "")
	return &proofCacheEntry
}

pred acc_inj_proofCacheEntry(proofCacheEntry *ProofCacheEntry, proofCacheKey string) {
	acc(mapserverInfoCache, _) &&
	acc(proofCacheEntry) && acc(proofCacheEntry.poi) && proofCacheEntry.mapserverID in domain(mapserverInfoCache) &&
	(forall k int :: {&proofCacheEntry.poi.ProofValue[k]} 0 <= k && k < len(proofCacheEntry.poi.ProofValue) ==> acc(&proofCacheEntry.poi.ProofValue[k])) && 
	(forall k int :: {&proofCacheEntry.calculatedLeafHash[k]} 0 <= k && k < len(proofCacheEntry.calculatedLeafHash) ==> acc(&proofCacheEntry.calculatedLeafHash[k]))
}

// verify previously registered proof identified by its proofCache key
preserves acc(proofCache)
preserves forall str string :: {str in domain(proofCache)} str in domain(proofCache) ==> acc_inj_proofCacheEntry(proofCache[str], str)
preserves acc(mapserverInfoCache, _)
preserves forall str string :: {str in domain(mapserverInfoCache)} str in domain(mapserverInfoCache) ==> acc(mapserverInfoCache[str]) && acc(mapserverInfoCache[str].publicKey)
ensures res != nil ==> exists str string :: proofCacheKey in domain(proofCache) ==> proofCache[proofCacheKey] == res
func VerifyProof(proofCacheKey string) (res *ProofCacheEntry) { // added name to return param

	proofCacheEntry, inCache := proofCache[proofCacheKey]

	// if the proof is not yet cached, it cannot be verified
	if !inCache {
		return nil
	}
	unfold acc_inj_proofCacheEntry(proofCacheEntry, proofCacheKey)

	poi := proofCacheEntry.poi

	// if the same proof was already evaluated,
	// return result of previous evaluation
	if proofCacheEntry.evaluated {
		fold acc_inj_proofCacheEntry(proofCacheEntry, proofCacheKey)
		return proofCacheEntry
	}

	if poi.ProofType == mapCommon.PoP {
		// for PoP, check that the leaf hash can be reconstructed from the response
		if !bytes.Equal(poi.ProofValue, proofCacheEntry.calculatedLeafHash) {
			proofCacheEntry.result = false
			proofCacheEntry.evaluated = true
			proofCacheEntry.lastError = fmt.Errorf("MHT leaf hashes do not match: %x (provided by mapserver) %x (calculated)", poi.ProofValue, proofCacheEntry.calculatedLeafHash)
			fold acc_inj_proofCacheEntry(proofCacheEntry, proofCacheKey)
			return proofCacheEntry
		}
	} else {
		// for PoA, ensure that no certificates were returned for this leaf
		if len(proofCacheEntry.sortedCertificateHashes) > 0 {
			proofCacheEntry.result = false
			proofCacheEntry.evaluated = true
			proofCacheEntry.lastError = fmt.Errorf("Returned non-inclusion proof with existing certificates")
			fold acc_inj_proofCacheEntry(proofCacheEntry, proofCacheKey)
			return proofCacheEntry
		}
	}

	// compute MHT root based on the proof and compare against received MHT root
	if poi.ProofType == mapCommon.PoP {
		if !trie.VerifyInclusion(poi.Root, poi.Proof, proofCacheEntry.calculatedProofKey, poi.ProofValue) {
			proofCacheEntry.result = false
			proofCacheEntry.evaluated = true
			proofCacheEntry.lastError = fmt.Errorf("Failed to validate inclusion proof")
			fold acc_inj_proofCacheEntry(proofCacheEntry, proofCacheKey)
			return proofCacheEntry
		}
	} else {
		if !trie.VerifyNonInclusion(poi.Root, poi.Proof, proofCacheEntry.calculatedProofKey, poi.ProofValue, poi.ProofKey) {
			proofCacheEntry.result = false
			proofCacheEntry.evaluated = true
			proofCacheEntry.lastError = fmt.Errorf("Failed to validate non-inclusion proof")
			fold acc_inj_proofCacheEntry(proofCacheEntry, proofCacheKey)
			return proofCacheEntry
		}
	}

	// verify the STH signature
	err := crypto.VerifySignedBytes(poi.Root, proofCacheEntry.treeHeadSignature, mapserverInfoCache[proofCacheEntry.mapserverID].publicKey)
	if err != nil {
		proofCacheEntry.result = false
		proofCacheEntry.evaluated = true
		proofCacheEntry.lastError = fmt.Errorf("Failed to verify signature: %s", err)
		fold acc_inj_proofCacheEntry(proofCacheEntry, proofCacheKey)
		return proofCacheEntry
	}

	proofCacheEntry.result = true
	proofCacheEntry.evaluated = true
	fold acc_inj_proofCacheEntry(proofCacheEntry, proofCacheKey)
	return proofCacheEntry
}
