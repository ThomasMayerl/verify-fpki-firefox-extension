package cache_v2

import (
	"bytes"
	"crypto/rsa"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"log"
	"sort"

	"fpki/pkg/common"
	"fpki/pkg/common/crypto"
	mapCommon "fpki/pkg/mapserver/common"
	"fpki/pkg/mapserver/trie"
	"fpki/pkg/util"
)

type MapServerInfo struct {
	// some identifier of the map server
	identifier string

	// TODO: allow for other algorithms than RSA
	// the public key used to verify the map server's MHT signature
	publicKey *rsa.PublicKey
}

type ProofCacheEntry struct {
	// inclusion proof
	poi *mapCommon.PoI

	// the map server's tree head signature
	treeHeadSignature []byte

	// the certificate hashes included in the map server's response
	// used to check whether the leaf in the proof is the expected one
	// sorted based on their byte representation
	sortedCertificateHashes []*([common.SHA256Size]byte) //[]*common.SHA256Output

	// leaf hash (i.e., sha256 hash of sorted concatenated certificate hashes)
	calculatedLeafHash []byte

	// proof key value (i.e., sha256 hash of domain)
	calculatedProofKey []byte

	// map server that sent the inclusion proof
	mapserverID string

	// true if the proof has been validated
	evaluated bool

	// the result of proof validation if the proof
	// has been evaluated
	result bool

	// the last encountered error (if any error occurred)
	lastError error
}

requires acc(e)
decreases
pure func (e *ProofCacheEntry) Evaluated() bool {
	return e.evaluated
}

requires acc(e)
decreases
pure func (e *ProofCacheEntry) Result() bool {
	return e.result
}

requires acc(e)
decreases
pure func (e *ProofCacheEntry) LastError() error {
	return e.lastError
}

// map server info cache
var mapserverInfoCache@ = map[string]*MapServerInfo{}

// cache mapping base64 encoded (leaf hash + map server identifier) to a ProofCacheEntry
var proofCache@ = map[string]*ProofCacheEntry{}

type MapStrAny map[string]interface{}

requires acc(m)
ensures res === let elem, ok := m[str] in elem
decreases
pure func getFromMap(m map[string]interface{}, str string) (res interface{})

requires acc(configMap)
requires "mapservers" in domain(configMap)
requires let conf, _ := configMap["mapservers"] in typeOf(conf) == type[[]MapStrAny]
requires let conf, _ := configMap["mapservers"] in (let mapserversJSON := conf.([]MapStrAny) in (forall k int :: {&mapserversJSON[k]} 0 <= k && k < len(mapserversJSON) ==> acc(&mapserversJSON[k]) && acc(mapserversJSON[k]) && let e := mapserversJSON[k] in ("identity" in domain(e) && typeOf(getFromMap(e, "identity")) == type[string] && "publickey" in domain(e) && typeOf(getFromMap(e, "publickey")) == type[string])))
requires acc(&mapserverInfoCache)
requires acc(&proofCache)
ensures acc(configMap)
ensures acc(&mapserverInfoCache)
ensures acc(&proofCache)
ensures acc(mapserverInfoCache)
ensures forall str string :: {mapserverInfoCache[str]} str in mapserverInfoCache ==> acc(mapserverInfoCache[str]) && acc(mapserverInfoCache[str].publicKey)
ensures acc(proofCache) && len(proofCache) == 0
ensures ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
ensures let conf, _ := configMap["mapservers"] in typeOf(conf) == type[[]MapStrAny]
ensures let conf, _ := configMap["mapservers"] in (let mapserversJSON := conf.([]MapStrAny) in (forall k int :: {&mapserversJSON[k]} 0 <= k && k < len(mapserversJSON) ==> acc(&mapserversJSON[k]) && acc(mapserversJSON[k]) && let e := mapserversJSON[k] in ("identity" in domain(e) && typeOf(getFromMap(e, "identity")) == type[string] && "publickey" in domain(e) && typeOf(getFromMap(e, "publickey")) == type[string])))
func InitializeMapserverInfoCache(configMap map[string]interface{}) bool {
	mapserverInfoCache = map[string]*MapServerInfo{}
	proofCache = map[string]*ProofCacheEntry{}

	identities := []string{}
	//mapserversJSON := configMap["mapservers"].([]interface{})
	tmp, _ := configMap["mapservers"]
	// VERIFY: we directly cast it to [](map[string]interface{}) instead of casting it to []interface{} and then again
	mapserversJSON := tmp.([]MapStrAny)

	fold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))

	invariant acc(&mapserverInfoCache)
	invariant acc(&proofCache)
	invariant acc(mapserverInfoCache)
	invariant forall str string :: {mapserverInfoCache[str]} str in mapserverInfoCache ==> acc(mapserverInfoCache[str]) && acc(mapserverInfoCache[str].publicKey)
	invariant acc(proofCache) && len(proofCache) == 0
	invariant ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
	invariant forall k int :: {&mapserversJSON[k]} 0 <= k && k < len(mapserversJSON) ==> acc(&mapserversJSON[k]) && acc(mapserversJSON[k]) && let e := mapserversJSON[k] in ("identity" in domain(e) && typeOf(getFromMap(e, "identity")) == type[string] && "publickey" in domain(e) && typeOf(getFromMap(e, "publickey")) == type[string])
	invariant forall k int :: {&identities[k]} 0 <= k && k < len(identities) ==> acc(&identities[k])
	for _, entryInterface := range mapserversJSON {
		entry := entryInterface // VERIFY: nothing really happens here because we already casted above
		identity/*, _*/ := entry["identity"] // TODO WHY DO WE NOT GET TWO THINGS BACK?
		id := identity.(string)
		publicKeyDERBase64/*, ok*/ := entry["publickey"] // TODO WHY DO WE NOT GET TWO THINGS BACK?
		//if ok {
			publicKey, err := util.DERBase64ToRSAPublic(publicKeyDERBase64.(string))
			if err != nil {
				log.Panicf("Cannot extract RSA public key from DER: %s", err)
			}
			unfold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
			mapserverInfoCache[id] = &MapServerInfo{identifier: id, publicKey: publicKey}
			fold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
			identities = append(perm(1), identities, id)
			
		/*} else {
			fmt.Printf("Ignoring map server without public key: %s\n", id)
		}*/
	}
	fmt.Printf("Added %d map servers: %s\n", len(identities), identities)
	return true
}

// MHT proof verifications are cached to ensure they only need to be verified once.
// The key is calculated as follows: hash(hash(domain), hash(leaf), mapserverID)
preserves acc_bytes(proofKey)
preserves acc_bytes(leafHash)
ensures err != nil ==> err.ErrorMem()
func GetProofCacheKey(proofKey []byte, leafHash []byte, mapserverID string) (res string, err error) { // added return param names
	h := sha256.New()
	unfold acc_bytes(proofKey)
	_, err := h.Write(proofKey)
	fold acc_bytes(proofKey)
	if err != nil {
		return "", fmt.Errorf("Failed to write proof key: %s", err)
	}
	unfold acc_bytes(leafHash)
	_, err = h.Write(leafHash)
	fold acc_bytes(leafHash)
	if err != nil {
		return "", fmt.Errorf("Failed to write leaf hash: %s", err)
	}
	_, err = h.Write([]byte(mapserverID))
	if err != nil {
		return "", fmt.Errorf("Failed to write mapserver ID: %s", err)
	}
	hash := h.Sum(nil)
	return base64.StdEncoding.EncodeToString(hash), nil
}

// add a new cache entry for this map server response if it does not exist yet and return the key used in the cache
requires forall k int :: {&certIDs[k]} 0 <= k && k < len(certIDs) ==> acc(&certIDs[k]) && acc(certIDs[k])
requires forall k int :: {&policyIDs[k]} 0 <= k && k < len(policyIDs) ==> acc(&policyIDs[k]) && acc(policyIDs[k])
//requires forall k int :: {&certIDs[k]} 0 <= k && k < len(certIDs) ==> (forall l int :: {&policyIDs[l]} 0 <= l && l < len(policyIDs) ==> certIDs[k] != policyIDs[l])
requires acc(response.DomainEntry)
requires acc_bytes(response.PoI.ProofKey)
requires acc_bytes(response.PoI.ProofValue)
requires acc_bytes(response.TreeHeadSig)
requires acc(&mapserverInfoCache, 1/2)
requires acc(mapserverInfoCache, 1/2)
requires mapserverID in domain(mapserverInfoCache)
requires acc(&proofCache)
requires acc(proofCache)
requires ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
requires forall str string :: {mapserverInfoCache[str]} str in mapserverInfoCache ==> acc(mapserverInfoCache[str], 1/2) && acc(mapserverInfoCache[str].publicKey, 1/2)
ensures acc(response.DomainEntry)
ensures acc(&mapserverInfoCache, 1/2)
ensures acc(mapserverInfoCache, 1/2)
ensures mapserverID in domain(mapserverInfoCache)
ensures acc(&proofCache)
ensures acc(proofCache)
ensures ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
ensures forall str string :: {mapserverInfoCache[str]} str in mapserverInfoCache ==> acc(mapserverInfoCache[str], 1/2) && acc(mapserverInfoCache[str].publicKey, 1/2)
ensures err == nil ==> res in domain(proofCache)
ensures err != nil ==> err.ErrorMem()
func AddMapServerResponseToCacheIfNecessary(response mapCommon.MapServerResponse, certIDs, policyIDs [](*[common.SHA256Size]byte), mapserverID string) (res string, err error) { // add names to return parameters
//func AddMapServerResponseToCacheIfNecessary(response mapCommon.MapServerResponse, certIDs, policyIDs []*common.SHA256Output, mapserverID string) (res string, err error) /*{ // add names to return parameters
	// merge and sort cert and policy IDs
	ids@ := append(perm(1/2), certIDs[:0:0], certIDs...)
	ids = append(perm(1/2), ids, policyIDs...)
	sort.Slice(ids, 
		requires acc(&ids, 1/2)
		requires 0 <= i && i < len(ids)
		requires 0 <= j && j < len(ids)
		requires forall k int :: 0 <= k && k < len(ids) ==> acc(&ids[k], 1/2) && acc(ids[k], 1/2)
		ensures acc(&ids, 1/2)
		ensures forall k int :: 0 <= k && k < len(ids) ==> acc(&ids[k], 1/2) && acc(ids[k], 1/2)
		func(i, j int) bool {
		return bytes.Compare(ids[i][:], ids[j][:]) == -1
	})

	// generate proof key
	proofKey := common.SHA256Hash([]byte(response.DomainEntry.DomainName))

	// calculate leaf hash to compare leaf values in PoPs (ignored in PoAs)
	concatenatedLeafHashes := common.IDsToBytes(ids)
	leafHash := common.SHA256Hash(concatenatedLeafHashes)

	// add entry to cache if necessary
	fold acc_bytes(proofKey)
	fold acc_bytes(leafHash)
	proofCacheKey, err := GetProofCacheKey(proofKey, leafHash, mapserverID)
	if err != nil {
		return "", err
	}
	if _, ok := proofCache[proofCacheKey]; !ok {
		unfold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
		//proofCache[proofCacheKey] = newProofCacheEntry(&response.PoI, proofKey, mapserverID, response.TreeHeadSig, ids, leafHash, proofCacheKey)
		resp@ := response // TODO IS THIS CORRECT? to make referencable
		fold acc_PoI(&resp.PoI)
		fold acc_SortedCertificateHashes(ids)
		proofCache[proofCacheKey] = newProofCacheEntry(&resp.PoI, proofKey, mapserverID, response.TreeHeadSig, ids, leafHash, proofCacheKey)
		fold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
	}
	return proofCacheKey, nil
}

// helper function to allocate a new ProofCacheEntry
requires acc_PoI(poi)
requires acc_bytes(leafHash)
requires acc_bytes(treeHeadSignature)
requires acc_bytes(proofKey)
requires acc_SortedCertificateHashes(sortedCertificateHashes)
requires acc(&mapserverInfoCache, 1/4)
requires acc(mapserverInfoCache, 1/4)
requires mapserverID in mapserverInfoCache
requires forall str string :: {mapserverInfoCache[str]} str in mapserverInfoCache ==> acc(mapserverInfoCache[str], 1/2) && acc(mapserverInfoCache[str].publicKey, 1/2)
ensures acc(&mapserverInfoCache, 1/4)
ensures acc(mapserverInfoCache, 1/4)
ensures forall str string :: {mapserverInfoCache[str]} str in mapserverInfoCache ==> acc(mapserverInfoCache[str], 1/2) && acc(mapserverInfoCache[str].publicKey, 1/2)
ensures ProofCachePermissions_entry(res, key, dict(mapserverInfoCache))
func newProofCacheEntry(poi *mapCommon.PoI, proofKey []byte, mapserverID string, treeHeadSignature []byte,
	sortedCertificateHashes []*([common.SHA256Size]byte)/*[]*common.SHA256Output*/, leafHash []byte, ghost key string) (res *ProofCacheEntry) { // name return param
	proofCacheEntry@ := ProofCacheEntry{
		poi:                     poi,
		treeHeadSignature:       treeHeadSignature,
		sortedCertificateHashes: sortedCertificateHashes,
		calculatedLeafHash:      leafHash,
		calculatedProofKey:      proofKey,
		mapserverID:             mapserverID,
		evaluated:               false,
		result:                  false,
		lastError:               nil,
	}
	defer fold ProofCachePermissions_entry(&proofCacheEntry, key, dict(mapserverInfoCache))
	return &proofCacheEntry
}

// verify previously registered proof identified by its proofCache key
preserves acc(&mapserverInfoCache, 1/2)
preserves acc(&proofCache, 1/2)
preserves acc(mapserverInfoCache, 1/2)
preserves forall str string :: {mapserverInfoCache[str]} str in mapserverInfoCache ==> acc(mapserverInfoCache[str], 1/2) && acc(mapserverInfoCache[str].publicKey, 1/2)
preserves acc(proofCache, 1/2)
preserves ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
ensures res != nil ==> exists str string :: proofCacheKey in domain(proofCache) ==> proofCache[proofCacheKey] == res
func VerifyProof(proofCacheKey string) (res *ProofCacheEntry) { // added name to return param

	proofCacheEntry, inCache := proofCache[proofCacheKey]

	// if the proof is not yet cached, it cannot be verified
	if !inCache {
		return nil
	}
	unfold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
	unfold ProofCachePermissions_entry(proofCacheEntry, proofCacheKey, dict(mapserverInfoCache))

	poi := proofCacheEntry.poi
	unfold acc_PoI(poi)

	// if the same proof was already evaluated,
	// return result of previous evaluation
	if proofCacheEntry.evaluated {
		fold acc_PoI(poi)
		fold ProofCachePermissions_entry(proofCacheEntry, proofCacheKey, dict(mapserverInfoCache))
		fold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
		return proofCacheEntry
	}

	if poi.ProofType == mapCommon.PoP {
		// for PoP, check that the leaf hash can be reconstructed from the response
		unfold acc_bytes(poi.ProofValue)
		unfold acc_bytes(proofCacheEntry.calculatedLeafHash)
		if !bytes.Equal(poi.ProofValue, proofCacheEntry.calculatedLeafHash) {
			fold acc_bytes(poi.ProofValue)
			fold acc_bytes(proofCacheEntry.calculatedLeafHash)
			proofCacheEntry.result = false
			proofCacheEntry.evaluated = true
			proofCacheEntry.lastError = fmt.Errorf("MHT leaf hashes do not match: %x (provided by mapserver) %x (calculated)", poi.ProofValue, proofCacheEntry.calculatedLeafHash)
			fold acc_PoI(poi)
			fold ProofCachePermissions_entry(proofCacheEntry, proofCacheKey, dict(mapserverInfoCache))
			fold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
			return proofCacheEntry
		}
		fold acc_bytes(poi.ProofValue)
		fold acc_bytes(proofCacheEntry.calculatedLeafHash)
	} else {
		// for PoA, ensure that no certificates were returned for this leaf
		if len(proofCacheEntry.sortedCertificateHashes) > 0 {
			proofCacheEntry.result = false
			proofCacheEntry.evaluated = true
			proofCacheEntry.lastError = fmt.Errorf("Returned non-inclusion proof with existing certificates")
			fold acc_PoI(poi)
			fold ProofCachePermissions_entry(proofCacheEntry, proofCacheKey, dict(mapserverInfoCache))
			fold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
			return proofCacheEntry
		}
	}

	// compute MHT root based on the proof and compare against received MHT root
	if poi.ProofType == mapCommon.PoP {
		if !trie.VerifyInclusion(poi.Root, poi.Proof, proofCacheEntry.calculatedProofKey, poi.ProofValue) {
			proofCacheEntry.result = false
			proofCacheEntry.evaluated = true
			proofCacheEntry.lastError = fmt.Errorf("Failed to validate inclusion proof")
			fold acc_PoI(poi)
			fold ProofCachePermissions_entry(proofCacheEntry, proofCacheKey, dict(mapserverInfoCache))
			fold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
			return proofCacheEntry
		}
	} else {
		if !trie.VerifyNonInclusion(poi.Root, poi.Proof, proofCacheEntry.calculatedProofKey, poi.ProofValue, poi.ProofKey) {
			proofCacheEntry.result = false
			proofCacheEntry.evaluated = true
			proofCacheEntry.lastError = fmt.Errorf("Failed to validate non-inclusion proof")
			fold acc_PoI(poi)
			fold ProofCachePermissions_entry(proofCacheEntry, proofCacheKey, dict(mapserverInfoCache))
			fold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
			return proofCacheEntry
		}
	}

	// verify the STH signature
	err := crypto.VerifySignedBytes(poi.Root, proofCacheEntry.treeHeadSignature, mapserverInfoCache[proofCacheEntry.mapserverID].publicKey)
	if err != nil {
		proofCacheEntry.result = false
		proofCacheEntry.evaluated = true
		proofCacheEntry.lastError = fmt.Errorf("Failed to verify signature: %s", err)
		fold acc_PoI(poi)
		fold ProofCachePermissions_entry(proofCacheEntry, proofCacheKey, dict(mapserverInfoCache))
		fold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
		return proofCacheEntry
	}

	proofCacheEntry.result = true
	proofCacheEntry.evaluated = true
	fold acc_PoI(poi)
	fold ProofCachePermissions_entry(proofCacheEntry, proofCacheKey, dict(mapserverInfoCache))
	fold ProofCachePermissions(dict(proofCache), dict(mapserverInfoCache))
	return proofCacheEntry
}
